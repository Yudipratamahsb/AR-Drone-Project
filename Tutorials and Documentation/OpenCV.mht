From: "Saved by Windows Internet Explorer 9"
Subject: =?Windows-1252?Q?Welcome_to_opencv_documentation!_=97_OpenCV_v2.4.2_docum?=
	=?Windows-1252?Q?entation?=
Date: Thu, 6 Sep 2012 23:43:35 -0500
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01CD8C89.6E361A20"
X-MimeOLE: Produced By Microsoft MimeOLE V6.1.7601.17609

This is a multi-part message in MIME format.

------=_NextPart_000_0000_01CD8C89.6E361A20
Content-Type: text/html;
	charset="utf-8"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://docs.opencv.org/index.html

=EF=BB=BF<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" =
"http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" =
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><HTML><HEAD>
<SCRIPT type=3D"text/javascript">=0A=
=0A=
  var _gaq =3D _gaq || [];=0A=
  _gaq.push(['_setAccount', 'UA-33108845-1']);=0A=
  _gaq.push(['_setDomainName', 'opencv.org']);=0A=
  _gaq.push(['_trackPageview']);=0A=
=0A=
  (function() {=0A=
    var ga =3D document.createElement('script'); ga.type =3D =
'text/javascript'; ga.async =3D true;=0A=
    ga.src =3D ('https:' =3D=3D document.location.protocol ? =
'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';=0A=
    var s =3D document.getElementsByTagName('script')[0]; =
s.parentNode.insertBefore(ga, s);=0A=
  })();=0A=
=0A=
</SCRIPT>

<META content=3D"text/html; charset=3Dutf-8"=20
http-equiv=3D"Content-Type"><TITLE>Welcome to opencv documentation! =
=E2=80=94 OpenCV=20
v2.4.2 documentation</TITLE><LINK rel=3D"stylesheet" type=3D"text/css" =
href=3D"http://docs.opencv.org/_static/default.css"><LINK=20
rel=3D"stylesheet" type=3D"text/css" =
href=3D"http://docs.opencv.org/_static/pygments.css">
<SCRIPT type=3D"text/javascript">=0A=
      var DOCUMENTATION_OPTIONS =3D {=0A=
        URL_ROOT:    '',=0A=
        VERSION:     '2.4.2',=0A=
        COLLAPSE_INDEX: false,=0A=
        FILE_SUFFIX: '.html',=0A=
        HAS_SOURCE:  true=0A=
      };=0A=
    </SCRIPT>

<SCRIPT type=3D"text/javascript" =
src=3D"http://docs.opencv.org/_static/jquery.js"></SCRIPT>

<SCRIPT type=3D"text/javascript" =
src=3D"http://docs.opencv.org/_static/underscore.js"></SCRIPT>

<SCRIPT type=3D"text/javascript" =
src=3D"http://docs.opencv.org/_static/doctools.js"></SCRIPT>

<SCRIPT type=3D"text/javascript" =
src=3D"http://docs.opencv.org/_static/insertIframe.js"></SCRIPT>
<LINK title=3D"OpenCV v2.4.2 documentation" rel=3D"top" href=3D"#"><LINK =
title=3D"OpenCV API Reference"=20
rel=3D"next" href=3D"modules/refman.html">
<META name=3D"GENERATOR" content=3D"MSHTML 9.00.8112.16448"></HEAD>
<BODY>
<DIV class=3D"related">
<H3>Navigation</H3>
<UL>
  <LI style=3D"margin-right: 10px;" class=3D"right"><A accessKey=3D"I" =
title=3D"General Index"=20
  href=3D"http://docs.opencv.org/genindex.html">index</A></LI>
  <LI class=3D"right"><A title=3D"Python Module Index" =
href=3D"http://docs.opencv.org/py-modindex.html">modules</A>=20
  |</LI>
  <LI class=3D"right"><A accessKey=3D"N" title=3D"OpenCV API Reference" =
href=3D"http://docs.opencv.org/modules/refman.html">next</A>=20
  |</LI>
  <LI><A href=3D"http://docs.opencv.org/index.html#">OpenCV v2.4.2=20
  documentation</A> =C2=BB</LI></UL></DIV>
<DIV class=3D"document">
<DIV class=3D"documentwrapper">
<DIV class=3D"bodywrapper">
<DIV class=3D"body">
<DIV id=3D"welcome-to-opencv-documentation" class=3D"section">
<H1>Welcome to opencv documentation!<A class=3D"headerlink" =
title=3D"Permalink to this headline"=20
href=3D"http://docs.opencv.org/index.html#welcome-to-opencv-documentation=
">=C2=B6</A></H1>
<DIV class=3D"toctree-wrapper compound">
<UL>
  <LI class=3D"toctree-l1"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/refman.html">OpenCV=20
  API Reference</A>
  <UL>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/core/doc/intro.html">Introduction<=
/A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/core/doc/core.html">core.=20
    The Core Functionality</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/imgproc/doc/imgproc.html">imgproc.=
=20
    Image Processing</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/highgui/doc/highgui.html">highgui.=
=20
    High-level GUI and Media I/O</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/video/doc/video.html">video.=20
    Video Analysis</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/calib3d/doc/calib3d.html">calib3d.=
=20
    Camera Calibration and 3D Reconstruction</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/features2d/doc/features2d.html">fe=
atures2d.=20
    2D Features Framework</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/objdetect/doc/objdetect.html">objd=
etect.=20
    Object Detection</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/ml/doc/ml.html">ml.=20
    Machine Learning</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/flann/doc/flann.html">flann.=20
    Clustering and Search in Multi-Dimensional Spaces</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/gpu/doc/gpu.html">gpu.=20
    GPU-accelerated Computer Vision</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/photo/doc/photo.html">photo.=20
    Computational Photography</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/stitching/doc/stitching.html">stit=
ching.=20
    Images stitching</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/nonfree/doc/nonfree.html">nonfree.=
=20
    Non-free functionality</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/contrib/doc/contrib.html">contrib.=
=20
    Contributed/Experimental Stuff</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/modules/legacy/doc/legacy.html">legacy.=20
    Deprecated stuff</A></LI></UL></LI>
  <LI class=3D"toctree-l1"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/android/refman.html">OpenCV4Android=20
  Reference</A>
  <UL>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/android/service/doc/index.html">Android=20
    OpenCV Manager</A></LI></UL></LI>
  <LI class=3D"toctree-l1"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/user_guide/user_guide.html">OpenCV=20
  User Guide</A>
  <UL>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/user_guide/ug_mat.html">Operations=20
    with images</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/user_guide/ug_features2d.html">Feature=
s2d</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/user_guide/ug_highgui.html">HighGUI</A=
></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/user_guide/ug_traincascade.html">Casca=
de=20
    Classifier Training</A></LI></UL></LI>
  <LI class=3D"toctree-l1"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/tutorials.html">OpenCV=20
  Tutorials</A>
  <UL>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/introduction/table_of_conten=
t_introduction/table_of_content_introduction.html">Introduction=20
    to OpenCV</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/core/table_of_content_core/t=
able_of_content_core.html"><EM>core</EM>=20
    module. The Core Functionality</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/imgproc/table_of_content_img=
proc/table_of_content_imgproc.html"><EM>imgproc</EM>=20
    module. Image Processing</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/highgui/table_of_content_hig=
hgui/table_of_content_highgui.html"><EM>highgui</EM>=20
    module. High Level GUI and Media</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/calib3d/table_of_content_cal=
ib3d/table_of_content_calib3d.html"><EM>calib3d</EM>=20
    module. Camera calibration and 3D reconstruction</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/features2d/table_of_content_=
features2d/table_of_content_features2d.html"><EM>feature2d</EM>=20
    module. 2D Features framework</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/video/table_of_content_video=
/table_of_content_video.html"><EM>video</EM>=20
    module. Video analysis</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/objdetect/table_of_content_o=
bjdetect/table_of_content_objdetect.html"><EM>objdetect</EM>=20
    module. Object Detection</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/ml/table_of_content_ml/table=
_of_content_ml.html"><EM>ml</EM>=20
    module. Machine Learning</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/gpu/table_of_content_gpu/tab=
le_of_content_gpu.html"><EM>gpu</EM>=20
    module. GPU-Accelerated Computer Vision</A></LI>
    <LI class=3D"toctree-l2"><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/doc/tutorials/general/table_of_content_gen=
eral/table_of_content_general.html">General=20
    tutorials</A></LI></UL></LI></UL></DIV></DIV>
<DIV id=3D"indices-and-tables" class=3D"section">
<H1>Indices and tables<A class=3D"headerlink" title=3D"Permalink to this =
headline"=20
href=3D"http://docs.opencv.org/index.html#indices-and-tables">=C2=B6</A><=
/H1>
<UL class=3D"simple">
  <LI><A class=3D"reference internal"=20
  href=3D"http://docs.opencv.org/genindex.html"><EM>Index</EM></A></LI>
  <LI><A class=3D"reference internal"=20
  href=3D"http://docs.opencv.org/search.html"><EM>Search =
Page</EM></A></LI></UL>
</DIV></DIV>
<DIV class=3D"feedback">
<H2>Help and Feedback</H2>              You did not find what you were =
looking=20
for?             =20
<UL>
  <LI>Ask a question in the <A=20
  href=3D"http://tech.groups.yahoo.com/group/OpenCV/">user group/mailing =

  list</A>.</LI>
  <LI>If you think something is missing or wrong in the documentation,   =
       =20
         please file a <A href=3D"http://code.opencv.org/">bug=20
report</A>.</LI></UL></DIV></DIV></DIV>
<DIV class=3D"sphinxsidebar">
<DIV class=3D"sphinxsidebarwrapper">
<P class=3D"logo"><A href=3D"http://docs.opencv.org/index.html#"><IMG =
class=3D"logo"=20
alt=3D"Logo" =
src=3D"http://docs.opencv.org/_static/opencv-logo-white.png"></A></P>
<DIV style=3D"display: none;" id=3D"searchbox">
<FORM class=3D"search" method=3D"get" action=3D"search.html"><INPUT =
name=3D"q" size=3D"18"=20
type=3D"text"><INPUT value=3D"Search" type=3D"submit"><INPUT =
name=3D"check_keywords"=20
value=3D"yes" type=3D"hidden"><INPUT name=3D"area" value=3D"default" =
type=3D"hidden">
<P></P></FORM></DIV>
<SCRIPT type=3D"text/javascript">$('#searchbox').show(0);</SCRIPT>

<H3><A href=3D"http://docs.opencv.org/index.html#">Table Of =
Contents</A></H3>
<UL>
  <LI><A class=3D"reference internal"=20
  href=3D"http://docs.opencv.org/index.html#">Welcome to opencv =
documentation!</A>
  <UL></UL></LI>
  <LI><A class=3D"reference internal" =
href=3D"http://docs.opencv.org/index.html#indices-and-tables">Indices=20
  and tables</A></LI></UL>
<H4>Next topic</H4>
<P class=3D"topless"><A title=3D"next chapter" =
href=3D"http://docs.opencv.org/modules/refman.html">OpenCV=20
API Reference</A></P>
<H3>This Page</H3>
<UL class=3D"this-page-menu">
  <LI><A href=3D"http://docs.opencv.org/_sources/index.txt" =
rel=3D"nofollow">Show=20
  Source</A></LI></UL></DIV></DIV>
<DIV class=3D"clearer"></DIV></DIV>
<DIV class=3D"related">
<H3>Navigation</H3>
<UL>
  <LI style=3D"margin-right: 10px;" class=3D"right"><A title=3D"General =
Index" href=3D"http://docs.opencv.org/genindex.html">index</A></LI>
  <LI class=3D"right"><A title=3D"Python Module Index" =
href=3D"http://docs.opencv.org/py-modindex.html">modules</A>=20
  |</LI>
  <LI class=3D"right"><A title=3D"OpenCV API Reference" =
href=3D"http://docs.opencv.org/modules/refman.html">next</A>=20
  |</LI>
  <LI><A href=3D"http://docs.opencv.org/index.html#">OpenCV v2.4.2=20
  documentation</A> =C2=BB</LI></UL></DIV>
<DIV class=3D"footer">        =C2=A9 Copyright 2011-2012, opencv dev =
team.      Last=20
updated on Jul 04, 2012.      Created using <A=20
href=3D"http://sphinx.pocoo.org/">Sphinx</A> 1.0.7.    =
</DIV></BODY></HTML>

------=_NextPart_000_0000_01CD8C89.6E361A20
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: http://docs.opencv.org/_static/opencv-logo-white.png

iVBORw0KGgoAAAANSUhEUgAAALQAAADeCAYAAACUoioOAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A
/wD/oL2nkwAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB9wEAgwUAaYSBhgAAB8jSURBVHja
7Z15vF1Fle+/tXMzQIBAmJIQhgBBBsMoU1RooG1FwiAqSutTsJFm6kbx+Xjdr/1gozwbbUGm17Qj
oN0KiA2IDTYSBpnH+BhDCCSMCUMgIRMZ1q//OPvc7Jycvc8+w659zrm17mfn3pyz965aVb9atdaq
VascgdoiwXhgS8HWwBQH7xNs42BLYJea2xcBrwheczBb8DSV62Xg5QjeCS0ayBdwB8lgU8G/GJiB
ac0lgWzNNfhZ7feJv5PPvmjwHYP165UbKFAnAb2b4ArBrFpQduhKgl8GMwU3GkxKDKRAgZonWwPi
UYKjBDMKAHAz1xMGBwkGQu8EahXMJxosSKgNVhKYB8s3WCg4OUjrQLmBbPAZwXMqVyI3umYbfDT0
WqAsHXlrwd0lS+PcV6wC3SnYJhiPgdbyIAi+kmacdfFlMahXCT4RejOAGcEwwe+st4CcJrGvD706
tKXypoJnexnEdVSQuQYTh3L/uiEK6vGC2Q7W67OxWu3PnR3MHIp9Gw1BMB8seIX+AnNSOAl4QvCZ
MB/3v5qxT7+oGDkNxsOCytG/oN5eMMsNvVnpMAfTA6D7y5uxtYMXh+LkJFgBTIlgVgB0/4B6CYkI
tiFIJhjrYGG/d3jfTr+JmIw7hziYBUQOrhsK0ivqZ8assgJ40BC3ias4PszgvKSRHFSO3hJLO1PZ
DSKGqL+9jqR+D9jewWsB0L3Xe88A7ws4XoeWu/7zwfe3yiE4UwHMaTRKcGqQ0L0DZkdlJXBcUDXS
m6lf/fH9yNR3qezEDmDOEGSCy4OE7nKLB9gMeCMYgo2bS/BuBGP6raGiPhuZnyt7oKqOV0x0navM
OdhIcF6/jfq+4kewusxBmpB284GbqWzpesHBMsFoV0lJcDBwFLBh2TOaq6wgjolgcZi0ug/MX7Zy
I9vmCv5WiTwaWWSwi+BswbySNwYcE9DTnYC+z/M2qmpZCwVntVN3g28bvFUSoB8J6OkiSsRsrCgB
ELcajOrQgBwQ/LakjboTA5K6SzofWwKYz6WDxl5iE8L/LgHU5wcUdRegn/KpZlhB25sSoP5Hz6rT
gwFF3QPmjbVups8ir0uSqk6BfJ3nUY9e0MnZJlAb+rPB3h6l2TOewIxVYi4WeuRtQj9gIuqDyu/i
y28LnOmj0VyljOWCHWq0kSLppADo7iAvAfwOrnfwe5+zTwRvArfgYQFMcHSY87tDh57haUqeWpJa
tZ+nrEvv9QMeXB8AehUwrOBiVgIjXHk8etmsINg4goVB5SjPKBxeNJhj5fWCkkf+TzxJt7FBhy6X
tlPxnYzgpyXOQAD3eSpuwwDocmlzVzygVkbwbFlHQMQD6lVPg2e9AOhyyYfvdFHZDeXihQ8PNCIA
utyOHu5B5VjeBay+F/AwBBgYQvusXN8UEgCd2QGrPBQzqgtYHelJQKwOgC5XQs/3UMwmCW9DWXxu
7klAvBcAXa6EfsMDmCJVDqUvk88tPQ2cZQHQ5dIcT+WcUvJMdLCnohYFY6NkskoWoKJpObCBK0nH
FLyOB7VDsEFUyaUdJHSJI/JZT4bhfiUN2I/hR4de3etg7gtAC+7xVM43Sxqw58gPf7fSB9QPEvou
T0X9heAQz4N1suAA56cdf9kPgO5pHTpOsbWv87PJU1RiKrZ2BXvx4pdHgtXO3/rRZg7eChK65NHo
4HmthYNCi9sKuKnowmL0/tj5EzqvO3jLCNQtkvo5n2m/DL5RkAFY/X2O5xwj0wOKuogMvmT+D4q/
yAqQnoJvlZA05/SAou6S0JEqGT59J2h8QrBBB/l4tIxUYOYpViTo0Pl1ThP8yWeRsWjeDZhn8KkO
gPkdYK8SjPU7oj7ZINtvUvrLJWXvVIfqf2FJ9T8soKd7Qb2kBFB8oYP1n19COuBhwbvRvcbhVz2D
+S2DEdY5QH/U/OrQXw+o6V7pjGCcJzBUy9ilAD7meqr/O0lXYTAKu88wxFWOd/CR69gJ7nLwdAEL
LHt7GPwO+FlfAaBfpXT8+60iJXW8uLJdgarT1QVL6HkBLb0F7K8UvNDyD0VL0IJVpeMCSnoP1HcV
uPS9oYqv/0kFrXD+KTmbBeoNbweCbQWrCwDE8Z7qP1Lwdoel84o4H2CgHpXSX++kG8zgCZ/STTCl
w268vwuo6H0D8R7rnIT+cAn1v7tDYP5ZQEV/qB8DBrM7AIjrSqr/jta+mjRPsH5YEewTSS2Y2KY+
bQaTrDwevtdG3ZcFI7A/JfUkq4SYtqKPfq/MAWkwppWwUoOVgl1D7/cvqPdvEhRWXYRQ+XX/YpOq
x3seE9QEKlH92KNJUJ/RRQbu000MxN1Cjw8dSb2T5Qs1fbjLBuRhOer8clXNCHrz0JLWozO2PFX/
v7e6bzDeWEdXrtb3GcFmoXeHtrT+tdU/K/y2bpRygh1SBuENqlFRAg09MFd/HyxYWpV2BkutOxKd
p9X74hoJ/dHQm4HqSb9fx56E73f7IIxDZP/DQkhzoCywGLzfemPwja4FeaBAmVKwB0AdKFCgQIEC
BQrzbyD/5LoEjKOppKodB+wO7AHsjJiIY7u1wFo5/HoZjlnAi8BDwGOIOTjewIUNoIHKsbwixCkY
T2GsRKzCMAwN/lidv5R6z+r4PcsR/44lzkQJboBABUnicYgLMB6ugWsSou3/2ODvVxFXYxwQwB2o
UyB2GLsjbkmArbMAzgNw4yWMz2JsGDolULPqRBXMhyIWIFZ7BXCazK78uxwrPyQ0WO/WU4A+EHG7
Zznc7M+riI/3F0h0PNiE7geLLgM7sgfakw0Q/9zlQE7KbNcnQN4Q9Ms4CO+6Lq/zToko3WvBxq7N
S/e07a6IZaXoyK39HN8f0tl2AS2rCZH+SBcD+sa1N6RrOdifd5eubPxzDwA4+bMII+p9j4e+l7Jx
5enu1FM1LX33m11Wfp2NUYj7ewzMQp3P6+wZGKPAbmuwG6uLEjIOqkbPJyRzvWsOaHRZYB6PeKPO
wkd3a84Wnw3ek9JZgI0GLa5IOrP0PbK2CrRp9+imOr3B3uRq1rO3QSN9t+u2GEt7BsZrQ3p8D+vL
40CvNpHN4Lzu0Eu1eQPJXDsgXwcb4wvMO/aYVE7+/GMPqxnrg81Jl8qp6aAndLGu30hib1n0YNsA
saIn5XLl3w17T9UQoPVA77aY3/zOco0t7dZ6Sj4tBhsosm1f7km5XPn5VO9KZ3uwvbTQtm95LjDd
1+aBA8921k+9Zhn7+Z6FsuJTZq3XJDOArulANt2lYMP8N4D2bT+1tQn0SGdnGXF+D+vNQhzUo3rz
J7O9GU1N3yd4ltAjQO917uAEndEpMB/fw5JZGL/oUffc1oljXTpxIsUqsA08AvpvCjjiZv9223UE
4vUelsyGana89A6oHywAENf6MRBtZDGn6dlsUNQOoP/Y09JZfKtHjcAzCzhmMU4KZRt5qP9NBR4T
+Y1WjcFDelhvNsT8jhrHfj0DC5pbiGjqmlUwD+OLq/ug+rV987NMb3s1hDi5Rw3BK4s/rtw+UuBg
nO/huPWfN1u3M3vY3yyMe3tQzQBscmcNwVRAv1MQD4d7qr9AU5twffJcD6sawtirR3XnywqWbMnF
lm8XUP+3/NRfAt2Tz8AVU7sCypahwddPb1D93509CuYRHsFgoEVgwzuoalzosf7Va51QU1cH0EuA
9Ut3wzqWArch7sQxE3gbGAFMonLkwueBLWueWwyMJWJlD+rOlwKney70LnAHtw/oiHgRZTg4n9va
fgduWoYvnz1KjFMWxpuI7yL2zdmW4xFfRdwbv+e7vbmIAmAvFujZyFqB27t9QOuuEqRzNX5643RX
VgVMZcB5OeKHbbbrNHqWtH05YNAS0JfbrLsD/XUlXsQ7qAV2dJawKENLfhqxJUOa7JYSwPD/QWM7
t3KokcWsbja8bk8D8zSPxmC1pMsY8qQNYjeUeZTMNxfoh76iBCk9ol59rvMsoX/Seyt5hQB6f88A
mNE5qZzq9/0vj2AW2Gn16jLTm+/ZuClI5sGGP9uf3myzQIXuAElISI/qh91UZ5GKlR5VjU2CZB4E
wW3+JJn282gX7Fyj5hR5PV07sPbyqDkfFUC8Vsf7UjX+pYTB+j1PvC2umR34J09w7sGtUIWCeYJH
f+0k/w1vw0C+lsO3huqhjY5DC1cBKokRr2RNqYFwU4u3iuWAxyB6wX/DR6tB0z0VdtAaaIl9cQW3
rAMcFwQQr0VTij/mxgF8qUQev+/HlaUPVgBtrB+3adEt++uA33VoRw9lLAA3ozz/aHQ/uHc9zHa7
VCW0ryMarg34XYfGVfS/Quk5vMirTLrLQxmTK4B2+NoJPCcYg+vQqOKj0/RmF/B5X+EWWuVYQCLE
cC8siUXBGFyHRhTfz8wpn0294MNQABgAhnniakXp7VqJyBtbcMM+ScTDOe8fVnw/a1H5gHZLfJU0
wNCic3EFb88S50NeQEvF6rYCXBf0sYb70uEjHKv8DFJGdgGgR3ng870m7l7tQUJ3QT5st4WvkiLU
VAe0Iyw27oL4jY098LmwiY5eXryx5LbuAkGyh4cy3q0AGhZ7Ymq3Uj1HwuHwISleb+LeonVLB0xI
GIhlNb6PZJkzqyqHL0B/omQpcWzhRlgFM814FXx4IHashIyWJU20MbCzh4KeqAJ6uScPRLmntorv
eBFSjiebqNRsH4xDqUdxfNXTYLonyfOtnnapnF0CkEFM8rYPp7nKHeohfNTiXR3D/UbbDe5eecJT
TPTkqg4NcIcH6SWqQTI+27UiHL7gqQ8fb/KBuz1ILxdHhh3tN9rOAfowsBvFM7kSmJXsiJ097iX8
kmcJvblH3i5toYK+4oUXFnsAT63ssoFK8hkvGxheTLrtwPEMsNQTpz/BmORR3fiNNxNf3NLCU772
V27EYMSjPEhn93VghCf9+YU1gHaDnTHLQ8HVQNVrPQHsLBwfwpeJ75jTAlZu8KjUHg12SqU5itD7
Bg9/Pwr4vx6n4T/Uq8u/eU7SeG2h+rQNng3ji6tVWLOhBAJshxIyJn2imPECoD8DW+Y5rdl29QBw
SAkpwO4uREgYZ5WQ0KyNw4m0qoTkLKd2KGNSsvGP8bjTu3rNzALDUu8JGsWTWCU4uyOqnbhxMEt0
z5whrm/4z21nAt3bOUNRP/e4gz15nZEFhm+XmA/6bIzN11HH8kvmTyMWlQBmQ8xub0AqAq0oJ9mh
VoBOj1f0mpXIo0EnJwZIGdlTd67f8JV0uruXfFDQEowfYYxCGdt2DeLvBxBnIN4uNUm70YGcF+0c
Idyx6/o4QcwwsKiqv1UbPM40GoG2AbuyC+r7Rn2vw9rAfgkxsdwtaFQOLXLMo7JG/xKwBDEKx1bA
nsCmwGTEsLiuoqyABTGaqF23p44EbqQ76F3gTeAtID4N1o0ENgE2w0fUYq6Zwk0Fd182oI1DgdtK
BzQpIK18Uh5416X/h+tU5n3NB7YgUB5czAG3/ZoTBKp+6NrbIqbjvPik8/ut63myu6NRQVzWuXWK
wfO4Q+a/xri4sB6EXYqOehKOH4V2a0iP4tinc+NDDtw7oI26ZwLqSgH9EkTb5JOAa9p3JrBTaLxU
9K1EbEjU6dBb7QV6NAA6SwXVn0N0W70bolQvAnwmTH+ZU95VBYAZcI/VGjqB1mr32WlgbqyLil8l
gB1oDb2OK/JcGBtTUT0C1Yz2FaDNIUpNLRY1EO6fpeK+CVJ6bUPwmGKLiRYCfxVmyFrhqwuzwJwt
oQfPU+RIxI1BpRukH+E4ucZbVIyqiOYA24YmB2AGuL1yoD7PDMg/4UrYPtVt0lm8RMS2xYJ5rYYf
Bu4NKgsZQ1mkLANNBLegUTO4HGCuSurHEe8fss0qlgKTiJpKU9CJgneFZjbe9qVXYzxE83Ipa7nv
EFNwvND8RtA+kMuVob+PfzADuKeA/YeoPu2AEytgzsd6/omzcufe3lKHdQucHQ44NN6mVgIZ4B4E
HV5VrIeGZBagr4K7ohntuPm2NSYg5pUa3eb3vNuTB3kvjQa3Np3UBRFuvg45usSX0wrEehhvlxhm
WvzWg649gk6fKGFXiO/ra3iTIoPCgokYM0qOny5KLhsWp921LpuJK78PKiGg3lfA/nHlta2IMO4s
ZctTUVvCjDdQL8SwaGfQa30krd+sxLF0g9kkzukTGf0Q6qWDMzQS7Bcl7eXrpL78ANjI7nLkiH0R
C3oS2BXJfHr3qRi5G/9YsJW9Ja1NoNWVPYnd7XD5Zbw3cM2+7u4G858QO/SBp2sA9F+9AWgT6GHQ
mO51r699dvgW2KBrz7rSGSdewzgQix2cfXHknIg3ub7UvUajvQXatjcbXByMuL/LAL0Q4/O9pSu3
5I46BOz2Ol6Esq5HQNPWdZf1msCo1P0AxO2IxXUkpY+f1YhnME7p6fZsrRPeD7oD9G5iuvelViwG
3Q92YF8tYiZWGUch/gfG/EKBbQllx7gUsQk2FI/9tKSPdTjoYNCDcQL0orIxCTSvsuHXRvnWj12J
QN8NOAA4BjgQselaNdJgHEXWO2rvWYL4I44/IKYT8RiBEqCuNpWNAaYC+4P7EPBB0Kg24HEncD/w
IOgBiF4pi0vXFe1b+f/GwDTEfjimAJtTOVdwIL5zVPzUcsSq+GyYlXFDPgLcimPuWsIpHMXcTAeM
Bg6kcgTbjlTyg4wCxoGWxnHZwyoJ2nke3L3ATHCv0EWN3r3RzRXvQ5SQwFHcD4aLFYoobE/qnGoS
Rn+gQIECBQoUKFCgQIECBQoUKFCgQIHKJzMr9P5AgdqlphdWJJ0taVmD2yLn3J3OuccSz+FcyCdW
tkCKoqj2sy+Q44gJ59xzzrn/7HT53kjSgJn9laQrJD2tFsjMJGmupGslfU3S8CC5vfdj9fcoM/t0
3Bf3q0Uys6clXSnpQ7V9KWnPBo+P7gQvMa7q4q2uiiDpb5L3qUMUV+SEAGp/YJY0TNIJ6ixZ3J/f
qSOFUzFjZge22+9mdkRGvR6o1wi/yqpUBwAtM/thgJs3UD+qYuk/a8q7MKP/r+oAP+9m1OXTtej/
bFFgrsPcGQFuhevMt8gPbZ0A3ISMPl/dJpg3b4Cp99c+8GaeqSZL+jZBLwXIFSqZxzTbJxn3N+r3
y2rKfiajmM+3MUA/lVU/qMQaVyvxMYiD7Ou2j1zF2HW3SprlnBuQdDXwbGwFj5F0WuLvzznnKg/W
d29MLN3y7W/KEhgCXOx5uqhqrDvnzq3+DZya8H6cluahcs4JOM3MvhZF0fJE2TvV86JJOgb4RUsu
OeeOSQGnc85dXPvhjzNG6P1mtn8LUuIQSXdnjOyfB9wVomps0UAYX2FmE+u51VLeN0zS+Q3eOSlx
/wcyJHpLKYklRQ1ml61qK/1wxv1jW7WyzWzP9DpYCNAvRt2Y2kB1GNHie5dlAGpq7ZSece9GLQzS
L2a8b2b1vuRcPyaFiT845xa0OEUQRdGM9K8dZjYqQLDjfueN0qZm4AfOuRUtvvvCjL7epObemzJe
9csWsPTX1NlxG6u0L9YD9I4pL1rWgXZ+OaOiEwIM1wJjI0nVUIhA/VO64u9ubLV+zrkVeeoY6+bn
Z+jvH29CMlf/3L2eTh7bZ39f/f9AjiXpP3agr/4V+FbKd8NqGNjUOXdunfvedM6dEzfYesCmkq4C
DqlT/9eAHwI/Bl6JDZe8oBon6X3OueOAU0jfbGfA5ZKudc495pxb2OC9mwL1+HrcOXd5/PfGkj4m
6RLn3GZ17v0NcJKkxc65lRnFbZkGtCiKbm+nI/OEL8Qz7wvxvbW7cV3sLNhJ0rONHAJRFCHpcGB0
Bk8P1X64T4ZB+PF2V3ckfTNjuXJaDaAnpdRjTvz9KWb2jpkpvhq5lO6QtFkjiSJpE0nPSVrdggty
iZldKWl4mgTL4Oum+PuTzWxlla8GOuirZrZjRln/kWtpuPl+nGZmP5J0ee1lZlPq3P9QBg//s4ly
F2Q0x3n1Hvh2xgNHdGAq/WYGY0fU3JvW8TdLOq6VhR8zW9TAit9D0up2l4IlPZQxdabx9WtJ/9Bs
mIGZrTKzPVPau+OAzqNq1Hnm4IzBOTenyrFeg6bYN9mvVXm/qpUKNzNTdeAdOwBXx+qDS9HN0qbA
DSVdUju9VXl2zt2SUUfl5U/SB8zsB03ytTvwrXhhIDdfzrkIuCqPXp2glo9bbiVSMo64TFPFtjGz
yTl08T2y+kXS48l+9bKiIemivAMm477JtfdImh7r5082GDQCzpA0rraTJJ0KjKP+IkDVM/CkpH8F
rsmqYzzYDm+yeSbXAcwbwGUN+HLAFEl7pw3UOvVbgH96OGNQnpNjEH05g/9HEos5+XRcSQd0CNTt
qhxVutbMtksp44j4+7SyPlbb2WY2J6WchyXtlsHP4ZLmpzw7vgmVo0qPrBNcs6asE9JUEjObnlfl
kPR8CZ6b0zL6/k85nl+RYR8d0orRNqkbAB3X770sv3VCci9Iecdva+7fIa1eeabyeitisVF3bpOA
XmxmA1nlSfrbtD7qZkCb2bgGRu7wjGePz3iurvrUdUEUDVSTS+tOMTV6XjVkss73S2rKSnN9za26
jLLqGUXRw/Xq65zbvUl+t4miaFVaebEueXGRBlxRFEXRvDTXb1zPUzMePyZDhXykJwDdwPi4OOc7
vp+ie36m5r49U14xI289nXPP1dGjj26C39mNdNtmDbKM+1eX1Ke/yLA5Lsp47s8y9Ocb6n0x4Enq
DnSoYebmvHVkThCkdfCIJpbkB9rx6Eh6vQn+nwe2b6Mfdixp1r05pT+q3qHJwKzkPZLWk7RFvefi
2fHiVgHdib1SZ+XdJNuhzbQj25yKD3PO5Y3X3qTNQfpWp92f3bYhOYqil+K2V4o36cgoii6o+fjq
jFdOTy0rR4N3wihcP28DZ8TdPtcESK5O0W3zvmIEsFnOa1iX2BdJPoeXAdwGRvQJsQu0Xn1Pq+Fz
FHBkRsjCOWll5ZHQo7tkoDcFnLIllKQdnHOzSzKqLwGOKOj9FwGr6nz+eBRFV2TMGFeaWdr3O9TU
f6usGck5Nzetf6uAHigaAGnTYKwX5pkurd3ymlA5XgZua5PlhZ4N5sF7Gtksbe4S+qSkreqUewNw
RQMDei6wbUqdz3bOnR8HNh2VwqskuSiKXmpk0PwE+D8p94ztQF/sk9EZy/N0WnJHRA4w79em1H7E
OXdCt3mAmtCNXQbYv+Ccu6q9cVUfbDnqPx04sc7zAj4KnB8XcGzK8845d2Kmvh6/4IUM6fXJDvTF
tCw+89oWTZTXboz1cHqb5qUNiNij0LL+LmlCGyPh2gxvR1Lt+FDagHTOXZGlq0eJm19LYeSoNg2F
CQ2YnNOMWpAzEGd1TqMqTS/ftRtRmneGkbQg4x1fabVsSbu2Wf+bgbS6bRP377QMPh+NvSaNAZ22
lOicc2Z2YhtMZOXfeLSZTpN0bk7d7/AUL8fVNe+bkeHlyAseS8RmKxHPPLbTgG7CBpiTMSA2kLR3
i+XenNE/M3O+7vKM2eOnzrkzqb/VCuCOZiTp9Q2CZ86XNFHSyDiQfXjSDWNmJD4fKWm0mf2uQfD9
39fTlRvlXmjUsXE+vXplXlNz37YZ9RuVo82irFiQmnvT+PptE330fJ6yYt7ea9CfX5E0WtJwMxsu
KaopayDRn1Ecj55FH8/JwwfSdkzHmHgqDS/r7OzOMh5iQ+qBDD3XJaz3pfH/X5e0NOEpqRa4Hmty
OqQ501dEUTSy1tAxs0m1no8autU59xdphpKkHwBnpnTykc65m2rKU22MdfzOpcBk59yrGWVdAXwx
xRJ3tYBO4esm59yROSXl88CkPFaapKMlXZ9hwFW/eDWeqd8B3k4Iqa2ccwPxu8bnmD3fF0XRszn5
yJJIK+vZMJIeiKKoYeTnQKJRHpS0GNiggdU8hjU7xMfl0OvqBq07556t10g53veRuEF+T+UE05fN
bA/n3G7Ah+MMl7XJbRT3+0N1yvsS8NM6dVgfeEXSk8DLsSRdVFtWncHg4neW5uWI77vBzFamGLiu
jgE9Lq39GwC5GmfdjM/9cUlTUt47PEVdurJZ4y1POtSOJW00s/Fp7rmUx+a1uk0qnspuybDcF3Yo
n59VbZFa49W3yhHzdV3RXRn/ntrkwPxgC/s2t23KFRZFEc65GZLOihX0wmIQnXNHR1H0WpOGz7uS
prQg1QQsqud+TISbHkdntok5Scc2ssSL9nIk7v8k8Ksm3aPNtK0D/t05d2/ebWCxRL8HyBuUpZiX
uU0BuipVoii6ENjFOff7zvCsKkjnS7oGmOicu7GFThsWRdFTks5mzaqhcjTeC8B+tbHQazVCFP1e
0kckPdOkNyFZ1jOS9o2iaHpRgqDZesVt/5eS/hcwo5MyKm6rS51zn2tmACdWDWeRf7/mNZ2s+KfM
7GeSlpvZCkkrc17L46nirGampAyV4/lEJ42W9HexClKv7BXx9qipeX3XCfXjaEmPxfXPw+PPJW3f
qBxJ28X3116/aXLQrPOOJp5fP26313Lyl7yWxc9cUOW3TVxNi/t1eYNLefsQmo/d3SQ2lhrRKufc
/DrSP4+emOYNeME5t31NfYbFRk0tt0ucc+80U24Kv1uSHsC1Do9lUas81ovJSJsdk+m2AjXXyJO6
ZT9coN6jkJg5UAB0oEAB0IECBUAHChQAHSgAOlCgAOhAgQKgAwUqkv4bfPLXUw4/P/sAAAAASUVO
RK5CYII=

------=_NextPart_000_0000_01CD8C89.6E361A20
Content-Type: text/css;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://docs.opencv.org/basic.css

div.clearer {
	clear: both;
}
div.related {
	width: 100%; font-size: 90%;
}
div.related h3 {
	display: none;
}
div.related ul {
	list-style: none; margin: 0px; padding: 0px 0px 0px 10px;
}
div.related li {
	display: inline;
}
div.related li.right {
	margin-right: 5px; float: right;
}
div.sphinxsidebarwrapper {
	padding: 10px 5px 0px 10px;
}
div.sphinxsidebar {
	width: 230px; font-size: 90%; margin-left: -100%; float: left;
}
div.sphinxsidebar ul {
	list-style: none;
}
div.sphinxsidebar ul ul {
	list-style: square; margin-left: 20px;
}
div.sphinxsidebar ul.want-points {
	list-style: square; margin-left: 20px;
}
div.sphinxsidebar ul ul {
	margin-top: 0px; margin-bottom: 0px;
}
div.sphinxsidebar form {
	margin-top: 10px;
}
div.sphinxsidebar input {
	border: 1px solid rgb(152, 219, 204); font-family: sans-serif; =
font-size: 1em;
}
img {
	border: 0px currentColor;
}
ul.search {
	margin: 10px 0px 0px 20px; padding: 0px;
}
ul.search li {
	background-position: 0px 7px; padding: 5px 0px 5px 20px; =
background-image: url("file.png"); background-repeat: no-repeat;
}
ul.search li a {
	font-weight: bold;
}
ul.search li div.context {
	margin: 2px 0px 0px 30px; text-align: left; color: rgb(136, 136, 136);
}
ul.keywordmatches li.goodmatch a {
	font-weight: bold;
}
table.contentstable {
	width: 90%;
}
table.contentstable p.biglink {
	line-height: 150%;
}
a.biglink {
	font-size: 1.3em;
}
span.linkdescr {
	padding-top: 5px; font-size: 90%; font-style: italic;
}
table.indextable {
	width: 100%;
}
table.indextable td {
	text-align: left; vertical-align: top;
}
table.indextable dl {
	margin-top: 0px; margin-bottom: 0px;
}
table.indextable dd {
	margin-top: 0px; margin-bottom: 0px;
}
table.indextable tr.pcap {
	height: 10px;
}
table.indextable tr.cap {
	margin-top: 10px; background-color: rgb(242, 242, 242);
}
img.toggler {
	margin-top: 3px; margin-right: 3px; cursor: pointer;
}
div.modindex-jumpbox {
	margin: 1em 0px; padding: 0.4em; border-top-color: rgb(221, 221, 221); =
border-bottom-color: rgb(221, 221, 221); border-top-width: 1px; =
border-bottom-width: 1px; border-top-style: solid; border-bottom-style: =
solid;
}
div.genindex-jumpbox {
	margin: 1em 0px; padding: 0.4em; border-top-color: rgb(221, 221, 221); =
border-bottom-color: rgb(221, 221, 221); border-top-width: 1px; =
border-bottom-width: 1px; border-top-style: solid; border-bottom-style: =
solid;
}
a.headerlink {
	visibility: hidden;
}
h1:hover > a.headerlink {
	visibility: visible;
}
h2:hover > a.headerlink {
	visibility: visible;
}
h3:hover > a.headerlink {
	visibility: visible;
}
h4:hover > a.headerlink {
	visibility: visible;
}
h5:hover > a.headerlink {
	visibility: visible;
}
h6:hover > a.headerlink {
	visibility: visible;
}
dt:hover > a.headerlink {
	visibility: visible;
}
div.body p.caption {
	text-align: inherit;
}
div.body td {
	text-align: left;
}
.field-list ul {
	padding-left: 1em;
}
.first {
	margin-top: 0px !important;
}
p.rubric {
	font-weight: bold; margin-top: 30px;
}
img.align-left {
	clear: left; margin-right: 1em; float: left;
}
.align-left.figure {
	clear: left; margin-right: 1em; float: left;
}
object.align-left {
	clear: left; margin-right: 1em; float: left;
}
img.align-right {
	clear: right; margin-left: 1em; float: right;
}
.align-right.figure {
	clear: right; margin-left: 1em; float: right;
}
object.align-right {
	clear: right; margin-left: 1em; float: right;
}
img.align-center {
	margin-right: auto; margin-left: auto; display: block;
}
.align-center.figure {
	margin-right: auto; margin-left: auto; display: block;
}
object.align-center {
	margin-right: auto; margin-left: auto; display: block;
}
.align-left {
	text-align: left;
}
.align-center {
	text-align: center; clear: both;
}
.align-right {
	text-align: right;
}
div.sidebar {
	margin: 0px 0px 0.5em 1em; padding: 7px 7px 0px; border: 1px solid =
rgb(221, 221, 187); width: 40%; float: right; background-color: rgb(255, =
255, 238);
}
p.sidebar-title {
	font-weight: bold;
}
div.topic {
	margin: 10px 0px; padding: 7px 7px 0px; border: 1px solid rgb(204, 204, =
204);
}
p.topic-title {
	font-size: 1.1em; font-weight: bold; margin-top: 10px;
}
div.admonition {
	padding: 7px; margin-top: 10px; margin-bottom: 10px;
}
div.admonition dt {
	font-weight: bold;
}
div.admonition dl {
	margin-bottom: 0px;
}
p.admonition-title {
	margin: 0px 10px 5px 0px; font-weight: bold;
}
div.body p.centered {
	text-align: center; margin-top: 25px;
}
table.docutils {
	border: 0px currentColor; border-collapse: collapse;
}
table.docutils td {
	border-width: 0px 0px 1px; border-style: none none solid; border-color: =
currentColor currentColor rgb(170, 170, 170); padding: 1px 8px 1px 5px;
}
table.docutils th {
	border-width: 0px 0px 1px; border-style: none none solid; border-color: =
currentColor currentColor rgb(170, 170, 170); padding: 1px 8px 1px 5px;
}
table.field-list td {
	border: 0px currentColor !important;
}
table.field-list th {
	border: 0px currentColor !important;
}
table.footnote td {
	border: 0px currentColor !important;
}
table.footnote th {
	border: 0px currentColor !important;
}
th {
	text-align: left; padding-right: 5px;
}
table.citation {
	margin-left: 1px; border-left-color: gray; border-left-width: 1px; =
border-left-style: solid;
}
table.citation td {
	border-bottom-color: currentColor; border-bottom-width: medium; =
border-bottom-style: none;
}
ol.arabic {
	list-style: decimal;
}
ol.loweralpha {
	list-style: lower-alpha;
}
ol.upperalpha {
	list-style: upper-alpha;
}
ol.lowerroman {
	list-style: lower-roman;
}
ol.upperroman {
	list-style: upper-roman;
}
dl {
	margin-bottom: 15px;
}
dd p {
	margin-top: 0px;
}
dd ul {
	margin-bottom: 10px;
}
dd table {
	margin-bottom: 10px;
}
dd {
	margin-top: 3px; margin-bottom: 10px; margin-left: 30px;
}
dt:target {
	background-color: rgb(251, 229, 78);
}
.highlighted {
	background-color: rgb(251, 229, 78);
}
dl.glossary dt {
	font-size: 1.1em; font-weight: bold;
}
.field-list ul {
	margin: 0px; padding-left: 1em;
}
.field-list p {
	margin: 0px;
}
.refcount {
	color: rgb(0, 102, 0);
}
.optional {
	font-size: 1.3em;
}
.versionmodified {
	font-style: italic;
}
.system-message {
	padding: 5px; border: 3px solid red; background-color: rgb(255, 221, =
170);
}
:target.footnote {
	background-color: rgb(255, 255, 170);
}
.line-block {
	margin-top: 1em; margin-bottom: 1em; display: block;
}
.line-block .line-block {
	margin-top: 0px; margin-bottom: 0px; margin-left: 1.5em;
}
.guilabel {
	font-family: sans-serif;
}
.menuselection {
	font-family: sans-serif;
}
.accelerator {
	text-decoration: underline;
}
.classifier {
	font-style: oblique;
}
pre {
	overflow: auto; overflow-y: hidden;
}
td.linenos pre {
	padding: 5px 0px; border: 0px currentColor; color: rgb(170, 170, 170); =
background-color: transparent;
}
table.highlighttable {
	margin-left: 0.5em;
}
table.highlighttable td {
	padding: 0px 0.5em;
}
tt.descname {
	font-size: 1.2em; font-weight: bold; background-color: transparent;
}
tt.descclassname {
	background-color: transparent;
}
tt.xref {
	font-weight: bold; background-color: transparent;
}
a tt {
	font-weight: bold; background-color: transparent;
}
h1 tt {
	background-color: transparent;
}
h2 tt {
	background-color: transparent;
}
h3 tt {
	background-color: transparent;
}
h4 tt {
	background-color: transparent;
}
h5 tt {
	background-color: transparent;
}
h6 tt {
	background-color: transparent;
}
.viewcode-link {
	float: right;
}
.viewcode-back {
	font-family: sans-serif; float: right;
}
div:target.viewcode-block {
	margin: -1px -10px; padding: 0px 10px;
}
img.math {
	vertical-align: middle;
}
div.body div.math p {
	text-align: center;
}
span.eqno {
	float: right;
}
div.document {
	margin: 0px !important; width: 100%;
}
div.documentwrapper {
	margin: 0px !important; width: 100%;
}
div.bodywrapper {
	margin: 0px !important; width: 100%;
}
div.sphinxsidebar {
	display: none;
}
div.related {
	display: none;
}
div.footer {
	display: none;
}
#top-link {
	display: none;
}

------=_NextPart_000_0000_01CD8C89.6E361A20
Content-Type: text/css;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://docs.opencv.org/_static/default.css

@import url( basic.css );
body {
	margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: =
sans-serif; font-size: 100%; background-color: rgb(0, 64, 104);
}
img.logo {
	width: 150px;
}
div.document {
	background-color: rgb(0, 96, 144);
}
div.documentwrapper {
	width: 100%; float: left;
}
div.bodywrapper {
	margin: 0px 0px 0px 270px;
}
div.body {
	padding: 0px 20px 30px; color: rgb(0, 0, 0); background-color: rgb(255, =
255, 255);
}
div.feedback {
	padding: 20px 20px 30px; color: rgb(255, 255, 255); background-color: =
rgb(0, 64, 104);
}
div.feedback h2 {
	margin: 10px 0px;
}
div.feedback a {
	color: rgb(255, 255, 255); font-weight: bold;
}
div.footer {
	padding: 9px 0px; width: 100%; text-align: center; color: rgb(255, 255, =
255); font-size: 75%;
}
div.footer a {
	color: rgb(255, 255, 255); text-decoration: underline;
}
div.related {
	color: rgb(255, 255, 255); line-height: 30px; background-color: rgb(0, =
48, 72);
}
div.related a {
	color: rgb(255, 255, 255);
}
div.sphinxsidebar {
	width: 270px; word-wrap: break-word;
}
div.sphinxsidebar h3 {
	margin: 0px; padding: 0px; color: rgb(255, 255, 255); font-family: =
"Trebuchet MS", sans-serif; font-size: 1.4em; font-weight: normal;
}
div.sphinxsidebar h3 a {
	color: rgb(255, 255, 255);
}
div.sphinxsidebar h4 {
	margin: 5px 0px 0px; padding: 0px; color: rgb(255, 255, 255); =
font-family: "Trebuchet MS", sans-serif; font-size: 1.3em; font-weight: =
normal;
}
div.sphinxsidebar p {
	color: rgb(255, 255, 255);
}
div.sphinxsidebar p.topless {
	margin: 5px 10px 10px;
}
div.sphinxsidebar ul {
	margin: 10px 0px 10px 10px; padding: 0px; color: rgb(255, 255, 255);
}
div.sphinxsidebar a {
	color: rgb(204, 238, 255);
}
div.sphinxsidebar input {
	border: 1px solid rgb(204, 238, 255); font-family: sans-serif; =
font-size: 1em;
}
a {
	color: rgb(0, 144, 217); text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
div.body p {
	text-align: justify; line-height: 130%;
}
div.body dd {
	text-align: justify; line-height: 130%;
}
div.body li {
	text-align: justify; line-height: 130%;
}
div.body h1 {
	margin: 20px -20px 10px; padding: 3px 0px 3px 10px; color: rgb(0, 48, =
72); font-family: "Trebuchet MS", sans-serif; font-weight: normal; =
border-bottom-color: rgb(204, 204, 204); border-bottom-width: 1px; =
border-bottom-style: solid; background-color: rgb(242, 242, 242);
}
div.body h2 {
	margin: 20px -20px 10px; padding: 3px 0px 3px 10px; color: rgb(0, 48, =
72); font-family: "Trebuchet MS", sans-serif; font-weight: normal; =
border-bottom-color: rgb(204, 204, 204); border-bottom-width: 1px; =
border-bottom-style: solid; background-color: rgb(242, 242, 242);
}
div.body h3 {
	margin: 20px -20px 10px; padding: 3px 0px 3px 10px; color: rgb(0, 48, =
72); font-family: "Trebuchet MS", sans-serif; font-weight: normal; =
border-bottom-color: rgb(204, 204, 204); border-bottom-width: 1px; =
border-bottom-style: solid; background-color: rgb(242, 242, 242);
}
div.body h4 {
	margin: 20px -20px 10px; padding: 3px 0px 3px 10px; color: rgb(0, 48, =
72); font-family: "Trebuchet MS", sans-serif; font-weight: normal; =
border-bottom-color: rgb(204, 204, 204); border-bottom-width: 1px; =
border-bottom-style: solid; background-color: rgb(242, 242, 242);
}
div.body h5 {
	margin: 20px -20px 10px; padding: 3px 0px 3px 10px; color: rgb(0, 48, =
72); font-family: "Trebuchet MS", sans-serif; font-weight: normal; =
border-bottom-color: rgb(204, 204, 204); border-bottom-width: 1px; =
border-bottom-style: solid; background-color: rgb(242, 242, 242);
}
div.body h6 {
	margin: 20px -20px 10px; padding: 3px 0px 3px 10px; color: rgb(0, 48, =
72); font-family: "Trebuchet MS", sans-serif; font-weight: normal; =
border-bottom-color: rgb(204, 204, 204); border-bottom-width: 1px; =
border-bottom-style: solid; background-color: rgb(242, 242, 242);
}
a.toc-backref {
	color: rgb(0, 48, 72); font-family: "Trebuchet MS", sans-serif; =
font-weight: normal; text-decoration: none; background-color: rgb(242, =
242, 242);
}
a.toc-backref:hover {
	color: rgb(0, 48, 72); font-family: "Trebuchet MS", sans-serif; =
font-weight: normal; text-decoration: none; background-color: rgb(242, =
242, 242);
}
div.body h1 {
	font-size: 200%; margin-top: 0px;
}
div.body h2 {
	font-size: 160%;
}
div.body h3 {
	font-size: 140%;
}
div.body h4 {
	font-size: 120%;
}
div.body h5 {
	font-size: 110%;
}
div.body h6 {
	font-size: 100%;
}
a.headerlink {
	padding: 0px 4px; color: rgb(101, 161, 54); font-size: 0.8em; =
text-decoration: none;
}
a.headerlink:hover {
	color: white; background-color: rgb(101, 161, 54);
}
div.body p {
	text-align: justify; line-height: 130%;
}
div.body dd {
	text-align: justify; line-height: 130%;
}
div.body li {
	text-align: justify; line-height: 130%;
}
div.admonition p.admonition-title + p {
	display: inline;
}
div.note {
	border: 1px solid rgb(204, 204, 204); background-color: rgb(238, 238, =
238);
}
div.seealso {
	border: 1px solid rgb(255, 255, 102); background-color: rgb(255, 255, =
204);
}
div.topic {
	background-color: rgb(238, 238, 238);
}
div.warning {
	border: 1px solid rgb(255, 102, 102); background-color: rgb(255, 228, =
228);
}
p.admonition-title {
	display: inline;
}
p.admonition-title::after {
	content: ":";
}
pre {
	border-width: 1px medium; border-style: solid none; border-color: =
rgb(170, 204, 238) currentColor; padding: 5px; color: rgb(51, 51, 51); =
line-height: 120%; background-color: rgb(224, 245, 255);
}
tt {
	padding: 0px 1px; color: rgb(0, 48, 72); font-size: 1.2em;
}
tt.descname {
	padding: 0px 1px; color: rgb(0, 48, 72); font-size: 1.4em;
}
div.math p {
	margin-top: 10px; margin-bottom: 10px;
}
dl.function > dt:first-child {
	margin-bottom: 7px;
}
dl.cfunction > dt:first-child {
	color: rgb(128, 128, 176); margin-bottom: 7px;
}
dl.cfunction > dt:first-child tt.descname {
	color: rgb(128, 128, 176);
}
dl.pyfunction > dt:first-child {
	margin-bottom: 7px;
}
dl.pyoldfunction > dt:first-child {
	color: rgb(128, 128, 176); margin-bottom: 7px;
}
dl.pyoldfunction > dt:first-child tt.descname {
	color: rgb(128, 128, 176);
}
dl.pyoldfunction > dt:first-child tt.descclassname {
	color: rgb(128, 128, 176);
}
dl.jfunction > dt:first-child {
	margin-bottom: 7px;
}
table.field-list {
	margin-top: 20px;
}
ul.simple {
	list-style: none;
}
em.menuselection {
	font-family: "Lucida Sans","Lucida Sans Unicode","Lucida =
Grande",Verdana,Arial,Helvetica,sans-serif;
}
em.guilabel {
	font-family: "Lucida Sans","Lucida Sans Unicode","Lucida =
Grande",Verdana,Arial,Helvetica,sans-serif;
}
.enumeratevisibleitemswithsquare ul {
	list-style: square; margin: 0px;
}
.enumeratevisibleitemswithsquare li {
	margin: 0.2em 0px;
}
.enumeratevisibleitemswithsquare p {
	margin-top: 1pt; margin-bottom: 0pt;
}
.enumeratevisibleitemswithsquare dl {
	margin: 0px;
}
.toctableopencv {
	width: 100%; table-layout: fixed;
}
.toctableopencv colgroup col:first-child {
	width: 100pt !important; min-width: 100pt !important; max-width: 100pt =
!important;
}
.toctableopencv colgroup col:nth-child(2) {
	width: 100% !important;
}
div.body ul.search li {
	text-align: left;
}

------=_NextPart_000_0000_01CD8C89.6E361A20
Content-Type: text/css;
	charset="iso-8859-1"
Content-Transfer-Encoding: 7bit
Content-Location: http://docs.opencv.org/_static/pygments.css

.highlight .hll {
	background-color: rgb(255, 255, 204);
}
.highlight {
	background: rgb(238, 255, 204);
}
.highlight .c {
	color: rgb(64, 128, 144); font-style: italic;
}
.highlight .err {
	border: 1px solid rgb(255, 0, 0);
}
.highlight .k {
	color: rgb(0, 112, 32); font-weight: bold;
}
.highlight .o {
	color: rgb(102, 102, 102);
}
.highlight .cm {
	color: rgb(64, 128, 144); font-style: italic;
}
.highlight .cp {
	color: rgb(0, 112, 32);
}
.highlight .c1 {
	color: rgb(64, 128, 144); font-style: italic;
}
.highlight .cs {
	color: rgb(64, 128, 144); background-color: rgb(255, 240, 240);
}
.highlight .gd {
	color: rgb(160, 0, 0);
}
.highlight .ge {
	font-style: italic;
}
.highlight .gr {
	color: rgb(255, 0, 0);
}
.highlight .gh {
	color: rgb(0, 0, 128); font-weight: bold;
}
.highlight .gi {
	color: rgb(0, 160, 0);
}
.highlight .go {
	color: rgb(48, 48, 48);
}
.highlight .gp {
	color: rgb(198, 93, 9); font-weight: bold;
}
.highlight .gs {
	font-weight: bold;
}
.highlight .gu {
	color: rgb(128, 0, 128); font-weight: bold;
}
.highlight .gt {
	color: rgb(0, 64, 208);
}
.highlight .kc {
	color: rgb(0, 112, 32); font-weight: bold;
}
.highlight .kd {
	color: rgb(0, 112, 32); font-weight: bold;
}
.highlight .kn {
	color: rgb(0, 112, 32); font-weight: bold;
}
.highlight .kp {
	color: rgb(0, 112, 32);
}
.highlight .kr {
	color: rgb(0, 112, 32); font-weight: bold;
}
.highlight .kt {
	color: rgb(144, 32, 0);
}
.highlight .m {
	color: rgb(32, 128, 80);
}
.highlight .s {
	color: rgb(64, 112, 160);
}
.highlight .na {
	color: rgb(64, 112, 160);
}
.highlight .nb {
	color: rgb(0, 112, 32);
}
.highlight .nc {
	color: rgb(14, 132, 181); font-weight: bold;
}
.highlight .no {
	color: rgb(96, 173, 213);
}
.highlight .nd {
	color: rgb(85, 85, 85); font-weight: bold;
}
.highlight .ni {
	color: rgb(213, 85, 55); font-weight: bold;
}
.highlight .ne {
	color: rgb(0, 112, 32);
}
.highlight .nf {
	color: rgb(6, 40, 126);
}
.highlight .nl {
	color: rgb(0, 32, 112); font-weight: bold;
}
.highlight .nn {
	color: rgb(14, 132, 181); font-weight: bold;
}
.highlight .nt {
	color: rgb(6, 40, 115); font-weight: bold;
}
.highlight .nv {
	color: rgb(187, 96, 213);
}
.highlight .ow {
	color: rgb(0, 112, 32); font-weight: bold;
}
.highlight .w {
	color: rgb(187, 187, 187);
}
.highlight .mf {
	color: rgb(32, 128, 80);
}
.highlight .mh {
	color: rgb(32, 128, 80);
}
.highlight .mi {
	color: rgb(32, 128, 80);
}
.highlight .mo {
	color: rgb(32, 128, 80);
}
.highlight .sb {
	color: rgb(64, 112, 160);
}
.highlight .sc {
	color: rgb(64, 112, 160);
}
.highlight .sd {
	color: rgb(64, 112, 160); font-style: italic;
}
.highlight .s2 {
	color: rgb(64, 112, 160);
}
.highlight .se {
	color: rgb(64, 112, 160); font-weight: bold;
}
.highlight .sh {
	color: rgb(64, 112, 160);
}
.highlight .si {
	color: rgb(112, 160, 208); font-style: italic;
}
.highlight .sx {
	color: rgb(198, 93, 9);
}
.highlight .sr {
	color: rgb(35, 83, 136);
}
.highlight .s1 {
	color: rgb(64, 112, 160);
}
.highlight .ss {
	color: rgb(81, 121, 24);
}
.highlight .bp {
	color: rgb(0, 112, 32);
}
.highlight .vc {
	color: rgb(187, 96, 213);
}
.highlight .vg {
	color: rgb(187, 96, 213);
}
.highlight .vi {
	color: rgb(187, 96, 213);
}
.highlight .il {
	color: rgb(32, 128, 80);
}

------=_NextPart_000_0000_01CD8C89.6E361A20
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://docs.opencv.org/_static/jquery.js

/*!=0A=
 * jQuery JavaScript Library v1.6.2=0A=
 * http://jquery.com/=0A=
 *=0A=
 * Copyright 2011, John Resig=0A=
 * Dual licensed under the MIT or GPL Version 2 licenses.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * Includes Sizzle.js=0A=
 * http://sizzlejs.com/=0A=
 * Copyright 2011, The Dojo Foundation=0A=
 * Released under the MIT, BSD, and GPL Licenses.=0A=
 *=0A=
 * Date: Thu Jun 30 14:16:56 2011 -0400=0A=
 */=0A=
(function( window, undefined ) {=0A=
=0A=
// Use the correct document accordingly with window argument (sandbox)=0A=
var document =3D window.document,=0A=
	navigator =3D window.navigator,=0A=
	location =3D window.location;=0A=
var jQuery =3D (function() {=0A=
=0A=
// Define a local copy of jQuery=0A=
var jQuery =3D function( selector, context ) {=0A=
		// The jQuery object is actually just the init constructor 'enhanced'=0A=
		return new jQuery.fn.init( selector, context, rootjQuery );=0A=
	},=0A=
=0A=
	// Map over jQuery in case of overwrite=0A=
	_jQuery =3D window.jQuery,=0A=
=0A=
	// Map over the $ in case of overwrite=0A=
	_$ =3D window.$,=0A=
=0A=
	// A central reference to the root jQuery(document)=0A=
	rootjQuery,=0A=
=0A=
	// A simple way to check for HTML strings or ID strings=0A=
	// (both of which we optimize for)=0A=
	quickExpr =3D /^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,=0A=
=0A=
	// Check if a string has a non-whitespace character in it=0A=
	rnotwhite =3D /\S/,=0A=
=0A=
	// Used for trimming whitespace=0A=
	trimLeft =3D /^\s+/,=0A=
	trimRight =3D /\s+$/,=0A=
=0A=
	// Check for digits=0A=
	rdigit =3D /\d/,=0A=
=0A=
	// Match a standalone tag=0A=
	rsingleTag =3D /^<(\w+)\s*\/?>(?:<\/\1>)?$/,=0A=
=0A=
	// JSON RegExp=0A=
	rvalidchars =3D /^[\],:{}\s]*$/,=0A=
	rvalidescape =3D /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,=0A=
	rvalidtokens =3D =
/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,=0A=
	rvalidbraces =3D /(?:^|:|,)(?:\s*\[)+/g,=0A=
=0A=
	// Useragent RegExp=0A=
	rwebkit =3D /(webkit)[ \/]([\w.]+)/,=0A=
	ropera =3D /(opera)(?:.*version)?[ \/]([\w.]+)/,=0A=
	rmsie =3D /(msie) ([\w.]+)/,=0A=
	rmozilla =3D /(mozilla)(?:.*? rv:([\w.]+))?/,=0A=
=0A=
	// Matches dashed string for camelizing=0A=
	rdashAlpha =3D /-([a-z])/ig,=0A=
=0A=
	// Used by jQuery.camelCase as callback to replace()=0A=
	fcamelCase =3D function( all, letter ) {=0A=
		return letter.toUpperCase();=0A=
	},=0A=
=0A=
	// Keep a UserAgent string for use with jQuery.browser=0A=
	userAgent =3D navigator.userAgent,=0A=
=0A=
	// For matching the engine and version of the browser=0A=
	browserMatch,=0A=
=0A=
	// The deferred used on DOM ready=0A=
	readyList,=0A=
=0A=
	// The ready event handler=0A=
	DOMContentLoaded,=0A=
=0A=
	// Save a reference to some core methods=0A=
	toString =3D Object.prototype.toString,=0A=
	hasOwn =3D Object.prototype.hasOwnProperty,=0A=
	push =3D Array.prototype.push,=0A=
	slice =3D Array.prototype.slice,=0A=
	trim =3D String.prototype.trim,=0A=
	indexOf =3D Array.prototype.indexOf,=0A=
=0A=
	// [[Class]] -> type pairs=0A=
	class2type =3D {};=0A=
=0A=
jQuery.fn =3D jQuery.prototype =3D {=0A=
	constructor: jQuery,=0A=
	init: function( selector, context, rootjQuery ) {=0A=
		var match, elem, ret, doc;=0A=
=0A=
		// Handle $(""), $(null), or $(undefined)=0A=
		if ( !selector ) {=0A=
			return this;=0A=
		}=0A=
=0A=
		// Handle $(DOMElement)=0A=
		if ( selector.nodeType ) {=0A=
			this.context =3D this[0] =3D selector;=0A=
			this.length =3D 1;=0A=
			return this;=0A=
		}=0A=
=0A=
		// The body element only exists once, optimize finding it=0A=
		if ( selector =3D=3D=3D "body" && !context && document.body ) {=0A=
			this.context =3D document;=0A=
			this[0] =3D document.body;=0A=
			this.selector =3D selector;=0A=
			this.length =3D 1;=0A=
			return this;=0A=
		}=0A=
=0A=
		// Handle HTML strings=0A=
		if ( typeof selector =3D=3D=3D "string" ) {=0A=
			// Are we dealing with HTML string or an ID?=0A=
			if ( selector.charAt(0) =3D=3D=3D "<" && selector.charAt( =
selector.length - 1 ) =3D=3D=3D ">" && selector.length >=3D 3 ) {=0A=
				// Assume that strings that start and end with <> are HTML and skip =
the regex check=0A=
				match =3D [ null, selector, null ];=0A=
=0A=
			} else {=0A=
				match =3D quickExpr.exec( selector );=0A=
			}=0A=
=0A=
			// Verify a match, and that no context was specified for #id=0A=
			if ( match && (match[1] || !context) ) {=0A=
=0A=
				// HANDLE: $(html) -> $(array)=0A=
				if ( match[1] ) {=0A=
					context =3D context instanceof jQuery ? context[0] : context;=0A=
					doc =3D (context ? context.ownerDocument || context : document);=0A=
=0A=
					// If a single string is passed in and it's a single tag=0A=
					// just do a createElement and skip the rest=0A=
					ret =3D rsingleTag.exec( selector );=0A=
=0A=
					if ( ret ) {=0A=
						if ( jQuery.isPlainObject( context ) ) {=0A=
							selector =3D [ document.createElement( ret[1] ) ];=0A=
							jQuery.fn.attr.call( selector, context, true );=0A=
=0A=
						} else {=0A=
							selector =3D [ doc.createElement( ret[1] ) ];=0A=
						}=0A=
=0A=
					} else {=0A=
						ret =3D jQuery.buildFragment( [ match[1] ], [ doc ] );=0A=
						selector =3D (ret.cacheable ? jQuery.clone(ret.fragment) : =
ret.fragment).childNodes;=0A=
					}=0A=
=0A=
					return jQuery.merge( this, selector );=0A=
=0A=
				// HANDLE: $("#id")=0A=
				} else {=0A=
					elem =3D document.getElementById( match[2] );=0A=
=0A=
					// Check parentNode to catch when Blackberry 4.6 returns=0A=
					// nodes that are no longer in the document #6963=0A=
					if ( elem && elem.parentNode ) {=0A=
						// Handle the case where IE and Opera return items=0A=
						// by name instead of ID=0A=
						if ( elem.id !=3D=3D match[2] ) {=0A=
							return rootjQuery.find( selector );=0A=
						}=0A=
=0A=
						// Otherwise, we inject the element directly into the jQuery object=0A=
						this.length =3D 1;=0A=
						this[0] =3D elem;=0A=
					}=0A=
=0A=
					this.context =3D document;=0A=
					this.selector =3D selector;=0A=
					return this;=0A=
				}=0A=
=0A=
			// HANDLE: $(expr, $(...))=0A=
			} else if ( !context || context.jquery ) {=0A=
				return (context || rootjQuery).find( selector );=0A=
=0A=
			// HANDLE: $(expr, context)=0A=
			// (which is just equivalent to: $(context).find(expr)=0A=
			} else {=0A=
				return this.constructor( context ).find( selector );=0A=
			}=0A=
=0A=
		// HANDLE: $(function)=0A=
		// Shortcut for document ready=0A=
		} else if ( jQuery.isFunction( selector ) ) {=0A=
			return rootjQuery.ready( selector );=0A=
		}=0A=
=0A=
		if (selector.selector !=3D=3D undefined) {=0A=
			this.selector =3D selector.selector;=0A=
			this.context =3D selector.context;=0A=
		}=0A=
=0A=
		return jQuery.makeArray( selector, this );=0A=
	},=0A=
=0A=
	// Start with an empty selector=0A=
	selector: "",=0A=
=0A=
	// The current version of jQuery being used=0A=
	jquery: "1.6.2",=0A=
=0A=
	// The default length of a jQuery object is 0=0A=
	length: 0,=0A=
=0A=
	// The number of elements contained in the matched element set=0A=
	size: function() {=0A=
		return this.length;=0A=
	},=0A=
=0A=
	toArray: function() {=0A=
		return slice.call( this, 0 );=0A=
	},=0A=
=0A=
	// Get the Nth element in the matched element set OR=0A=
	// Get the whole matched element set as a clean array=0A=
	get: function( num ) {=0A=
		return num =3D=3D null ?=0A=
=0A=
			// Return a 'clean' array=0A=
			this.toArray() :=0A=
=0A=
			// Return just the object=0A=
			( num < 0 ? this[ this.length + num ] : this[ num ] );=0A=
	},=0A=
=0A=
	// Take an array of elements and push it onto the stack=0A=
	// (returning the new matched element set)=0A=
	pushStack: function( elems, name, selector ) {=0A=
		// Build a new jQuery matched element set=0A=
		var ret =3D this.constructor();=0A=
=0A=
		if ( jQuery.isArray( elems ) ) {=0A=
			push.apply( ret, elems );=0A=
=0A=
		} else {=0A=
			jQuery.merge( ret, elems );=0A=
		}=0A=
=0A=
		// Add the old object onto the stack (as a reference)=0A=
		ret.prevObject =3D this;=0A=
=0A=
		ret.context =3D this.context;=0A=
=0A=
		if ( name =3D=3D=3D "find" ) {=0A=
			ret.selector =3D this.selector + (this.selector ? " " : "") + =
selector;=0A=
		} else if ( name ) {=0A=
			ret.selector =3D this.selector + "." + name + "(" + selector + ")";=0A=
		}=0A=
=0A=
		// Return the newly-formed element set=0A=
		return ret;=0A=
	},=0A=
=0A=
	// Execute a callback for every element in the matched set.=0A=
	// (You can seed the arguments with an array of args, but this is=0A=
	// only used internally.)=0A=
	each: function( callback, args ) {=0A=
		return jQuery.each( this, callback, args );=0A=
	},=0A=
=0A=
	ready: function( fn ) {=0A=
		// Attach the listeners=0A=
		jQuery.bindReady();=0A=
=0A=
		// Add the callback=0A=
		readyList.done( fn );=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	eq: function( i ) {=0A=
		return i =3D=3D=3D -1 ?=0A=
			this.slice( i ) :=0A=
			this.slice( i, +i + 1 );=0A=
	},=0A=
=0A=
	first: function() {=0A=
		return this.eq( 0 );=0A=
	},=0A=
=0A=
	last: function() {=0A=
		return this.eq( -1 );=0A=
	},=0A=
=0A=
	slice: function() {=0A=
		return this.pushStack( slice.apply( this, arguments ),=0A=
			"slice", slice.call(arguments).join(",") );=0A=
	},=0A=
=0A=
	map: function( callback ) {=0A=
		return this.pushStack( jQuery.map(this, function( elem, i ) {=0A=
			return callback.call( elem, i, elem );=0A=
		}));=0A=
	},=0A=
=0A=
	end: function() {=0A=
		return this.prevObject || this.constructor(null);=0A=
	},=0A=
=0A=
	// For internal use only.=0A=
	// Behaves like an Array's method, not like a jQuery method.=0A=
	push: push,=0A=
	sort: [].sort,=0A=
	splice: [].splice=0A=
};=0A=
=0A=
// Give the init function the jQuery prototype for later instantiation=0A=
jQuery.fn.init.prototype =3D jQuery.fn;=0A=
=0A=
jQuery.extend =3D jQuery.fn.extend =3D function() {=0A=
	var options, name, src, copy, copyIsArray, clone,=0A=
		target =3D arguments[0] || {},=0A=
		i =3D 1,=0A=
		length =3D arguments.length,=0A=
		deep =3D false;=0A=
=0A=
	// Handle a deep copy situation=0A=
	if ( typeof target =3D=3D=3D "boolean" ) {=0A=
		deep =3D target;=0A=
		target =3D arguments[1] || {};=0A=
		// skip the boolean and the target=0A=
		i =3D 2;=0A=
	}=0A=
=0A=
	// Handle case when target is a string or something (possible in deep =
copy)=0A=
	if ( typeof target !=3D=3D "object" && !jQuery.isFunction(target) ) {=0A=
		target =3D {};=0A=
	}=0A=
=0A=
	// extend jQuery itself if only one argument is passed=0A=
	if ( length =3D=3D=3D i ) {=0A=
		target =3D this;=0A=
		--i;=0A=
	}=0A=
=0A=
	for ( ; i < length; i++ ) {=0A=
		// Only deal with non-null/undefined values=0A=
		if ( (options =3D arguments[ i ]) !=3D null ) {=0A=
			// Extend the base object=0A=
			for ( name in options ) {=0A=
				src =3D target[ name ];=0A=
				copy =3D options[ name ];=0A=
=0A=
				// Prevent never-ending loop=0A=
				if ( target =3D=3D=3D copy ) {=0A=
					continue;=0A=
				}=0A=
=0A=
				// Recurse if we're merging plain objects or arrays=0A=
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray =
=3D jQuery.isArray(copy)) ) ) {=0A=
					if ( copyIsArray ) {=0A=
						copyIsArray =3D false;=0A=
						clone =3D src && jQuery.isArray(src) ? src : [];=0A=
=0A=
					} else {=0A=
						clone =3D src && jQuery.isPlainObject(src) ? src : {};=0A=
					}=0A=
=0A=
					// Never move original objects, clone them=0A=
					target[ name ] =3D jQuery.extend( deep, clone, copy );=0A=
=0A=
				// Don't bring in undefined values=0A=
				} else if ( copy !=3D=3D undefined ) {=0A=
					target[ name ] =3D copy;=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	// Return the modified object=0A=
	return target;=0A=
};=0A=
=0A=
jQuery.extend({=0A=
	noConflict: function( deep ) {=0A=
		if ( window.$ =3D=3D=3D jQuery ) {=0A=
			window.$ =3D _$;=0A=
		}=0A=
=0A=
		if ( deep && window.jQuery =3D=3D=3D jQuery ) {=0A=
			window.jQuery =3D _jQuery;=0A=
		}=0A=
=0A=
		return jQuery;=0A=
	},=0A=
=0A=
	// Is the DOM ready to be used? Set to true once it occurs.=0A=
	isReady: false,=0A=
=0A=
	// A counter to track how many items to wait for before=0A=
	// the ready event fires. See #6781=0A=
	readyWait: 1,=0A=
=0A=
	// Hold (or release) the ready event=0A=
	holdReady: function( hold ) {=0A=
		if ( hold ) {=0A=
			jQuery.readyWait++;=0A=
		} else {=0A=
			jQuery.ready( true );=0A=
		}=0A=
	},=0A=
=0A=
	// Handle when the DOM is ready=0A=
	ready: function( wait ) {=0A=
		// Either a released hold or an DOMready/load event and not yet ready=0A=
		if ( (wait =3D=3D=3D true && !--jQuery.readyWait) || (wait !=3D=3D =
true && !jQuery.isReady) ) {=0A=
			// Make sure body exists, at least, in case IE gets a little =
overzealous (ticket #5443).=0A=
			if ( !document.body ) {=0A=
				return setTimeout( jQuery.ready, 1 );=0A=
			}=0A=
=0A=
			// Remember that the DOM is ready=0A=
			jQuery.isReady =3D true;=0A=
=0A=
			// If a normal DOM Ready event fired, decrement, and wait if need be=0A=
			if ( wait !=3D=3D true && --jQuery.readyWait > 0 ) {=0A=
				return;=0A=
			}=0A=
=0A=
			// If there are functions bound, to execute=0A=
			readyList.resolveWith( document, [ jQuery ] );=0A=
=0A=
			// Trigger any bound ready events=0A=
			if ( jQuery.fn.trigger ) {=0A=
				jQuery( document ).trigger( "ready" ).unbind( "ready" );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	bindReady: function() {=0A=
		if ( readyList ) {=0A=
			return;=0A=
		}=0A=
=0A=
		readyList =3D jQuery._Deferred();=0A=
=0A=
		// Catch cases where $(document).ready() is called after the=0A=
		// browser event has already occurred.=0A=
		if ( document.readyState =3D=3D=3D "complete" ) {=0A=
			// Handle it asynchronously to allow scripts the opportunity to delay =
ready=0A=
			return setTimeout( jQuery.ready, 1 );=0A=
		}=0A=
=0A=
		// Mozilla, Opera and webkit nightlies currently support this event=0A=
		if ( document.addEventListener ) {=0A=
			// Use the handy event callback=0A=
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, =
false );=0A=
=0A=
			// A fallback to window.onload, that will always work=0A=
			window.addEventListener( "load", jQuery.ready, false );=0A=
=0A=
		// If IE event model is used=0A=
		} else if ( document.attachEvent ) {=0A=
			// ensure firing before onload,=0A=
			// maybe late but safe also for iframes=0A=
			document.attachEvent( "onreadystatechange", DOMContentLoaded );=0A=
=0A=
			// A fallback to window.onload, that will always work=0A=
			window.attachEvent( "onload", jQuery.ready );=0A=
=0A=
			// If IE and not a frame=0A=
			// continually check to see if the document is ready=0A=
			var toplevel =3D false;=0A=
=0A=
			try {=0A=
				toplevel =3D window.frameElement =3D=3D null;=0A=
			} catch(e) {}=0A=
=0A=
			if ( document.documentElement.doScroll && toplevel ) {=0A=
				doScrollCheck();=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	// See test/unit/core.js for details concerning isFunction.=0A=
	// Since version 1.3, DOM methods and functions like alert=0A=
	// aren't supported. They return false on IE (#2968).=0A=
	isFunction: function( obj ) {=0A=
		return jQuery.type(obj) =3D=3D=3D "function";=0A=
	},=0A=
=0A=
	isArray: Array.isArray || function( obj ) {=0A=
		return jQuery.type(obj) =3D=3D=3D "array";=0A=
	},=0A=
=0A=
	// A crude way of determining if an object is a window=0A=
	isWindow: function( obj ) {=0A=
		return obj && typeof obj =3D=3D=3D "object" && "setInterval" in obj;=0A=
	},=0A=
=0A=
	isNaN: function( obj ) {=0A=
		return obj =3D=3D null || !rdigit.test( obj ) || isNaN( obj );=0A=
	},=0A=
=0A=
	type: function( obj ) {=0A=
		return obj =3D=3D null ?=0A=
			String( obj ) :=0A=
			class2type[ toString.call(obj) ] || "object";=0A=
	},=0A=
=0A=
	isPlainObject: function( obj ) {=0A=
		// Must be an Object.=0A=
		// Because of IE, we also have to check the presence of the =
constructor property.=0A=
		// Make sure that DOM nodes and window objects don't pass through, as =
well=0A=
		if ( !obj || jQuery.type(obj) !=3D=3D "object" || obj.nodeType || =
jQuery.isWindow( obj ) ) {=0A=
			return false;=0A=
		}=0A=
=0A=
		// Not own constructor property must be Object=0A=
		if ( obj.constructor &&=0A=
			!hasOwn.call(obj, "constructor") &&=0A=
			!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {=0A=
			return false;=0A=
		}=0A=
=0A=
		// Own properties are enumerated firstly, so to speed up,=0A=
		// if last one is own, then all properties are own.=0A=
=0A=
		var key;=0A=
		for ( key in obj ) {}=0A=
=0A=
		return key =3D=3D=3D undefined || hasOwn.call( obj, key );=0A=
	},=0A=
=0A=
	isEmptyObject: function( obj ) {=0A=
		for ( var name in obj ) {=0A=
			return false;=0A=
		}=0A=
		return true;=0A=
	},=0A=
=0A=
	error: function( msg ) {=0A=
		throw msg;=0A=
	},=0A=
=0A=
	parseJSON: function( data ) {=0A=
		if ( typeof data !=3D=3D "string" || !data ) {=0A=
			return null;=0A=
		}=0A=
=0A=
		// Make sure leading/trailing whitespace is removed (IE can't handle =
it)=0A=
		data =3D jQuery.trim( data );=0A=
=0A=
		// Attempt to parse using the native JSON parser first=0A=
		if ( window.JSON && window.JSON.parse ) {=0A=
			return window.JSON.parse( data );=0A=
		}=0A=
=0A=
		// Make sure the incoming data is actual JSON=0A=
		// Logic borrowed from http://json.org/json2.js=0A=
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )=0A=
			.replace( rvalidtokens, "]" )=0A=
			.replace( rvalidbraces, "")) ) {=0A=
=0A=
			return (new Function( "return " + data ))();=0A=
=0A=
		}=0A=
		jQuery.error( "Invalid JSON: " + data );=0A=
	},=0A=
=0A=
	// Cross-browser xml parsing=0A=
	// (xml & tmp used internally)=0A=
	parseXML: function( data , xml , tmp ) {=0A=
=0A=
		if ( window.DOMParser ) { // Standard=0A=
			tmp =3D new DOMParser();=0A=
			xml =3D tmp.parseFromString( data , "text/xml" );=0A=
		} else { // IE=0A=
			xml =3D new ActiveXObject( "Microsoft.XMLDOM" );=0A=
			xml.async =3D "false";=0A=
			xml.loadXML( data );=0A=
		}=0A=
=0A=
		tmp =3D xml.documentElement;=0A=
=0A=
		if ( ! tmp || ! tmp.nodeName || tmp.nodeName =3D=3D=3D "parsererror" ) =
{=0A=
			jQuery.error( "Invalid XML: " + data );=0A=
		}=0A=
=0A=
		return xml;=0A=
	},=0A=
=0A=
	noop: function() {},=0A=
=0A=
	// Evaluates a script in a global context=0A=
	// Workarounds based on findings by Jim Driscoll=0A=
	// =
http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-=
global-context=0A=
	globalEval: function( data ) {=0A=
		if ( data && rnotwhite.test( data ) ) {=0A=
			// We use execScript on Internet Explorer=0A=
			// We use an anonymous function so that context is window=0A=
			// rather than jQuery in Firefox=0A=
			( window.execScript || function( data ) {=0A=
				window[ "eval" ].call( window, data );=0A=
			} )( data );=0A=
		}=0A=
	},=0A=
=0A=
	// Converts a dashed string to camelCased string;=0A=
	// Used by both the css and data modules=0A=
	camelCase: function( string ) {=0A=
		return string.replace( rdashAlpha, fcamelCase );=0A=
	},=0A=
=0A=
	nodeName: function( elem, name ) {=0A=
		return elem.nodeName && elem.nodeName.toUpperCase() =3D=3D=3D =
name.toUpperCase();=0A=
	},=0A=
=0A=
	// args is for internal usage only=0A=
	each: function( object, callback, args ) {=0A=
		var name, i =3D 0,=0A=
			length =3D object.length,=0A=
			isObj =3D length =3D=3D=3D undefined || jQuery.isFunction( object );=0A=
=0A=
		if ( args ) {=0A=
			if ( isObj ) {=0A=
				for ( name in object ) {=0A=
					if ( callback.apply( object[ name ], args ) =3D=3D=3D false ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			} else {=0A=
				for ( ; i < length; ) {=0A=
					if ( callback.apply( object[ i++ ], args ) =3D=3D=3D false ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
		// A special, fast, case for the most common use of each=0A=
		} else {=0A=
			if ( isObj ) {=0A=
				for ( name in object ) {=0A=
					if ( callback.call( object[ name ], name, object[ name ] ) =
=3D=3D=3D false ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			} else {=0A=
				for ( ; i < length; ) {=0A=
					if ( callback.call( object[ i ], i, object[ i++ ] ) =3D=3D=3D false =
) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return object;=0A=
	},=0A=
=0A=
	// Use native String.trim function wherever possible=0A=
	trim: trim ?=0A=
		function( text ) {=0A=
			return text =3D=3D null ?=0A=
				"" :=0A=
				trim.call( text );=0A=
		} :=0A=
=0A=
		// Otherwise use our own trimming functionality=0A=
		function( text ) {=0A=
			return text =3D=3D null ?=0A=
				"" :=0A=
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );=0A=
		},=0A=
=0A=
	// results is for internal usage only=0A=
	makeArray: function( array, results ) {=0A=
		var ret =3D results || [];=0A=
=0A=
		if ( array !=3D null ) {=0A=
			// The window, strings (and functions) also have 'length'=0A=
			// The extra typeof function check is to prevent crashes=0A=
			// in Safari 2 (See: #3039)=0A=
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930=0A=
			var type =3D jQuery.type( array );=0A=
=0A=
			if ( array.length =3D=3D null || type =3D=3D=3D "string" || type =
=3D=3D=3D "function" || type =3D=3D=3D "regexp" || jQuery.isWindow( =
array ) ) {=0A=
				push.call( ret, array );=0A=
			} else {=0A=
				jQuery.merge( ret, array );=0A=
			}=0A=
		}=0A=
=0A=
		return ret;=0A=
	},=0A=
=0A=
	inArray: function( elem, array ) {=0A=
=0A=
		if ( indexOf ) {=0A=
			return indexOf.call( array, elem );=0A=
		}=0A=
=0A=
		for ( var i =3D 0, length =3D array.length; i < length; i++ ) {=0A=
			if ( array[ i ] =3D=3D=3D elem ) {=0A=
				return i;=0A=
			}=0A=
		}=0A=
=0A=
		return -1;=0A=
	},=0A=
=0A=
	merge: function( first, second ) {=0A=
		var i =3D first.length,=0A=
			j =3D 0;=0A=
=0A=
		if ( typeof second.length =3D=3D=3D "number" ) {=0A=
			for ( var l =3D second.length; j < l; j++ ) {=0A=
				first[ i++ ] =3D second[ j ];=0A=
			}=0A=
=0A=
		} else {=0A=
			while ( second[j] !=3D=3D undefined ) {=0A=
				first[ i++ ] =3D second[ j++ ];=0A=
			}=0A=
		}=0A=
=0A=
		first.length =3D i;=0A=
=0A=
		return first;=0A=
	},=0A=
=0A=
	grep: function( elems, callback, inv ) {=0A=
		var ret =3D [], retVal;=0A=
		inv =3D !!inv;=0A=
=0A=
		// Go through the array, only saving the items=0A=
		// that pass the validator function=0A=
		for ( var i =3D 0, length =3D elems.length; i < length; i++ ) {=0A=
			retVal =3D !!callback( elems[ i ], i );=0A=
			if ( inv !=3D=3D retVal ) {=0A=
				ret.push( elems[ i ] );=0A=
			}=0A=
		}=0A=
=0A=
		return ret;=0A=
	},=0A=
=0A=
	// arg is for internal usage only=0A=
	map: function( elems, callback, arg ) {=0A=
		var value, key, ret =3D [],=0A=
			i =3D 0,=0A=
			length =3D elems.length,=0A=
			// jquery objects are treated as arrays=0A=
			isArray =3D elems instanceof jQuery || length !=3D=3D undefined && =
typeof length =3D=3D=3D "number" && ( ( length > 0 && elems[ 0 ] && =
elems[ length -1 ] ) || length =3D=3D=3D 0 || jQuery.isArray( elems ) ) ;=0A=
=0A=
		// Go through the array, translating each of the items to their=0A=
		if ( isArray ) {=0A=
			for ( ; i < length; i++ ) {=0A=
				value =3D callback( elems[ i ], i, arg );=0A=
=0A=
				if ( value !=3D null ) {=0A=
					ret[ ret.length ] =3D value;=0A=
				}=0A=
			}=0A=
=0A=
		// Go through every key on the object,=0A=
		} else {=0A=
			for ( key in elems ) {=0A=
				value =3D callback( elems[ key ], key, arg );=0A=
=0A=
				if ( value !=3D null ) {=0A=
					ret[ ret.length ] =3D value;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Flatten any nested arrays=0A=
		return ret.concat.apply( [], ret );=0A=
	},=0A=
=0A=
	// A global GUID counter for objects=0A=
	guid: 1,=0A=
=0A=
	// Bind a function to a context, optionally partially applying any=0A=
	// arguments.=0A=
	proxy: function( fn, context ) {=0A=
		if ( typeof context =3D=3D=3D "string" ) {=0A=
			var tmp =3D fn[ context ];=0A=
			context =3D fn;=0A=
			fn =3D tmp;=0A=
		}=0A=
=0A=
		// Quick check to determine if target is callable, in the spec=0A=
		// this throws a TypeError, but we will just return undefined.=0A=
		if ( !jQuery.isFunction( fn ) ) {=0A=
			return undefined;=0A=
		}=0A=
=0A=
		// Simulated bind=0A=
		var args =3D slice.call( arguments, 2 ),=0A=
			proxy =3D function() {=0A=
				return fn.apply( context, args.concat( slice.call( arguments ) ) );=0A=
			};=0A=
=0A=
		// Set the guid of unique handler to the same of original handler, so =
it can be removed=0A=
		proxy.guid =3D fn.guid =3D fn.guid || proxy.guid || jQuery.guid++;=0A=
=0A=
		return proxy;=0A=
	},=0A=
=0A=
	// Mutifunctional method to get and set values to a collection=0A=
	// The value/s can optionally be executed if it's a function=0A=
	access: function( elems, key, value, exec, fn, pass ) {=0A=
		var length =3D elems.length;=0A=
=0A=
		// Setting many attributes=0A=
		if ( typeof key =3D=3D=3D "object" ) {=0A=
			for ( var k in key ) {=0A=
				jQuery.access( elems, k, key[k], exec, fn, value );=0A=
			}=0A=
			return elems;=0A=
		}=0A=
=0A=
		// Setting one attribute=0A=
		if ( value !=3D=3D undefined ) {=0A=
			// Optionally, function values get executed if exec is true=0A=
			exec =3D !pass && exec && jQuery.isFunction(value);=0A=
=0A=
			for ( var i =3D 0; i < length; i++ ) {=0A=
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key =
) ) : value, pass );=0A=
			}=0A=
=0A=
			return elems;=0A=
		}=0A=
=0A=
		// Getting an attribute=0A=
		return length ? fn( elems[0], key ) : undefined;=0A=
	},=0A=
=0A=
	now: function() {=0A=
		return (new Date()).getTime();=0A=
	},=0A=
=0A=
	// Use of jQuery.browser is frowned upon.=0A=
	// More details: http://docs.jquery.com/Utilities/jQuery.browser=0A=
	uaMatch: function( ua ) {=0A=
		ua =3D ua.toLowerCase();=0A=
=0A=
		var match =3D rwebkit.exec( ua ) ||=0A=
			ropera.exec( ua ) ||=0A=
			rmsie.exec( ua ) ||=0A=
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||=0A=
			[];=0A=
=0A=
		return { browser: match[1] || "", version: match[2] || "0" };=0A=
	},=0A=
=0A=
	sub: function() {=0A=
		function jQuerySub( selector, context ) {=0A=
			return new jQuerySub.fn.init( selector, context );=0A=
		}=0A=
		jQuery.extend( true, jQuerySub, this );=0A=
		jQuerySub.superclass =3D this;=0A=
		jQuerySub.fn =3D jQuerySub.prototype =3D this();=0A=
		jQuerySub.fn.constructor =3D jQuerySub;=0A=
		jQuerySub.sub =3D this.sub;=0A=
		jQuerySub.fn.init =3D function init( selector, context ) {=0A=
			if ( context && context instanceof jQuery && !(context instanceof =
jQuerySub) ) {=0A=
				context =3D jQuerySub( context );=0A=
			}=0A=
=0A=
			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );=0A=
		};=0A=
		jQuerySub.fn.init.prototype =3D jQuerySub.fn;=0A=
		var rootjQuerySub =3D jQuerySub(document);=0A=
		return jQuerySub;=0A=
	},=0A=
=0A=
	browser: {}=0A=
});=0A=
=0A=
// Populate the class2type map=0A=
jQuery.each("Boolean Number String Function Array Date RegExp =
Object".split(" "), function(i, name) {=0A=
	class2type[ "[object " + name + "]" ] =3D name.toLowerCase();=0A=
});=0A=
=0A=
browserMatch =3D jQuery.uaMatch( userAgent );=0A=
if ( browserMatch.browser ) {=0A=
	jQuery.browser[ browserMatch.browser ] =3D true;=0A=
	jQuery.browser.version =3D browserMatch.version;=0A=
}=0A=
=0A=
// Deprecated, use jQuery.browser.webkit instead=0A=
if ( jQuery.browser.webkit ) {=0A=
	jQuery.browser.safari =3D true;=0A=
}=0A=
=0A=
// IE doesn't match non-breaking spaces with \s=0A=
if ( rnotwhite.test( "\xA0" ) ) {=0A=
	trimLeft =3D /^[\s\xA0]+/;=0A=
	trimRight =3D /[\s\xA0]+$/;=0A=
}=0A=
=0A=
// All jQuery objects should point back to these=0A=
rootjQuery =3D jQuery(document);=0A=
=0A=
// Cleanup functions for the document ready method=0A=
if ( document.addEventListener ) {=0A=
	DOMContentLoaded =3D function() {=0A=
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, =
false );=0A=
		jQuery.ready();=0A=
	};=0A=
=0A=
} else if ( document.attachEvent ) {=0A=
	DOMContentLoaded =3D function() {=0A=
		// Make sure body exists, at least, in case IE gets a little =
overzealous (ticket #5443).=0A=
		if ( document.readyState =3D=3D=3D "complete" ) {=0A=
			document.detachEvent( "onreadystatechange", DOMContentLoaded );=0A=
			jQuery.ready();=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
// The DOM ready check for Internet Explorer=0A=
function doScrollCheck() {=0A=
	if ( jQuery.isReady ) {=0A=
		return;=0A=
	}=0A=
=0A=
	try {=0A=
		// If IE is used, use the trick by Diego Perini=0A=
		// http://javascript.nwbox.com/IEContentLoaded/=0A=
		document.documentElement.doScroll("left");=0A=
	} catch(e) {=0A=
		setTimeout( doScrollCheck, 1 );=0A=
		return;=0A=
	}=0A=
=0A=
	// and execute any waiting functions=0A=
	jQuery.ready();=0A=
}=0A=
=0A=
return jQuery;=0A=
=0A=
})();=0A=
=0A=
=0A=
var // Promise methods=0A=
	promiseMethods =3D "done fail isResolved isRejected promise then always =
pipe".split( " " ),=0A=
	// Static reference to slice=0A=
	sliceDeferred =3D [].slice;=0A=
=0A=
jQuery.extend({=0A=
	// Create a simple deferred (one callbacks list)=0A=
	_Deferred: function() {=0A=
		var // callbacks list=0A=
			callbacks =3D [],=0A=
			// stored [ context , args ]=0A=
			fired,=0A=
			// to avoid firing when already doing so=0A=
			firing,=0A=
			// flag to know if the deferred has been cancelled=0A=
			cancelled,=0A=
			// the deferred itself=0A=
			deferred  =3D {=0A=
=0A=
				// done( f1, f2, ...)=0A=
				done: function() {=0A=
					if ( !cancelled ) {=0A=
						var args =3D arguments,=0A=
							i,=0A=
							length,=0A=
							elem,=0A=
							type,=0A=
							_fired;=0A=
						if ( fired ) {=0A=
							_fired =3D fired;=0A=
							fired =3D 0;=0A=
						}=0A=
						for ( i =3D 0, length =3D args.length; i < length; i++ ) {=0A=
							elem =3D args[ i ];=0A=
							type =3D jQuery.type( elem );=0A=
							if ( type =3D=3D=3D "array" ) {=0A=
								deferred.done.apply( deferred, elem );=0A=
							} else if ( type =3D=3D=3D "function" ) {=0A=
								callbacks.push( elem );=0A=
							}=0A=
						}=0A=
						if ( _fired ) {=0A=
							deferred.resolveWith( _fired[ 0 ], _fired[ 1 ] );=0A=
						}=0A=
					}=0A=
					return this;=0A=
				},=0A=
=0A=
				// resolve with given context and args=0A=
				resolveWith: function( context, args ) {=0A=
					if ( !cancelled && !fired && !firing ) {=0A=
						// make sure args are available (#8421)=0A=
						args =3D args || [];=0A=
						firing =3D 1;=0A=
						try {=0A=
							while( callbacks[ 0 ] ) {=0A=
								callbacks.shift().apply( context, args );=0A=
							}=0A=
						}=0A=
						finally {=0A=
							fired =3D [ context, args ];=0A=
							firing =3D 0;=0A=
						}=0A=
					}=0A=
					return this;=0A=
				},=0A=
=0A=
				// resolve with this as context and given arguments=0A=
				resolve: function() {=0A=
					deferred.resolveWith( this, arguments );=0A=
					return this;=0A=
				},=0A=
=0A=
				// Has this deferred been resolved?=0A=
				isResolved: function() {=0A=
					return !!( firing || fired );=0A=
				},=0A=
=0A=
				// Cancel=0A=
				cancel: function() {=0A=
					cancelled =3D 1;=0A=
					callbacks =3D [];=0A=
					return this;=0A=
				}=0A=
			};=0A=
=0A=
		return deferred;=0A=
	},=0A=
=0A=
	// Full fledged deferred (two callbacks list)=0A=
	Deferred: function( func ) {=0A=
		var deferred =3D jQuery._Deferred(),=0A=
			failDeferred =3D jQuery._Deferred(),=0A=
			promise;=0A=
		// Add errorDeferred methods, then and promise=0A=
		jQuery.extend( deferred, {=0A=
			then: function( doneCallbacks, failCallbacks ) {=0A=
				deferred.done( doneCallbacks ).fail( failCallbacks );=0A=
				return this;=0A=
			},=0A=
			always: function() {=0A=
				return deferred.done.apply( deferred, arguments ).fail.apply( this, =
arguments );=0A=
			},=0A=
			fail: failDeferred.done,=0A=
			rejectWith: failDeferred.resolveWith,=0A=
			reject: failDeferred.resolve,=0A=
			isRejected: failDeferred.isResolved,=0A=
			pipe: function( fnDone, fnFail ) {=0A=
				return jQuery.Deferred(function( newDefer ) {=0A=
					jQuery.each( {=0A=
						done: [ fnDone, "resolve" ],=0A=
						fail: [ fnFail, "reject" ]=0A=
					}, function( handler, data ) {=0A=
						var fn =3D data[ 0 ],=0A=
							action =3D data[ 1 ],=0A=
							returned;=0A=
						if ( jQuery.isFunction( fn ) ) {=0A=
							deferred[ handler ](function() {=0A=
								returned =3D fn.apply( this, arguments );=0A=
								if ( returned && jQuery.isFunction( returned.promise ) ) {=0A=
									returned.promise().then( newDefer.resolve, newDefer.reject );=0A=
								} else {=0A=
									newDefer[ action ]( returned );=0A=
								}=0A=
							});=0A=
						} else {=0A=
							deferred[ handler ]( newDefer[ action ] );=0A=
						}=0A=
					});=0A=
				}).promise();=0A=
			},=0A=
			// Get a promise for this deferred=0A=
			// If obj is provided, the promise aspect is added to the object=0A=
			promise: function( obj ) {=0A=
				if ( obj =3D=3D null ) {=0A=
					if ( promise ) {=0A=
						return promise;=0A=
					}=0A=
					promise =3D obj =3D {};=0A=
				}=0A=
				var i =3D promiseMethods.length;=0A=
				while( i-- ) {=0A=
					obj[ promiseMethods[i] ] =3D deferred[ promiseMethods[i] ];=0A=
				}=0A=
				return obj;=0A=
			}=0A=
		});=0A=
		// Make sure only one callback list will be used=0A=
		deferred.done( failDeferred.cancel ).fail( deferred.cancel );=0A=
		// Unexpose cancel=0A=
		delete deferred.cancel;=0A=
		// Call given func if any=0A=
		if ( func ) {=0A=
			func.call( deferred, deferred );=0A=
		}=0A=
		return deferred;=0A=
	},=0A=
=0A=
	// Deferred helper=0A=
	when: function( firstParam ) {=0A=
		var args =3D arguments,=0A=
			i =3D 0,=0A=
			length =3D args.length,=0A=
			count =3D length,=0A=
			deferred =3D length <=3D 1 && firstParam && jQuery.isFunction( =
firstParam.promise ) ?=0A=
				firstParam :=0A=
				jQuery.Deferred();=0A=
		function resolveFunc( i ) {=0A=
			return function( value ) {=0A=
				args[ i ] =3D arguments.length > 1 ? sliceDeferred.call( arguments, =
0 ) : value;=0A=
				if ( !( --count ) ) {=0A=
					// Strange bug in FF4:=0A=
					// Values changed onto the arguments object sometimes end up as =
undefined values=0A=
					// outside the $.when method. Cloning the object into a fresh array =
solves the issue=0A=
					deferred.resolveWith( deferred, sliceDeferred.call( args, 0 ) );=0A=
				}=0A=
			};=0A=
		}=0A=
		if ( length > 1 ) {=0A=
			for( ; i < length; i++ ) {=0A=
				if ( args[ i ] && jQuery.isFunction( args[ i ].promise ) ) {=0A=
					args[ i ].promise().then( resolveFunc(i), deferred.reject );=0A=
				} else {=0A=
					--count;=0A=
				}=0A=
			}=0A=
			if ( !count ) {=0A=
				deferred.resolveWith( deferred, args );=0A=
			}=0A=
		} else if ( deferred !=3D=3D firstParam ) {=0A=
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );=0A=
		}=0A=
		return deferred.promise();=0A=
	}=0A=
});=0A=
=0A=
=0A=
=0A=
jQuery.support =3D (function() {=0A=
=0A=
	var div =3D document.createElement( "div" ),=0A=
		documentElement =3D document.documentElement,=0A=
		all,=0A=
		a,=0A=
		select,=0A=
		opt,=0A=
		input,=0A=
		marginDiv,=0A=
		support,=0A=
		fragment,=0A=
		body,=0A=
		testElementParent,=0A=
		testElement,=0A=
		testElementStyle,=0A=
		tds,=0A=
		events,=0A=
		eventName,=0A=
		i,=0A=
		isSupported;=0A=
=0A=
	// Preliminary tests=0A=
	div.setAttribute("className", "t");=0A=
	div.innerHTML =3D "   <link/><table></table><a href=3D'/a' =
style=3D'top:1px;float:left;opacity:.55;'>a</a><input =
type=3D'checkbox'/>";=0A=
=0A=
	all =3D div.getElementsByTagName( "*" );=0A=
	a =3D div.getElementsByTagName( "a" )[ 0 ];=0A=
=0A=
	// Can't get basic test support=0A=
	if ( !all || !all.length || !a ) {=0A=
		return {};=0A=
	}=0A=
=0A=
	// First batch of supports tests=0A=
	select =3D document.createElement( "select" );=0A=
	opt =3D select.appendChild( document.createElement("option") );=0A=
	input =3D div.getElementsByTagName( "input" )[ 0 ];=0A=
=0A=
	support =3D {=0A=
		// IE strips leading whitespace when .innerHTML is used=0A=
		leadingWhitespace: ( div.firstChild.nodeType =3D=3D=3D 3 ),=0A=
=0A=
		// Make sure that tbody elements aren't automatically inserted=0A=
		// IE will insert them into empty tables=0A=
		tbody: !div.getElementsByTagName( "tbody" ).length,=0A=
=0A=
		// Make sure that link elements get serialized correctly by innerHTML=0A=
		// This requires a wrapper element in IE=0A=
		htmlSerialize: !!div.getElementsByTagName( "link" ).length,=0A=
=0A=
		// Get the style information from getAttribute=0A=
		// (IE uses .cssText instead)=0A=
		style: /top/.test( a.getAttribute("style") ),=0A=
=0A=
		// Make sure that URLs aren't manipulated=0A=
		// (IE normalizes it by default)=0A=
		hrefNormalized: ( a.getAttribute( "href" ) =3D=3D=3D "/a" ),=0A=
=0A=
		// Make sure that element opacity exists=0A=
		// (IE uses filter instead)=0A=
		// Use a regex to work around a WebKit issue. See #5145=0A=
		opacity: /^0.55$/.test( a.style.opacity ),=0A=
=0A=
		// Verify style float existence=0A=
		// (IE uses styleFloat instead of cssFloat)=0A=
		cssFloat: !!a.style.cssFloat,=0A=
=0A=
		// Make sure that if no value is specified for a checkbox=0A=
		// that it defaults to "on".=0A=
		// (WebKit defaults to "" instead)=0A=
		checkOn: ( input.value =3D=3D=3D "on" ),=0A=
=0A=
		// Make sure that a selected-by-default option has a working selected =
property.=0A=
		// (WebKit defaults to false instead of true, IE too, if it's in an =
optgroup)=0A=
		optSelected: opt.selected,=0A=
=0A=
		// Test setAttribute on camelCase class. If it works, we need =
attrFixes when doing get/setAttribute (ie6/7)=0A=
		getSetAttribute: div.className !=3D=3D "t",=0A=
=0A=
		// Will be defined later=0A=
		submitBubbles: true,=0A=
		changeBubbles: true,=0A=
		focusinBubbles: false,=0A=
		deleteExpando: true,=0A=
		noCloneEvent: true,=0A=
		inlineBlockNeedsLayout: false,=0A=
		shrinkWrapBlocks: false,=0A=
		reliableMarginRight: true=0A=
	};=0A=
=0A=
	// Make sure checked status is properly cloned=0A=
	input.checked =3D true;=0A=
	support.noCloneChecked =3D input.cloneNode( true ).checked;=0A=
=0A=
	// Make sure that the options inside disabled selects aren't marked as =
disabled=0A=
	// (WebKit marks them as disabled)=0A=
	select.disabled =3D true;=0A=
	support.optDisabled =3D !opt.disabled;=0A=
=0A=
	// Test to see if it's possible to delete an expando from an element=0A=
	// Fails in Internet Explorer=0A=
	try {=0A=
		delete div.test;=0A=
	} catch( e ) {=0A=
		support.deleteExpando =3D false;=0A=
	}=0A=
=0A=
	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {=0A=
		div.attachEvent( "onclick", function() {=0A=
			// Cloning a node shouldn't copy over any=0A=
			// bound event handlers (IE does this)=0A=
			support.noCloneEvent =3D false;=0A=
		});=0A=
		div.cloneNode( true ).fireEvent( "onclick" );=0A=
	}=0A=
=0A=
	// Check if a radio maintains it's value=0A=
	// after being appended to the DOM=0A=
	input =3D document.createElement("input");=0A=
	input.value =3D "t";=0A=
	input.setAttribute("type", "radio");=0A=
	support.radioValue =3D input.value =3D=3D=3D "t";=0A=
=0A=
	input.setAttribute("checked", "checked");=0A=
	div.appendChild( input );=0A=
	fragment =3D document.createDocumentFragment();=0A=
	fragment.appendChild( div.firstChild );=0A=
=0A=
	// WebKit doesn't clone checked state correctly in fragments=0A=
	support.checkClone =3D fragment.cloneNode( true ).cloneNode( true =
).lastChild.checked;=0A=
=0A=
	div.innerHTML =3D "";=0A=
=0A=
	// Figure out if the W3C box model works as expected=0A=
	div.style.width =3D div.style.paddingLeft =3D "1px";=0A=
=0A=
	body =3D document.getElementsByTagName( "body" )[ 0 ];=0A=
	// We use our own, invisible, body unless the body is already present=0A=
	// in which case we use a div (#9239)=0A=
	testElement =3D document.createElement( body ? "div" : "body" );=0A=
	testElementStyle =3D {=0A=
		visibility: "hidden",=0A=
		width: 0,=0A=
		height: 0,=0A=
		border: 0,=0A=
		margin: 0=0A=
	};=0A=
	if ( body ) {=0A=
		jQuery.extend( testElementStyle, {=0A=
			position: "absolute",=0A=
			left: -1000,=0A=
			top: -1000=0A=
		});=0A=
	}=0A=
	for ( i in testElementStyle ) {=0A=
		testElement.style[ i ] =3D testElementStyle[ i ];=0A=
	}=0A=
	testElement.appendChild( div );=0A=
	testElementParent =3D body || documentElement;=0A=
	testElementParent.insertBefore( testElement, =
testElementParent.firstChild );=0A=
=0A=
	// Check if a disconnected checkbox will retain its checked=0A=
	// value of true after appended to the DOM (IE6/7)=0A=
	support.appendChecked =3D input.checked;=0A=
=0A=
	support.boxModel =3D div.offsetWidth =3D=3D=3D 2;=0A=
=0A=
	if ( "zoom" in div.style ) {=0A=
		// Check if natively block-level elements act like inline-block=0A=
		// elements when setting their display to 'inline' and giving=0A=
		// them layout=0A=
		// (IE < 8 does this)=0A=
		div.style.display =3D "inline";=0A=
		div.style.zoom =3D 1;=0A=
		support.inlineBlockNeedsLayout =3D ( div.offsetWidth =3D=3D=3D 2 );=0A=
=0A=
		// Check if elements with layout shrink-wrap their children=0A=
		// (IE 6 does this)=0A=
		div.style.display =3D "";=0A=
		div.innerHTML =3D "<div style=3D'width:4px;'></div>";=0A=
		support.shrinkWrapBlocks =3D ( div.offsetWidth !=3D=3D 2 );=0A=
	}=0A=
=0A=
	div.innerHTML =3D "<table><tr><td =
style=3D'padding:0;border:0;display:none'></td><td>t</td></tr></table>";=0A=
	tds =3D div.getElementsByTagName( "td" );=0A=
=0A=
	// Check if table cells still have offsetWidth/Height when they are set=0A=
	// to display:none and there are still other visible table cells in a=0A=
	// table row; if so, offsetWidth/Height are not reliable for use when=0A=
	// determining if an element has been hidden directly using=0A=
	// display:none (it is still safe to use offsets if a parent element is=0A=
	// hidden; don safety goggles and see bug #4512 for more information).=0A=
	// (only IE 8 fails this test)=0A=
	isSupported =3D ( tds[ 0 ].offsetHeight =3D=3D=3D 0 );=0A=
=0A=
	tds[ 0 ].style.display =3D "";=0A=
	tds[ 1 ].style.display =3D "none";=0A=
=0A=
	// Check if empty table cells still have offsetWidth/Height=0A=
	// (IE < 8 fail this test)=0A=
	support.reliableHiddenOffsets =3D isSupported && ( tds[ 0 =
].offsetHeight =3D=3D=3D 0 );=0A=
	div.innerHTML =3D "";=0A=
=0A=
	// Check if div with explicit width and no margin-right incorrectly=0A=
	// gets computed margin-right based on width of container. For more=0A=
	// info see bug #3333=0A=
	// Fails in WebKit before Feb 2011 nightlies=0A=
	// WebKit Bug 13343 - getComputedStyle returns wrong value for =
margin-right=0A=
	if ( document.defaultView && document.defaultView.getComputedStyle ) {=0A=
		marginDiv =3D document.createElement( "div" );=0A=
		marginDiv.style.width =3D "0";=0A=
		marginDiv.style.marginRight =3D "0";=0A=
		div.appendChild( marginDiv );=0A=
		support.reliableMarginRight =3D=0A=
			( parseInt( ( document.defaultView.getComputedStyle( marginDiv, null =
) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) =3D=3D=3D 0;=0A=
	}=0A=
=0A=
	// Remove the body element we added=0A=
	testElement.innerHTML =3D "";=0A=
	testElementParent.removeChild( testElement );=0A=
=0A=
	// Technique from Juriy Zaytsev=0A=
	// =
http://thinkweb2.com/projects/prototype/detecting-event-support-without-b=
rowser-sniffing/=0A=
	// We only care about the case where non-standard event systems=0A=
	// are used, namely in IE. Short-circuiting here helps us to=0A=
	// avoid an eval call (in setAttribute) which can cause CSP=0A=
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP=0A=
	if ( div.attachEvent ) {=0A=
		for( i in {=0A=
			submit: 1,=0A=
			change: 1,=0A=
			focusin: 1=0A=
		} ) {=0A=
			eventName =3D "on" + i;=0A=
			isSupported =3D ( eventName in div );=0A=
			if ( !isSupported ) {=0A=
				div.setAttribute( eventName, "return;" );=0A=
				isSupported =3D ( typeof div[ eventName ] =3D=3D=3D "function" );=0A=
			}=0A=
			support[ i + "Bubbles" ] =3D isSupported;=0A=
		}=0A=
	}=0A=
=0A=
	// Null connected elements to avoid leaks in IE=0A=
	testElement =3D fragment =3D select =3D opt =3D body =3D marginDiv =3D =
div =3D input =3D null;=0A=
=0A=
	return support;=0A=
})();=0A=
=0A=
// Keep track of boxModel=0A=
jQuery.boxModel =3D jQuery.support.boxModel;=0A=
=0A=
=0A=
=0A=
=0A=
var rbrace =3D /^(?:\{.*\}|\[.*\])$/,=0A=
	rmultiDash =3D /([a-z])([A-Z])/g;=0A=
=0A=
jQuery.extend({=0A=
	cache: {},=0A=
=0A=
	// Please use with caution=0A=
	uuid: 0,=0A=
=0A=
	// Unique for each copy of jQuery on the page=0A=
	// Non-digits removed to match rinlinejQuery=0A=
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( =
/\D/g, "" ),=0A=
=0A=
	// The following elements throw uncatchable exceptions if you=0A=
	// attempt to add expando properties to them.=0A=
	noData: {=0A=
		"embed": true,=0A=
		// Ban all objects except for Flash (which handle expandos)=0A=
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",=0A=
		"applet": true=0A=
	},=0A=
=0A=
	hasData: function( elem ) {=0A=
		elem =3D elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ =
jQuery.expando ];=0A=
=0A=
		return !!elem && !isEmptyDataObject( elem );=0A=
	},=0A=
=0A=
	data: function( elem, name, data, pvt /* Internal Use Only */ ) {=0A=
		if ( !jQuery.acceptData( elem ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		var internalKey =3D jQuery.expando, getByName =3D typeof name =
=3D=3D=3D "string", thisCache,=0A=
=0A=
			// We have to handle DOM nodes and JS objects differently because =
IE6-7=0A=
			// can't GC object references properly across the DOM-JS boundary=0A=
			isNode =3D elem.nodeType,=0A=
=0A=
			// Only DOM nodes need the global jQuery cache; JS object data is=0A=
			// attached directly to the object so GC can occur automatically=0A=
			cache =3D isNode ? jQuery.cache : elem,=0A=
=0A=
			// Only defining an ID for JS objects if its cache already exists =
allows=0A=
			// the code to shortcut on the same path as a DOM node with no cache=0A=
			id =3D isNode ? elem[ jQuery.expando ] : elem[ jQuery.expando ] && =
jQuery.expando;=0A=
=0A=
		// Avoid doing any more work than we need to when trying to get data =
on an=0A=
		// object that has no data at all=0A=
		if ( (!id || (pvt && id && !cache[ id ][ internalKey ])) && getByName =
&& data =3D=3D=3D undefined ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( !id ) {=0A=
			// Only DOM nodes need a new unique ID for each element since their =
data=0A=
			// ends up in the global cache=0A=
			if ( isNode ) {=0A=
				elem[ jQuery.expando ] =3D id =3D ++jQuery.uuid;=0A=
			} else {=0A=
				id =3D jQuery.expando;=0A=
			}=0A=
		}=0A=
=0A=
		if ( !cache[ id ] ) {=0A=
			cache[ id ] =3D {};=0A=
=0A=
			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery=0A=
			// metadata on plain JS objects when the object is serialized using=0A=
			// JSON.stringify=0A=
			if ( !isNode ) {=0A=
				cache[ id ].toJSON =3D jQuery.noop;=0A=
			}=0A=
		}=0A=
=0A=
		// An object can be passed to jQuery.data instead of a key/value pair; =
this gets=0A=
		// shallow copied over onto the existing cache=0A=
		if ( typeof name =3D=3D=3D "object" || typeof name =3D=3D=3D =
"function" ) {=0A=
			if ( pvt ) {=0A=
				cache[ id ][ internalKey ] =3D jQuery.extend(cache[ id ][ =
internalKey ], name);=0A=
			} else {=0A=
				cache[ id ] =3D jQuery.extend(cache[ id ], name);=0A=
			}=0A=
		}=0A=
=0A=
		thisCache =3D cache[ id ];=0A=
=0A=
		// Internal jQuery data is stored in a separate object inside the =
object's data=0A=
		// cache in order to avoid key collisions between internal data and =
user-defined=0A=
		// data=0A=
		if ( pvt ) {=0A=
			if ( !thisCache[ internalKey ] ) {=0A=
				thisCache[ internalKey ] =3D {};=0A=
			}=0A=
=0A=
			thisCache =3D thisCache[ internalKey ];=0A=
		}=0A=
=0A=
		if ( data !=3D=3D undefined ) {=0A=
			thisCache[ jQuery.camelCase( name ) ] =3D data;=0A=
		}=0A=
=0A=
		// TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users =
should=0A=
		// not attempt to inspect the internal events object using =
jQuery.data, as this=0A=
		// internal data object is undocumented and subject to change.=0A=
		if ( name =3D=3D=3D "events" && !thisCache[name] ) {=0A=
			return thisCache[ internalKey ] && thisCache[ internalKey ].events;=0A=
		}=0A=
=0A=
		return getByName ? =0A=
			// Check for both converted-to-camel and non-converted data property =
names=0A=
			thisCache[ jQuery.camelCase( name ) ] || thisCache[ name ] :=0A=
			thisCache;=0A=
	},=0A=
=0A=
	removeData: function( elem, name, pvt /* Internal Use Only */ ) {=0A=
		if ( !jQuery.acceptData( elem ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		var internalKey =3D jQuery.expando, isNode =3D elem.nodeType,=0A=
=0A=
			// See jQuery.data for more information=0A=
			cache =3D isNode ? jQuery.cache : elem,=0A=
=0A=
			// See jQuery.data for more information=0A=
			id =3D isNode ? elem[ jQuery.expando ] : jQuery.expando;=0A=
=0A=
		// If there is already no cache entry for this object, there is no=0A=
		// purpose in continuing=0A=
		if ( !cache[ id ] ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( name ) {=0A=
			var thisCache =3D pvt ? cache[ id ][ internalKey ] : cache[ id ];=0A=
=0A=
			if ( thisCache ) {=0A=
				delete thisCache[ name ];=0A=
=0A=
				// If there is no data left in the cache, we want to continue=0A=
				// and let the cache object itself get destroyed=0A=
				if ( !isEmptyDataObject(thisCache) ) {=0A=
					return;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// See jQuery.data for more information=0A=
		if ( pvt ) {=0A=
			delete cache[ id ][ internalKey ];=0A=
=0A=
			// Don't destroy the parent cache unless the internal data object=0A=
			// had been the only thing left in it=0A=
			if ( !isEmptyDataObject(cache[ id ]) ) {=0A=
				return;=0A=
			}=0A=
		}=0A=
=0A=
		var internalCache =3D cache[ id ][ internalKey ];=0A=
=0A=
		// Browsers that fail expando deletion also refuse to delete expandos =
on=0A=
		// the window, but it will allow it on all other JS objects; other =
browsers=0A=
		// don't care=0A=
		if ( jQuery.support.deleteExpando || cache !=3D window ) {=0A=
			delete cache[ id ];=0A=
		} else {=0A=
			cache[ id ] =3D null;=0A=
		}=0A=
=0A=
		// We destroyed the entire user cache at once because it's faster than=0A=
		// iterating through each key, but we need to continue to persist =
internal=0A=
		// data if it existed=0A=
		if ( internalCache ) {=0A=
			cache[ id ] =3D {};=0A=
			// TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery=0A=
			// metadata on plain JS objects when the object is serialized using=0A=
			// JSON.stringify=0A=
			if ( !isNode ) {=0A=
				cache[ id ].toJSON =3D jQuery.noop;=0A=
			}=0A=
=0A=
			cache[ id ][ internalKey ] =3D internalCache;=0A=
=0A=
		// Otherwise, we need to eliminate the expando on the node to avoid=0A=
		// false lookups in the cache for entries that no longer exist=0A=
		} else if ( isNode ) {=0A=
			// IE does not allow us to delete expando properties from nodes,=0A=
			// nor does it have a removeAttribute function on Document nodes;=0A=
			// we must handle all of these cases=0A=
			if ( jQuery.support.deleteExpando ) {=0A=
				delete elem[ jQuery.expando ];=0A=
			} else if ( elem.removeAttribute ) {=0A=
				elem.removeAttribute( jQuery.expando );=0A=
			} else {=0A=
				elem[ jQuery.expando ] =3D null;=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	// For internal use only.=0A=
	_data: function( elem, name, data ) {=0A=
		return jQuery.data( elem, name, data, true );=0A=
	},=0A=
=0A=
	// A method for determining if a DOM node can handle the data expando=0A=
	acceptData: function( elem ) {=0A=
		if ( elem.nodeName ) {=0A=
			var match =3D jQuery.noData[ elem.nodeName.toLowerCase() ];=0A=
=0A=
			if ( match ) {=0A=
				return !(match =3D=3D=3D true || elem.getAttribute("classid") =
!=3D=3D match);=0A=
			}=0A=
		}=0A=
=0A=
		return true;=0A=
	}=0A=
});=0A=
=0A=
jQuery.fn.extend({=0A=
	data: function( key, value ) {=0A=
		var data =3D null;=0A=
=0A=
		if ( typeof key =3D=3D=3D "undefined" ) {=0A=
			if ( this.length ) {=0A=
				data =3D jQuery.data( this[0] );=0A=
=0A=
				if ( this[0].nodeType =3D=3D=3D 1 ) {=0A=
			    var attr =3D this[0].attributes, name;=0A=
					for ( var i =3D 0, l =3D attr.length; i < l; i++ ) {=0A=
						name =3D attr[i].name;=0A=
=0A=
						if ( name.indexOf( "data-" ) =3D=3D=3D 0 ) {=0A=
							name =3D jQuery.camelCase( name.substring(5) );=0A=
=0A=
							dataAttr( this[0], name, data[ name ] );=0A=
						}=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			return data;=0A=
=0A=
		} else if ( typeof key =3D=3D=3D "object" ) {=0A=
			return this.each(function() {=0A=
				jQuery.data( this, key );=0A=
			});=0A=
		}=0A=
=0A=
		var parts =3D key.split(".");=0A=
		parts[1] =3D parts[1] ? "." + parts[1] : "";=0A=
=0A=
		if ( value =3D=3D=3D undefined ) {=0A=
			data =3D this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);=0A=
=0A=
			// Try to fetch any internally stored data first=0A=
			if ( data =3D=3D=3D undefined && this.length ) {=0A=
				data =3D jQuery.data( this[0], key );=0A=
				data =3D dataAttr( this[0], key, data );=0A=
			}=0A=
=0A=
			return data =3D=3D=3D undefined && parts[1] ?=0A=
				this.data( parts[0] ) :=0A=
				data;=0A=
=0A=
		} else {=0A=
			return this.each(function() {=0A=
				var $this =3D jQuery( this ),=0A=
					args =3D [ parts[0], value ];=0A=
=0A=
				$this.triggerHandler( "setData" + parts[1] + "!", args );=0A=
				jQuery.data( this, key, value );=0A=
				$this.triggerHandler( "changeData" + parts[1] + "!", args );=0A=
			});=0A=
		}=0A=
	},=0A=
=0A=
	removeData: function( key ) {=0A=
		return this.each(function() {=0A=
			jQuery.removeData( this, key );=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
function dataAttr( elem, key, data ) {=0A=
	// If nothing was found internally, try to fetch any=0A=
	// data from the HTML5 data-* attribute=0A=
	if ( data =3D=3D=3D undefined && elem.nodeType =3D=3D=3D 1 ) {=0A=
		var name =3D "data-" + key.replace( rmultiDash, "$1-$2" =
).toLowerCase();=0A=
=0A=
		data =3D elem.getAttribute( name );=0A=
=0A=
		if ( typeof data =3D=3D=3D "string" ) {=0A=
			try {=0A=
				data =3D data =3D=3D=3D "true" ? true :=0A=
				data =3D=3D=3D "false" ? false :=0A=
				data =3D=3D=3D "null" ? null :=0A=
				!jQuery.isNaN( data ) ? parseFloat( data ) :=0A=
					rbrace.test( data ) ? jQuery.parseJSON( data ) :=0A=
					data;=0A=
			} catch( e ) {}=0A=
=0A=
			// Make sure we set the data so it isn't changed later=0A=
			jQuery.data( elem, key, data );=0A=
=0A=
		} else {=0A=
			data =3D undefined;=0A=
		}=0A=
	}=0A=
=0A=
	return data;=0A=
}=0A=
=0A=
// TODO: This is a hack for 1.5 ONLY to allow objects with a single =
toJSON=0A=
// property to be considered empty objects; this property always exists =
in=0A=
// order to make sure JSON.stringify does not expose internal metadata=0A=
function isEmptyDataObject( obj ) {=0A=
	for ( var name in obj ) {=0A=
		if ( name !=3D=3D "toJSON" ) {=0A=
			return false;=0A=
		}=0A=
	}=0A=
=0A=
	return true;=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
function handleQueueMarkDefer( elem, type, src ) {=0A=
	var deferDataKey =3D type + "defer",=0A=
		queueDataKey =3D type + "queue",=0A=
		markDataKey =3D type + "mark",=0A=
		defer =3D jQuery.data( elem, deferDataKey, undefined, true );=0A=
	if ( defer &&=0A=
		( src =3D=3D=3D "queue" || !jQuery.data( elem, queueDataKey, =
undefined, true ) ) &&=0A=
		( src =3D=3D=3D "mark" || !jQuery.data( elem, markDataKey, undefined, =
true ) ) ) {=0A=
		// Give room for hard-coded callbacks to fire first=0A=
		// and eventually mark/queue something else on the element=0A=
		setTimeout( function() {=0A=
			if ( !jQuery.data( elem, queueDataKey, undefined, true ) &&=0A=
				!jQuery.data( elem, markDataKey, undefined, true ) ) {=0A=
				jQuery.removeData( elem, deferDataKey, true );=0A=
				defer.resolve();=0A=
			}=0A=
		}, 0 );=0A=
	}=0A=
}=0A=
=0A=
jQuery.extend({=0A=
=0A=
	_mark: function( elem, type ) {=0A=
		if ( elem ) {=0A=
			type =3D (type || "fx") + "mark";=0A=
			jQuery.data( elem, type, (jQuery.data(elem,type,undefined,true) || 0) =
+ 1, true );=0A=
		}=0A=
	},=0A=
=0A=
	_unmark: function( force, elem, type ) {=0A=
		if ( force !=3D=3D true ) {=0A=
			type =3D elem;=0A=
			elem =3D force;=0A=
			force =3D false;=0A=
		}=0A=
		if ( elem ) {=0A=
			type =3D type || "fx";=0A=
			var key =3D type + "mark",=0A=
				count =3D force ? 0 : ( (jQuery.data( elem, key, undefined, true) || =
1 ) - 1 );=0A=
			if ( count ) {=0A=
				jQuery.data( elem, key, count, true );=0A=
			} else {=0A=
				jQuery.removeData( elem, key, true );=0A=
				handleQueueMarkDefer( elem, type, "mark" );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	queue: function( elem, type, data ) {=0A=
		if ( elem ) {=0A=
			type =3D (type || "fx") + "queue";=0A=
			var q =3D jQuery.data( elem, type, undefined, true );=0A=
			// Speed up dequeue by getting out quickly if this is just a lookup=0A=
			if ( data ) {=0A=
				if ( !q || jQuery.isArray(data) ) {=0A=
					q =3D jQuery.data( elem, type, jQuery.makeArray(data), true );=0A=
				} else {=0A=
					q.push( data );=0A=
				}=0A=
			}=0A=
			return q || [];=0A=
		}=0A=
	},=0A=
=0A=
	dequeue: function( elem, type ) {=0A=
		type =3D type || "fx";=0A=
=0A=
		var queue =3D jQuery.queue( elem, type ),=0A=
			fn =3D queue.shift(),=0A=
			defer;=0A=
=0A=
		// If the fx queue is dequeued, always remove the progress sentinel=0A=
		if ( fn =3D=3D=3D "inprogress" ) {=0A=
			fn =3D queue.shift();=0A=
		}=0A=
=0A=
		if ( fn ) {=0A=
			// Add a progress sentinel to prevent the fx queue from being=0A=
			// automatically dequeued=0A=
			if ( type =3D=3D=3D "fx" ) {=0A=
				queue.unshift("inprogress");=0A=
			}=0A=
=0A=
			fn.call(elem, function() {=0A=
				jQuery.dequeue(elem, type);=0A=
			});=0A=
		}=0A=
=0A=
		if ( !queue.length ) {=0A=
			jQuery.removeData( elem, type + "queue", true );=0A=
			handleQueueMarkDefer( elem, type, "queue" );=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
jQuery.fn.extend({=0A=
	queue: function( type, data ) {=0A=
		if ( typeof type !=3D=3D "string" ) {=0A=
			data =3D type;=0A=
			type =3D "fx";=0A=
		}=0A=
=0A=
		if ( data =3D=3D=3D undefined ) {=0A=
			return jQuery.queue( this[0], type );=0A=
		}=0A=
		return this.each(function() {=0A=
			var queue =3D jQuery.queue( this, type, data );=0A=
=0A=
			if ( type =3D=3D=3D "fx" && queue[0] !=3D=3D "inprogress" ) {=0A=
				jQuery.dequeue( this, type );=0A=
			}=0A=
		});=0A=
	},=0A=
	dequeue: function( type ) {=0A=
		return this.each(function() {=0A=
			jQuery.dequeue( this, type );=0A=
		});=0A=
	},=0A=
	// Based off of the plugin by Clint Helfers, with permission.=0A=
	// http://blindsignals.com/index.php/2009/07/jquery-delay/=0A=
	delay: function( time, type ) {=0A=
		time =3D jQuery.fx ? jQuery.fx.speeds[time] || time : time;=0A=
		type =3D type || "fx";=0A=
=0A=
		return this.queue( type, function() {=0A=
			var elem =3D this;=0A=
			setTimeout(function() {=0A=
				jQuery.dequeue( elem, type );=0A=
			}, time );=0A=
		});=0A=
	},=0A=
	clearQueue: function( type ) {=0A=
		return this.queue( type || "fx", [] );=0A=
	},=0A=
	// Get a promise resolved when queues of a certain type=0A=
	// are emptied (fx is the type by default)=0A=
	promise: function( type, object ) {=0A=
		if ( typeof type !=3D=3D "string" ) {=0A=
			object =3D type;=0A=
			type =3D undefined;=0A=
		}=0A=
		type =3D type || "fx";=0A=
		var defer =3D jQuery.Deferred(),=0A=
			elements =3D this,=0A=
			i =3D elements.length,=0A=
			count =3D 1,=0A=
			deferDataKey =3D type + "defer",=0A=
			queueDataKey =3D type + "queue",=0A=
			markDataKey =3D type + "mark",=0A=
			tmp;=0A=
		function resolve() {=0A=
			if ( !( --count ) ) {=0A=
				defer.resolveWith( elements, [ elements ] );=0A=
			}=0A=
		}=0A=
		while( i-- ) {=0A=
			if (( tmp =3D jQuery.data( elements[ i ], deferDataKey, undefined, =
true ) ||=0A=
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||=0A=
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&=0A=
					jQuery.data( elements[ i ], deferDataKey, jQuery._Deferred(), true =
) )) {=0A=
				count++;=0A=
				tmp.done( resolve );=0A=
			}=0A=
		}=0A=
		resolve();=0A=
		return defer.promise();=0A=
	}=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
var rclass =3D /[\n\t\r]/g,=0A=
	rspace =3D /\s+/,=0A=
	rreturn =3D /\r/g,=0A=
	rtype =3D /^(?:button|input)$/i,=0A=
	rfocusable =3D /^(?:button|input|object|select|textarea)$/i,=0A=
	rclickable =3D /^a(?:rea)?$/i,=0A=
	rboolean =3D =
/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop=
|multiple|open|readonly|required|scoped|selected)$/i,=0A=
	rinvalidChar =3D /\:|^on/,=0A=
	formHook, boolHook;=0A=
=0A=
jQuery.fn.extend({=0A=
	attr: function( name, value ) {=0A=
		return jQuery.access( this, name, value, true, jQuery.attr );=0A=
	},=0A=
=0A=
	removeAttr: function( name ) {=0A=
		return this.each(function() {=0A=
			jQuery.removeAttr( this, name );=0A=
		});=0A=
	},=0A=
	=0A=
	prop: function( name, value ) {=0A=
		return jQuery.access( this, name, value, true, jQuery.prop );=0A=
	},=0A=
	=0A=
	removeProp: function( name ) {=0A=
		name =3D jQuery.propFix[ name ] || name;=0A=
		return this.each(function() {=0A=
			// try/catch handles cases where IE balks (such as removing a =
property on window)=0A=
			try {=0A=
				this[ name ] =3D undefined;=0A=
				delete this[ name ];=0A=
			} catch( e ) {}=0A=
		});=0A=
	},=0A=
=0A=
	addClass: function( value ) {=0A=
		var classNames, i, l, elem,=0A=
			setClass, c, cl;=0A=
=0A=
		if ( jQuery.isFunction( value ) ) {=0A=
			return this.each(function( j ) {=0A=
				jQuery( this ).addClass( value.call(this, j, this.className) );=0A=
			});=0A=
		}=0A=
=0A=
		if ( value && typeof value =3D=3D=3D "string" ) {=0A=
			classNames =3D value.split( rspace );=0A=
=0A=
			for ( i =3D 0, l =3D this.length; i < l; i++ ) {=0A=
				elem =3D this[ i ];=0A=
=0A=
				if ( elem.nodeType =3D=3D=3D 1 ) {=0A=
					if ( !elem.className && classNames.length =3D=3D=3D 1 ) {=0A=
						elem.className =3D value;=0A=
=0A=
					} else {=0A=
						setClass =3D " " + elem.className + " ";=0A=
=0A=
						for ( c =3D 0, cl =3D classNames.length; c < cl; c++ ) {=0A=
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {=0A=
								setClass +=3D classNames[ c ] + " ";=0A=
							}=0A=
						}=0A=
						elem.className =3D jQuery.trim( setClass );=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	removeClass: function( value ) {=0A=
		var classNames, i, l, elem, className, c, cl;=0A=
=0A=
		if ( jQuery.isFunction( value ) ) {=0A=
			return this.each(function( j ) {=0A=
				jQuery( this ).removeClass( value.call(this, j, this.className) );=0A=
			});=0A=
		}=0A=
=0A=
		if ( (value && typeof value =3D=3D=3D "string") || value =3D=3D=3D =
undefined ) {=0A=
			classNames =3D (value || "").split( rspace );=0A=
=0A=
			for ( i =3D 0, l =3D this.length; i < l; i++ ) {=0A=
				elem =3D this[ i ];=0A=
=0A=
				if ( elem.nodeType =3D=3D=3D 1 && elem.className ) {=0A=
					if ( value ) {=0A=
						className =3D (" " + elem.className + " ").replace( rclass, " " );=0A=
						for ( c =3D 0, cl =3D classNames.length; c < cl; c++ ) {=0A=
							className =3D className.replace(" " + classNames[ c ] + " ", " ");=0A=
						}=0A=
						elem.className =3D jQuery.trim( className );=0A=
=0A=
					} else {=0A=
						elem.className =3D "";=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	toggleClass: function( value, stateVal ) {=0A=
		var type =3D typeof value,=0A=
			isBool =3D typeof stateVal =3D=3D=3D "boolean";=0A=
=0A=
		if ( jQuery.isFunction( value ) ) {=0A=
			return this.each(function( i ) {=0A=
				jQuery( this ).toggleClass( value.call(this, i, this.className, =
stateVal), stateVal );=0A=
			});=0A=
		}=0A=
=0A=
		return this.each(function() {=0A=
			if ( type =3D=3D=3D "string" ) {=0A=
				// toggle individual class names=0A=
				var className,=0A=
					i =3D 0,=0A=
					self =3D jQuery( this ),=0A=
					state =3D stateVal,=0A=
					classNames =3D value.split( rspace );=0A=
=0A=
				while ( (className =3D classNames[ i++ ]) ) {=0A=
					// check each className given, space seperated list=0A=
					state =3D isBool ? state : !self.hasClass( className );=0A=
					self[ state ? "addClass" : "removeClass" ]( className );=0A=
				}=0A=
=0A=
			} else if ( type =3D=3D=3D "undefined" || type =3D=3D=3D "boolean" ) {=0A=
				if ( this.className ) {=0A=
					// store className if set=0A=
					jQuery._data( this, "__className__", this.className );=0A=
				}=0A=
=0A=
				// toggle whole className=0A=
				this.className =3D this.className || value =3D=3D=3D false ? "" : =
jQuery._data( this, "__className__" ) || "";=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	hasClass: function( selector ) {=0A=
		var className =3D " " + selector + " ";=0A=
		for ( var i =3D 0, l =3D this.length; i < l; i++ ) {=0A=
			if ( (" " + this[i].className + " ").replace(rclass, " ").indexOf( =
className ) > -1 ) {=0A=
				return true;=0A=
			}=0A=
		}=0A=
=0A=
		return false;=0A=
	},=0A=
=0A=
	val: function( value ) {=0A=
		var hooks, ret,=0A=
			elem =3D this[0];=0A=
		=0A=
		if ( !arguments.length ) {=0A=
			if ( elem ) {=0A=
				hooks =3D jQuery.valHooks[ elem.nodeName.toLowerCase() ] || =
jQuery.valHooks[ elem.type ];=0A=
=0A=
				if ( hooks && "get" in hooks && (ret =3D hooks.get( elem, "value" )) =
!=3D=3D undefined ) {=0A=
					return ret;=0A=
				}=0A=
=0A=
				ret =3D elem.value;=0A=
=0A=
				return typeof ret =3D=3D=3D "string" ? =0A=
					// handle most common string cases=0A=
					ret.replace(rreturn, "") : =0A=
					// handle cases where value is null/undef or number=0A=
					ret =3D=3D null ? "" : ret;=0A=
			}=0A=
=0A=
			return undefined;=0A=
		}=0A=
=0A=
		var isFunction =3D jQuery.isFunction( value );=0A=
=0A=
		return this.each(function( i ) {=0A=
			var self =3D jQuery(this), val;=0A=
=0A=
			if ( this.nodeType !=3D=3D 1 ) {=0A=
				return;=0A=
			}=0A=
=0A=
			if ( isFunction ) {=0A=
				val =3D value.call( this, i, self.val() );=0A=
			} else {=0A=
				val =3D value;=0A=
			}=0A=
=0A=
			// Treat null/undefined as ""; convert numbers to string=0A=
			if ( val =3D=3D null ) {=0A=
				val =3D "";=0A=
			} else if ( typeof val =3D=3D=3D "number" ) {=0A=
				val +=3D "";=0A=
			} else if ( jQuery.isArray( val ) ) {=0A=
				val =3D jQuery.map(val, function ( value ) {=0A=
					return value =3D=3D null ? "" : value + "";=0A=
				});=0A=
			}=0A=
=0A=
			hooks =3D jQuery.valHooks[ this.nodeName.toLowerCase() ] || =
jQuery.valHooks[ this.type ];=0A=
=0A=
			// If set returns undefined, fall back to normal setting=0A=
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) =
=3D=3D=3D undefined ) {=0A=
				this.value =3D val;=0A=
			}=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
jQuery.extend({=0A=
	valHooks: {=0A=
		option: {=0A=
			get: function( elem ) {=0A=
				// attributes.value is undefined in Blackberry 4.7 but=0A=
				// uses .value. See #6932=0A=
				var val =3D elem.attributes.value;=0A=
				return !val || val.specified ? elem.value : elem.text;=0A=
			}=0A=
		},=0A=
		select: {=0A=
			get: function( elem ) {=0A=
				var value,=0A=
					index =3D elem.selectedIndex,=0A=
					values =3D [],=0A=
					options =3D elem.options,=0A=
					one =3D elem.type =3D=3D=3D "select-one";=0A=
=0A=
				// Nothing was selected=0A=
				if ( index < 0 ) {=0A=
					return null;=0A=
				}=0A=
=0A=
				// Loop through all the selected options=0A=
				for ( var i =3D one ? index : 0, max =3D one ? index + 1 : =
options.length; i < max; i++ ) {=0A=
					var option =3D options[ i ];=0A=
=0A=
					// Don't return options that are disabled or in a disabled optgroup=0A=
					if ( option.selected && (jQuery.support.optDisabled ? =
!option.disabled : option.getAttribute("disabled") =3D=3D=3D null) &&=0A=
							(!option.parentNode.disabled || !jQuery.nodeName( =
option.parentNode, "optgroup" )) ) {=0A=
=0A=
						// Get the specific value for the option=0A=
						value =3D jQuery( option ).val();=0A=
=0A=
						// We don't need an array for one selects=0A=
						if ( one ) {=0A=
							return value;=0A=
						}=0A=
=0A=
						// Multi-Selects return an array=0A=
						values.push( value );=0A=
					}=0A=
				}=0A=
=0A=
				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()=0A=
				if ( one && !values.length && options.length ) {=0A=
					return jQuery( options[ index ] ).val();=0A=
				}=0A=
=0A=
				return values;=0A=
			},=0A=
=0A=
			set: function( elem, value ) {=0A=
				var values =3D jQuery.makeArray( value );=0A=
=0A=
				jQuery(elem).find("option").each(function() {=0A=
					this.selected =3D jQuery.inArray( jQuery(this).val(), values ) >=3D =
0;=0A=
				});=0A=
=0A=
				if ( !values.length ) {=0A=
					elem.selectedIndex =3D -1;=0A=
				}=0A=
				return values;=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	attrFn: {=0A=
		val: true,=0A=
		css: true,=0A=
		html: true,=0A=
		text: true,=0A=
		data: true,=0A=
		width: true,=0A=
		height: true,=0A=
		offset: true=0A=
	},=0A=
	=0A=
	attrFix: {=0A=
		// Always normalize to ensure hook usage=0A=
		tabindex: "tabIndex"=0A=
	},=0A=
	=0A=
	attr: function( elem, name, value, pass ) {=0A=
		var nType =3D elem.nodeType;=0A=
		=0A=
		// don't get/set attributes on text, comment and attribute nodes=0A=
		if ( !elem || nType =3D=3D=3D 3 || nType =3D=3D=3D 8 || nType =
=3D=3D=3D 2 ) {=0A=
			return undefined;=0A=
		}=0A=
=0A=
		if ( pass && name in jQuery.attrFn ) {=0A=
			return jQuery( elem )[ name ]( value );=0A=
		}=0A=
=0A=
		// Fallback to prop when attributes are not supported=0A=
		if ( !("getAttribute" in elem) ) {=0A=
			return jQuery.prop( elem, name, value );=0A=
		}=0A=
=0A=
		var ret, hooks,=0A=
			notxml =3D nType !=3D=3D 1 || !jQuery.isXMLDoc( elem );=0A=
=0A=
		// Normalize the name if needed=0A=
		if ( notxml ) {=0A=
			name =3D jQuery.attrFix[ name ] || name;=0A=
=0A=
			hooks =3D jQuery.attrHooks[ name ];=0A=
=0A=
			if ( !hooks ) {=0A=
				// Use boolHook for boolean attributes=0A=
				if ( rboolean.test( name ) ) {=0A=
=0A=
					hooks =3D boolHook;=0A=
=0A=
				// Use formHook for forms and if the name contains certain characters=0A=
				} else if ( formHook && name !=3D=3D "className" &&=0A=
					(jQuery.nodeName( elem, "form" ) || rinvalidChar.test( name )) ) {=0A=
=0A=
					hooks =3D formHook;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		if ( value !=3D=3D undefined ) {=0A=
=0A=
			if ( value =3D=3D=3D null ) {=0A=
				jQuery.removeAttr( elem, name );=0A=
				return undefined;=0A=
=0A=
			} else if ( hooks && "set" in hooks && notxml && (ret =3D hooks.set( =
elem, value, name )) !=3D=3D undefined ) {=0A=
				return ret;=0A=
=0A=
			} else {=0A=
				elem.setAttribute( name, "" + value );=0A=
				return value;=0A=
			}=0A=
=0A=
		} else if ( hooks && "get" in hooks && notxml && (ret =3D hooks.get( =
elem, name )) !=3D=3D null ) {=0A=
			return ret;=0A=
=0A=
		} else {=0A=
=0A=
			ret =3D elem.getAttribute( name );=0A=
=0A=
			// Non-existent attributes return null, we normalize to undefined=0A=
			return ret =3D=3D=3D null ?=0A=
				undefined :=0A=
				ret;=0A=
		}=0A=
	},=0A=
=0A=
	removeAttr: function( elem, name ) {=0A=
		var propName;=0A=
		if ( elem.nodeType =3D=3D=3D 1 ) {=0A=
			name =3D jQuery.attrFix[ name ] || name;=0A=
		=0A=
			if ( jQuery.support.getSetAttribute ) {=0A=
				// Use removeAttribute in browsers that support it=0A=
				elem.removeAttribute( name );=0A=
			} else {=0A=
				jQuery.attr( elem, name, "" );=0A=
				elem.removeAttributeNode( elem.getAttributeNode( name ) );=0A=
			}=0A=
=0A=
			// Set corresponding property to false for boolean attributes=0A=
			if ( rboolean.test( name ) && (propName =3D jQuery.propFix[ name ] || =
name) in elem ) {=0A=
				elem[ propName ] =3D false;=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	attrHooks: {=0A=
		type: {=0A=
			set: function( elem, value ) {=0A=
				// We can't allow the type property to be changed (since it causes =
problems in IE)=0A=
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {=0A=
					jQuery.error( "type property can't be changed" );=0A=
				} else if ( !jQuery.support.radioValue && value =3D=3D=3D "radio" && =
jQuery.nodeName(elem, "input") ) {=0A=
					// Setting the type on a radio button after the value resets the =
value in IE6-9=0A=
					// Reset value to it's default in case type is set after value=0A=
					// This is for element creation=0A=
					var val =3D elem.value;=0A=
					elem.setAttribute( "type", value );=0A=
					if ( val ) {=0A=
						elem.value =3D val;=0A=
					}=0A=
					return value;=0A=
				}=0A=
			}=0A=
		},=0A=
		tabIndex: {=0A=
			get: function( elem ) {=0A=
				// elem.tabIndex doesn't always return the correct value when it =
hasn't been explicitly set=0A=
				// =
http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabi=
ndex-values-with-javascript/=0A=
				var attributeNode =3D elem.getAttributeNode("tabIndex");=0A=
=0A=
				return attributeNode && attributeNode.specified ?=0A=
					parseInt( attributeNode.value, 10 ) :=0A=
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName =
) && elem.href ?=0A=
						0 :=0A=
						undefined;=0A=
			}=0A=
		},=0A=
		// Use the value property for back compat=0A=
		// Use the formHook for button elements in IE6/7 (#1954)=0A=
		value: {=0A=
			get: function( elem, name ) {=0A=
				if ( formHook && jQuery.nodeName( elem, "button" ) ) {=0A=
					return formHook.get( elem, name );=0A=
				}=0A=
				return name in elem ?=0A=
					elem.value :=0A=
					null;=0A=
			},=0A=
			set: function( elem, value, name ) {=0A=
				if ( formHook && jQuery.nodeName( elem, "button" ) ) {=0A=
					return formHook.set( elem, value, name );=0A=
				}=0A=
				// Does not return so that setAttribute is also used=0A=
				elem.value =3D value;=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	propFix: {=0A=
		tabindex: "tabIndex",=0A=
		readonly: "readOnly",=0A=
		"for": "htmlFor",=0A=
		"class": "className",=0A=
		maxlength: "maxLength",=0A=
		cellspacing: "cellSpacing",=0A=
		cellpadding: "cellPadding",=0A=
		rowspan: "rowSpan",=0A=
		colspan: "colSpan",=0A=
		usemap: "useMap",=0A=
		frameborder: "frameBorder",=0A=
		contenteditable: "contentEditable"=0A=
	},=0A=
	=0A=
	prop: function( elem, name, value ) {=0A=
		var nType =3D elem.nodeType;=0A=
=0A=
		// don't get/set properties on text, comment and attribute nodes=0A=
		if ( !elem || nType =3D=3D=3D 3 || nType =3D=3D=3D 8 || nType =
=3D=3D=3D 2 ) {=0A=
			return undefined;=0A=
		}=0A=
=0A=
		var ret, hooks,=0A=
			notxml =3D nType !=3D=3D 1 || !jQuery.isXMLDoc( elem );=0A=
=0A=
		if ( notxml ) {=0A=
			// Fix name and attach hooks=0A=
			name =3D jQuery.propFix[ name ] || name;=0A=
			hooks =3D jQuery.propHooks[ name ];=0A=
		}=0A=
=0A=
		if ( value !=3D=3D undefined ) {=0A=
			if ( hooks && "set" in hooks && (ret =3D hooks.set( elem, value, name =
)) !=3D=3D undefined ) {=0A=
				return ret;=0A=
=0A=
			} else {=0A=
				return (elem[ name ] =3D value);=0A=
			}=0A=
=0A=
		} else {=0A=
			if ( hooks && "get" in hooks && (ret =3D hooks.get( elem, name )) =
!=3D=3D undefined ) {=0A=
				return ret;=0A=
=0A=
			} else {=0A=
				return elem[ name ];=0A=
			}=0A=
		}=0A=
	},=0A=
	=0A=
	propHooks: {}=0A=
});=0A=
=0A=
// Hook for boolean attributes=0A=
boolHook =3D {=0A=
	get: function( elem, name ) {=0A=
		// Align boolean attributes with corresponding properties=0A=
		return jQuery.prop( elem, name ) ?=0A=
			name.toLowerCase() :=0A=
			undefined;=0A=
	},=0A=
	set: function( elem, value, name ) {=0A=
		var propName;=0A=
		if ( value =3D=3D=3D false ) {=0A=
			// Remove boolean attributes when set to false=0A=
			jQuery.removeAttr( elem, name );=0A=
		} else {=0A=
			// value is true since we know at this point it's type boolean and =
not false=0A=
			// Set boolean attributes to the same name and set the DOM property=0A=
			propName =3D jQuery.propFix[ name ] || name;=0A=
			if ( propName in elem ) {=0A=
				// Only set the IDL specifically if it already exists on the element=0A=
				elem[ propName ] =3D true;=0A=
			}=0A=
=0A=
			elem.setAttribute( name, name.toLowerCase() );=0A=
		}=0A=
		return name;=0A=
	}=0A=
};=0A=
=0A=
// IE6/7 do not support getting/setting some attributes with =
get/setAttribute=0A=
if ( !jQuery.support.getSetAttribute ) {=0A=
=0A=
	// propFix is more comprehensive and contains all fixes=0A=
	jQuery.attrFix =3D jQuery.propFix;=0A=
	=0A=
	// Use this for any attribute on a form in IE6/7=0A=
	formHook =3D jQuery.attrHooks.name =3D jQuery.attrHooks.title =3D =
jQuery.valHooks.button =3D {=0A=
		get: function( elem, name ) {=0A=
			var ret;=0A=
			ret =3D elem.getAttributeNode( name );=0A=
			// Return undefined if nodeValue is empty string=0A=
			return ret && ret.nodeValue !=3D=3D "" ?=0A=
				ret.nodeValue :=0A=
				undefined;=0A=
		},=0A=
		set: function( elem, value, name ) {=0A=
			// Check form objects in IE (multiple bugs related)=0A=
			// Only use nodeValue if the attribute node exists on the form=0A=
			var ret =3D elem.getAttributeNode( name );=0A=
			if ( ret ) {=0A=
				ret.nodeValue =3D value;=0A=
				return value;=0A=
			}=0A=
		}=0A=
	};=0A=
=0A=
	// Set width and height to auto instead of 0 on empty string( Bug #8150 =
)=0A=
	// This is for removals=0A=
	jQuery.each([ "width", "height" ], function( i, name ) {=0A=
		jQuery.attrHooks[ name ] =3D jQuery.extend( jQuery.attrHooks[ name ], {=0A=
			set: function( elem, value ) {=0A=
				if ( value =3D=3D=3D "" ) {=0A=
					elem.setAttribute( name, "auto" );=0A=
					return value;=0A=
				}=0A=
			}=0A=
		});=0A=
	});=0A=
}=0A=
=0A=
=0A=
// Some attributes require a special call on IE=0A=
if ( !jQuery.support.hrefNormalized ) {=0A=
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {=0A=
		jQuery.attrHooks[ name ] =3D jQuery.extend( jQuery.attrHooks[ name ], {=0A=
			get: function( elem ) {=0A=
				var ret =3D elem.getAttribute( name, 2 );=0A=
				return ret =3D=3D=3D null ? undefined : ret;=0A=
			}=0A=
		});=0A=
	});=0A=
}=0A=
=0A=
if ( !jQuery.support.style ) {=0A=
	jQuery.attrHooks.style =3D {=0A=
		get: function( elem ) {=0A=
			// Return undefined in the case of empty string=0A=
			// Normalize to lowercase since IE uppercases css property names=0A=
			return elem.style.cssText.toLowerCase() || undefined;=0A=
		},=0A=
		set: function( elem, value ) {=0A=
			return (elem.style.cssText =3D "" + value);=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
// Safari mis-reports the default selected property of an option=0A=
// Accessing the parent's selectedIndex property fixes it=0A=
if ( !jQuery.support.optSelected ) {=0A=
	jQuery.propHooks.selected =3D jQuery.extend( jQuery.propHooks.selected, =
{=0A=
		get: function( elem ) {=0A=
			var parent =3D elem.parentNode;=0A=
=0A=
			if ( parent ) {=0A=
				parent.selectedIndex;=0A=
=0A=
				// Make sure that it also works with optgroups, see #5701=0A=
				if ( parent.parentNode ) {=0A=
					parent.parentNode.selectedIndex;=0A=
				}=0A=
			}=0A=
		}=0A=
	});=0A=
}=0A=
=0A=
// Radios and checkboxes getter/setter=0A=
if ( !jQuery.support.checkOn ) {=0A=
	jQuery.each([ "radio", "checkbox" ], function() {=0A=
		jQuery.valHooks[ this ] =3D {=0A=
			get: function( elem ) {=0A=
				// Handle the case where in Webkit "" is returned instead of "on" if =
a value isn't specified=0A=
				return elem.getAttribute("value") =3D=3D=3D null ? "on" : elem.value;=0A=
			}=0A=
		};=0A=
	});=0A=
}=0A=
jQuery.each([ "radio", "checkbox" ], function() {=0A=
	jQuery.valHooks[ this ] =3D jQuery.extend( jQuery.valHooks[ this ], {=0A=
		set: function( elem, value ) {=0A=
			if ( jQuery.isArray( value ) ) {=0A=
				return (elem.checked =3D jQuery.inArray( jQuery(elem).val(), value ) =
>=3D 0);=0A=
			}=0A=
		}=0A=
	});=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
var rnamespaces =3D /\.(.*)$/,=0A=
	rformElems =3D /^(?:textarea|input|select)$/i,=0A=
	rperiod =3D /\./g,=0A=
	rspaces =3D / /g,=0A=
	rescape =3D /[^\w\s.|`]/g,=0A=
	fcleanup =3D function( nm ) {=0A=
		return nm.replace(rescape, "\\$&");=0A=
	};=0A=
=0A=
/*=0A=
 * A number of helper functions used for managing events.=0A=
 * Many of the ideas behind this code originated from=0A=
 * Dean Edwards' addEvent library.=0A=
 */=0A=
jQuery.event =3D {=0A=
=0A=
	// Bind an event to an element=0A=
	// Original by Dean Edwards=0A=
	add: function( elem, types, handler, data ) {=0A=
		if ( elem.nodeType =3D=3D=3D 3 || elem.nodeType =3D=3D=3D 8 ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( handler =3D=3D=3D false ) {=0A=
			handler =3D returnFalse;=0A=
		} else if ( !handler ) {=0A=
			// Fixes bug #7229. Fix recommended by jdalton=0A=
			return;=0A=
		}=0A=
=0A=
		var handleObjIn, handleObj;=0A=
=0A=
		if ( handler.handler ) {=0A=
			handleObjIn =3D handler;=0A=
			handler =3D handleObjIn.handler;=0A=
		}=0A=
=0A=
		// Make sure that the function being executed has a unique ID=0A=
		if ( !handler.guid ) {=0A=
			handler.guid =3D jQuery.guid++;=0A=
		}=0A=
=0A=
		// Init the element's event structure=0A=
		var elemData =3D jQuery._data( elem );=0A=
=0A=
		// If no elemData is found then we must be trying to bind to one of the=0A=
		// banned noData elements=0A=
		if ( !elemData ) {=0A=
			return;=0A=
		}=0A=
=0A=
		var events =3D elemData.events,=0A=
			eventHandle =3D elemData.handle;=0A=
=0A=
		if ( !events ) {=0A=
			elemData.events =3D events =3D {};=0A=
		}=0A=
=0A=
		if ( !eventHandle ) {=0A=
			elemData.handle =3D eventHandle =3D function( e ) {=0A=
				// Discard the second event of a jQuery.event.trigger() and=0A=
				// when an event is called after a page has unloaded=0A=
				return typeof jQuery !=3D=3D "undefined" && (!e || =
jQuery.event.triggered !=3D=3D e.type) ?=0A=
					jQuery.event.handle.apply( eventHandle.elem, arguments ) :=0A=
					undefined;=0A=
			};=0A=
		}=0A=
=0A=
		// Add elem as a property of the handle function=0A=
		// This is to prevent a memory leak with non-native events in IE.=0A=
		eventHandle.elem =3D elem;=0A=
=0A=
		// Handle multiple events separated by a space=0A=
		// jQuery(...).bind("mouseover mouseout", fn);=0A=
		types =3D types.split(" ");=0A=
=0A=
		var type, i =3D 0, namespaces;=0A=
=0A=
		while ( (type =3D types[ i++ ]) ) {=0A=
			handleObj =3D handleObjIn ?=0A=
				jQuery.extend({}, handleObjIn) :=0A=
				{ handler: handler, data: data };=0A=
=0A=
			// Namespaced event handlers=0A=
			if ( type.indexOf(".") > -1 ) {=0A=
				namespaces =3D type.split(".");=0A=
				type =3D namespaces.shift();=0A=
				handleObj.namespace =3D namespaces.slice(0).sort().join(".");=0A=
=0A=
			} else {=0A=
				namespaces =3D [];=0A=
				handleObj.namespace =3D "";=0A=
			}=0A=
=0A=
			handleObj.type =3D type;=0A=
			if ( !handleObj.guid ) {=0A=
				handleObj.guid =3D handler.guid;=0A=
			}=0A=
=0A=
			// Get the current list of functions bound to this event=0A=
			var handlers =3D events[ type ],=0A=
				special =3D jQuery.event.special[ type ] || {};=0A=
=0A=
			// Init the event handler queue=0A=
			if ( !handlers ) {=0A=
				handlers =3D events[ type ] =3D [];=0A=
=0A=
				// Check for a special event handler=0A=
				// Only use addEventListener/attachEvent if the special=0A=
				// events handler returns false=0A=
				if ( !special.setup || special.setup.call( elem, data, namespaces, =
eventHandle ) =3D=3D=3D false ) {=0A=
					// Bind the global event handler to the element=0A=
					if ( elem.addEventListener ) {=0A=
						elem.addEventListener( type, eventHandle, false );=0A=
=0A=
					} else if ( elem.attachEvent ) {=0A=
						elem.attachEvent( "on" + type, eventHandle );=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			if ( special.add ) {=0A=
				special.add.call( elem, handleObj );=0A=
=0A=
				if ( !handleObj.handler.guid ) {=0A=
					handleObj.handler.guid =3D handler.guid;=0A=
				}=0A=
			}=0A=
=0A=
			// Add the function to the element's handler list=0A=
			handlers.push( handleObj );=0A=
=0A=
			// Keep track of which events have been used, for event optimization=0A=
			jQuery.event.global[ type ] =3D true;=0A=
		}=0A=
=0A=
		// Nullify elem to prevent memory leaks in IE=0A=
		elem =3D null;=0A=
	},=0A=
=0A=
	global: {},=0A=
=0A=
	// Detach an event or set of events from an element=0A=
	remove: function( elem, types, handler, pos ) {=0A=
		// don't do events on text and comment nodes=0A=
		if ( elem.nodeType =3D=3D=3D 3 || elem.nodeType =3D=3D=3D 8 ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( handler =3D=3D=3D false ) {=0A=
			handler =3D returnFalse;=0A=
		}=0A=
=0A=
		var ret, type, fn, j, i =3D 0, all, namespaces, namespace, special, =
eventType, handleObj, origType,=0A=
			elemData =3D jQuery.hasData( elem ) && jQuery._data( elem ),=0A=
			events =3D elemData && elemData.events;=0A=
=0A=
		if ( !elemData || !events ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// types is actually an event object here=0A=
		if ( types && types.type ) {=0A=
			handler =3D types.handler;=0A=
			types =3D types.type;=0A=
		}=0A=
=0A=
		// Unbind all events for the element=0A=
		if ( !types || typeof types =3D=3D=3D "string" && types.charAt(0) =
=3D=3D=3D "." ) {=0A=
			types =3D types || "";=0A=
=0A=
			for ( type in events ) {=0A=
				jQuery.event.remove( elem, type + types );=0A=
			}=0A=
=0A=
			return;=0A=
		}=0A=
=0A=
		// Handle multiple events separated by a space=0A=
		// jQuery(...).unbind("mouseover mouseout", fn);=0A=
		types =3D types.split(" ");=0A=
=0A=
		while ( (type =3D types[ i++ ]) ) {=0A=
			origType =3D type;=0A=
			handleObj =3D null;=0A=
			all =3D type.indexOf(".") < 0;=0A=
			namespaces =3D [];=0A=
=0A=
			if ( !all ) {=0A=
				// Namespaced event handlers=0A=
				namespaces =3D type.split(".");=0A=
				type =3D namespaces.shift();=0A=
=0A=
				namespace =3D new RegExp("(^|\\.)" +=0A=
					jQuery.map( namespaces.slice(0).sort(), fcleanup =
).join("\\.(?:.*\\.)?") + "(\\.|$)");=0A=
			}=0A=
=0A=
			eventType =3D events[ type ];=0A=
=0A=
			if ( !eventType ) {=0A=
				continue;=0A=
			}=0A=
=0A=
			if ( !handler ) {=0A=
				for ( j =3D 0; j < eventType.length; j++ ) {=0A=
					handleObj =3D eventType[ j ];=0A=
=0A=
					if ( all || namespace.test( handleObj.namespace ) ) {=0A=
						jQuery.event.remove( elem, origType, handleObj.handler, j );=0A=
						eventType.splice( j--, 1 );=0A=
					}=0A=
				}=0A=
=0A=
				continue;=0A=
			}=0A=
=0A=
			special =3D jQuery.event.special[ type ] || {};=0A=
=0A=
			for ( j =3D pos || 0; j < eventType.length; j++ ) {=0A=
				handleObj =3D eventType[ j ];=0A=
=0A=
				if ( handler.guid =3D=3D=3D handleObj.guid ) {=0A=
					// remove the given handler for the given type=0A=
					if ( all || namespace.test( handleObj.namespace ) ) {=0A=
						if ( pos =3D=3D null ) {=0A=
							eventType.splice( j--, 1 );=0A=
						}=0A=
=0A=
						if ( special.remove ) {=0A=
							special.remove.call( elem, handleObj );=0A=
						}=0A=
					}=0A=
=0A=
					if ( pos !=3D null ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			// remove generic event handler if no more handlers exist=0A=
			if ( eventType.length =3D=3D=3D 0 || pos !=3D null && =
eventType.length =3D=3D=3D 1 ) {=0A=
				if ( !special.teardown || special.teardown.call( elem, namespaces ) =
=3D=3D=3D false ) {=0A=
					jQuery.removeEvent( elem, type, elemData.handle );=0A=
				}=0A=
=0A=
				ret =3D null;=0A=
				delete events[ type ];=0A=
			}=0A=
		}=0A=
=0A=
		// Remove the expando if it's no longer used=0A=
		if ( jQuery.isEmptyObject( events ) ) {=0A=
			var handle =3D elemData.handle;=0A=
			if ( handle ) {=0A=
				handle.elem =3D null;=0A=
			}=0A=
=0A=
			delete elemData.events;=0A=
			delete elemData.handle;=0A=
=0A=
			if ( jQuery.isEmptyObject( elemData ) ) {=0A=
				jQuery.removeData( elem, undefined, true );=0A=
			}=0A=
		}=0A=
	},=0A=
	=0A=
	// Events that are safe to short-circuit if no handlers are attached.=0A=
	// Native DOM events should not be added, they may have inline handlers.=0A=
	customEvent: {=0A=
		"getData": true,=0A=
		"setData": true,=0A=
		"changeData": true=0A=
	},=0A=
=0A=
	trigger: function( event, data, elem, onlyHandlers ) {=0A=
		// Event object or event type=0A=
		var type =3D event.type || event,=0A=
			namespaces =3D [],=0A=
			exclusive;=0A=
=0A=
		if ( type.indexOf("!") >=3D 0 ) {=0A=
			// Exclusive events trigger only for the exact event (no namespaces)=0A=
			type =3D type.slice(0, -1);=0A=
			exclusive =3D true;=0A=
		}=0A=
=0A=
		if ( type.indexOf(".") >=3D 0 ) {=0A=
			// Namespaced trigger; create a regexp to match event type in handle()=0A=
			namespaces =3D type.split(".");=0A=
			type =3D namespaces.shift();=0A=
			namespaces.sort();=0A=
		}=0A=
=0A=
		if ( (!elem || jQuery.event.customEvent[ type ]) && =
!jQuery.event.global[ type ] ) {=0A=
			// No jQuery handlers for this event type, and it can't have inline =
handlers=0A=
			return;=0A=
		}=0A=
=0A=
		// Caller can pass in an Event, Object, or just an event type string=0A=
		event =3D typeof event =3D=3D=3D "object" ?=0A=
			// jQuery.Event object=0A=
			event[ jQuery.expando ] ? event :=0A=
			// Object literal=0A=
			new jQuery.Event( type, event ) :=0A=
			// Just the event type (string)=0A=
			new jQuery.Event( type );=0A=
=0A=
		event.type =3D type;=0A=
		event.exclusive =3D exclusive;=0A=
		event.namespace =3D namespaces.join(".");=0A=
		event.namespace_re =3D new RegExp("(^|\\.)" + =
namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");=0A=
		=0A=
		// triggerHandler() and global events don't bubble or run the default =
action=0A=
		if ( onlyHandlers || !elem ) {=0A=
			event.preventDefault();=0A=
			event.stopPropagation();=0A=
		}=0A=
=0A=
		// Handle a global trigger=0A=
		if ( !elem ) {=0A=
			// TODO: Stop taunting the data cache; remove global events and =
always attach to document=0A=
			jQuery.each( jQuery.cache, function() {=0A=
				// internalKey variable is just used to make it easier to find=0A=
				// and potentially change this stuff later; currently it just=0A=
				// points to jQuery.expando=0A=
				var internalKey =3D jQuery.expando,=0A=
					internalCache =3D this[ internalKey ];=0A=
				if ( internalCache && internalCache.events && internalCache.events[ =
type ] ) {=0A=
					jQuery.event.trigger( event, data, internalCache.handle.elem );=0A=
				}=0A=
			});=0A=
			return;=0A=
		}=0A=
=0A=
		// Don't do events on text and comment nodes=0A=
		if ( elem.nodeType =3D=3D=3D 3 || elem.nodeType =3D=3D=3D 8 ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Clean up the event in case it is being reused=0A=
		event.result =3D undefined;=0A=
		event.target =3D elem;=0A=
=0A=
		// Clone any incoming data and prepend the event, creating the handler =
arg list=0A=
		data =3D data !=3D null ? jQuery.makeArray( data ) : [];=0A=
		data.unshift( event );=0A=
=0A=
		var cur =3D elem,=0A=
			// IE doesn't like method names with a colon (#3533, #8272)=0A=
			ontype =3D type.indexOf(":") < 0 ? "on" + type : "";=0A=
=0A=
		// Fire event on the current element, then bubble up the DOM tree=0A=
		do {=0A=
			var handle =3D jQuery._data( cur, "handle" );=0A=
=0A=
			event.currentTarget =3D cur;=0A=
			if ( handle ) {=0A=
				handle.apply( cur, data );=0A=
			}=0A=
=0A=
			// Trigger an inline bound script=0A=
			if ( ontype && jQuery.acceptData( cur ) && cur[ ontype ] && cur[ =
ontype ].apply( cur, data ) =3D=3D=3D false ) {=0A=
				event.result =3D false;=0A=
				event.preventDefault();=0A=
			}=0A=
=0A=
			// Bubble up to document, then to window=0A=
			cur =3D cur.parentNode || cur.ownerDocument || cur =3D=3D=3D =
event.target.ownerDocument && window;=0A=
		} while ( cur && !event.isPropagationStopped() );=0A=
=0A=
		// If nobody prevented the default action, do it now=0A=
		if ( !event.isDefaultPrevented() ) {=0A=
			var old,=0A=
				special =3D jQuery.event.special[ type ] || {};=0A=
=0A=
			if ( (!special._default || special._default.call( elem.ownerDocument, =
event ) =3D=3D=3D false) &&=0A=
				!(type =3D=3D=3D "click" && jQuery.nodeName( elem, "a" )) && =
jQuery.acceptData( elem ) ) {=0A=
=0A=
				// Call a native DOM method on the target with the same name name as =
the event.=0A=
				// Can't use an .isFunction)() check here because IE6/7 fails that =
test.=0A=
				// IE<9 dies on focus to hidden element (#1486), may want to revisit =
a try/catch.=0A=
				try {=0A=
					if ( ontype && elem[ type ] ) {=0A=
						// Don't re-trigger an onFOO event when we call its FOO() method=0A=
						old =3D elem[ ontype ];=0A=
=0A=
						if ( old ) {=0A=
							elem[ ontype ] =3D null;=0A=
						}=0A=
=0A=
						jQuery.event.triggered =3D type;=0A=
						elem[ type ]();=0A=
					}=0A=
				} catch ( ieError ) {}=0A=
=0A=
				if ( old ) {=0A=
					elem[ ontype ] =3D old;=0A=
				}=0A=
=0A=
				jQuery.event.triggered =3D undefined;=0A=
			}=0A=
		}=0A=
		=0A=
		return event.result;=0A=
	},=0A=
=0A=
	handle: function( event ) {=0A=
		event =3D jQuery.event.fix( event || window.event );=0A=
		// Snapshot the handlers list since a called handler may add/remove =
events.=0A=
		var handlers =3D ((jQuery._data( this, "events" ) || {})[ event.type ] =
|| []).slice(0),=0A=
			run_all =3D !event.exclusive && !event.namespace,=0A=
			args =3D Array.prototype.slice.call( arguments, 0 );=0A=
=0A=
		// Use the fix-ed Event rather than the (read-only) native event=0A=
		args[0] =3D event;=0A=
		event.currentTarget =3D this;=0A=
=0A=
		for ( var j =3D 0, l =3D handlers.length; j < l; j++ ) {=0A=
			var handleObj =3D handlers[ j ];=0A=
=0A=
			// Triggered event must 1) be non-exclusive and have no namespace, or=0A=
			// 2) have namespace(s) a subset or equal to those in the bound event.=0A=
			if ( run_all || event.namespace_re.test( handleObj.namespace ) ) {=0A=
				// Pass in a reference to the handler function itself=0A=
				// So that we can later remove it=0A=
				event.handler =3D handleObj.handler;=0A=
				event.data =3D handleObj.data;=0A=
				event.handleObj =3D handleObj;=0A=
=0A=
				var ret =3D handleObj.handler.apply( this, args );=0A=
=0A=
				if ( ret !=3D=3D undefined ) {=0A=
					event.result =3D ret;=0A=
					if ( ret =3D=3D=3D false ) {=0A=
						event.preventDefault();=0A=
						event.stopPropagation();=0A=
					}=0A=
				}=0A=
=0A=
				if ( event.isImmediatePropagationStopped() ) {=0A=
					break;=0A=
				}=0A=
			}=0A=
		}=0A=
		return event.result;=0A=
	},=0A=
=0A=
	props: "altKey attrChange attrName bubbles button cancelable charCode =
clientX clientY ctrlKey currentTarget data detail eventPhase fromElement =
handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX =
pageY prevValue relatedNode relatedTarget screenX screenY shiftKey =
srcElement target toElement view wheelDelta which".split(" "),=0A=
=0A=
	fix: function( event ) {=0A=
		if ( event[ jQuery.expando ] ) {=0A=
			return event;=0A=
		}=0A=
=0A=
		// store a copy of the original event object=0A=
		// and "clone" to set read-only properties=0A=
		var originalEvent =3D event;=0A=
		event =3D jQuery.Event( originalEvent );=0A=
=0A=
		for ( var i =3D this.props.length, prop; i; ) {=0A=
			prop =3D this.props[ --i ];=0A=
			event[ prop ] =3D originalEvent[ prop ];=0A=
		}=0A=
=0A=
		// Fix target property, if necessary=0A=
		if ( !event.target ) {=0A=
			// Fixes #1925 where srcElement might not be defined either=0A=
			event.target =3D event.srcElement || document;=0A=
		}=0A=
=0A=
		// check if target is a textnode (safari)=0A=
		if ( event.target.nodeType =3D=3D=3D 3 ) {=0A=
			event.target =3D event.target.parentNode;=0A=
		}=0A=
=0A=
		// Add relatedTarget, if necessary=0A=
		if ( !event.relatedTarget && event.fromElement ) {=0A=
			event.relatedTarget =3D event.fromElement =3D=3D=3D event.target ? =
event.toElement : event.fromElement;=0A=
		}=0A=
=0A=
		// Calculate pageX/Y if missing and clientX/Y available=0A=
		if ( event.pageX =3D=3D null && event.clientX !=3D null ) {=0A=
			var eventDocument =3D event.target.ownerDocument || document,=0A=
				doc =3D eventDocument.documentElement,=0A=
				body =3D eventDocument.body;=0A=
=0A=
			event.pageX =3D event.clientX + (doc && doc.scrollLeft || body && =
body.scrollLeft || 0) - (doc && doc.clientLeft || body && =
body.clientLeft || 0);=0A=
			event.pageY =3D event.clientY + (doc && doc.scrollTop  || body && =
body.scrollTop  || 0) - (doc && doc.clientTop  || body && body.clientTop =
 || 0);=0A=
		}=0A=
=0A=
		// Add which for key events=0A=
		if ( event.which =3D=3D null && (event.charCode !=3D null || =
event.keyCode !=3D null) ) {=0A=
			event.which =3D event.charCode !=3D null ? event.charCode : =
event.keyCode;=0A=
		}=0A=
=0A=
		// Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for =
Macs)=0A=
		if ( !event.metaKey && event.ctrlKey ) {=0A=
			event.metaKey =3D event.ctrlKey;=0A=
		}=0A=
=0A=
		// Add which for click: 1 =3D=3D=3D left; 2 =3D=3D=3D middle; 3 =
=3D=3D=3D right=0A=
		// Note: button is not normalized, so don't use it=0A=
		if ( !event.which && event.button !=3D=3D undefined ) {=0A=
			event.which =3D (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( =
event.button & 4 ? 2 : 0 ) ));=0A=
		}=0A=
=0A=
		return event;=0A=
	},=0A=
=0A=
	// Deprecated, use jQuery.guid instead=0A=
	guid: 1E8,=0A=
=0A=
	// Deprecated, use jQuery.proxy instead=0A=
	proxy: jQuery.proxy,=0A=
=0A=
	special: {=0A=
		ready: {=0A=
			// Make sure the ready event is setup=0A=
			setup: jQuery.bindReady,=0A=
			teardown: jQuery.noop=0A=
		},=0A=
=0A=
		live: {=0A=
			add: function( handleObj ) {=0A=
				jQuery.event.add( this,=0A=
					liveConvert( handleObj.origType, handleObj.selector ),=0A=
					jQuery.extend({}, handleObj, {handler: liveHandler, guid: =
handleObj.handler.guid}) );=0A=
			},=0A=
=0A=
			remove: function( handleObj ) {=0A=
				jQuery.event.remove( this, liveConvert( handleObj.origType, =
handleObj.selector ), handleObj );=0A=
			}=0A=
		},=0A=
=0A=
		beforeunload: {=0A=
			setup: function( data, namespaces, eventHandle ) {=0A=
				// We only want to do this special case on windows=0A=
				if ( jQuery.isWindow( this ) ) {=0A=
					this.onbeforeunload =3D eventHandle;=0A=
				}=0A=
			},=0A=
=0A=
			teardown: function( namespaces, eventHandle ) {=0A=
				if ( this.onbeforeunload =3D=3D=3D eventHandle ) {=0A=
					this.onbeforeunload =3D null;=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
jQuery.removeEvent =3D document.removeEventListener ?=0A=
	function( elem, type, handle ) {=0A=
		if ( elem.removeEventListener ) {=0A=
			elem.removeEventListener( type, handle, false );=0A=
		}=0A=
	} :=0A=
	function( elem, type, handle ) {=0A=
		if ( elem.detachEvent ) {=0A=
			elem.detachEvent( "on" + type, handle );=0A=
		}=0A=
	};=0A=
=0A=
jQuery.Event =3D function( src, props ) {=0A=
	// Allow instantiation without the 'new' keyword=0A=
	if ( !this.preventDefault ) {=0A=
		return new jQuery.Event( src, props );=0A=
	}=0A=
=0A=
	// Event object=0A=
	if ( src && src.type ) {=0A=
		this.originalEvent =3D src;=0A=
		this.type =3D src.type;=0A=
=0A=
		// Events bubbling up the document may have been marked as prevented=0A=
		// by a handler lower down the tree; reflect the correct value.=0A=
		this.isDefaultPrevented =3D (src.defaultPrevented || src.returnValue =
=3D=3D=3D false ||=0A=
			src.getPreventDefault && src.getPreventDefault()) ? returnTrue : =
returnFalse;=0A=
=0A=
	// Event type=0A=
	} else {=0A=
		this.type =3D src;=0A=
	}=0A=
=0A=
	// Put explicitly provided properties onto the event object=0A=
	if ( props ) {=0A=
		jQuery.extend( this, props );=0A=
	}=0A=
=0A=
	// timeStamp is buggy for some events on Firefox(#3843)=0A=
	// So we won't rely on the native value=0A=
	this.timeStamp =3D jQuery.now();=0A=
=0A=
	// Mark it as fixed=0A=
	this[ jQuery.expando ] =3D true;=0A=
};=0A=
=0A=
function returnFalse() {=0A=
	return false;=0A=
}=0A=
function returnTrue() {=0A=
	return true;=0A=
}=0A=
=0A=
// jQuery.Event is based on DOM3 Events as specified by the ECMAScript =
Language Binding=0A=
// =
http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-bind=
ing.html=0A=
jQuery.Event.prototype =3D {=0A=
	preventDefault: function() {=0A=
		this.isDefaultPrevented =3D returnTrue;=0A=
=0A=
		var e =3D this.originalEvent;=0A=
		if ( !e ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// if preventDefault exists run it on the original event=0A=
		if ( e.preventDefault ) {=0A=
			e.preventDefault();=0A=
=0A=
		// otherwise set the returnValue property of the original event to =
false (IE)=0A=
		} else {=0A=
			e.returnValue =3D false;=0A=
		}=0A=
	},=0A=
	stopPropagation: function() {=0A=
		this.isPropagationStopped =3D returnTrue;=0A=
=0A=
		var e =3D this.originalEvent;=0A=
		if ( !e ) {=0A=
			return;=0A=
		}=0A=
		// if stopPropagation exists run it on the original event=0A=
		if ( e.stopPropagation ) {=0A=
			e.stopPropagation();=0A=
		}=0A=
		// otherwise set the cancelBubble property of the original event to =
true (IE)=0A=
		e.cancelBubble =3D true;=0A=
	},=0A=
	stopImmediatePropagation: function() {=0A=
		this.isImmediatePropagationStopped =3D returnTrue;=0A=
		this.stopPropagation();=0A=
	},=0A=
	isDefaultPrevented: returnFalse,=0A=
	isPropagationStopped: returnFalse,=0A=
	isImmediatePropagationStopped: returnFalse=0A=
};=0A=
=0A=
// Checks if an event happened on an element within another element=0A=
// Used in jQuery.event.special.mouseenter and mouseleave handlers=0A=
var withinElement =3D function( event ) {=0A=
=0A=
	// Check if mouse(over|out) are still within the same parent element=0A=
	var related =3D event.relatedTarget,=0A=
		inside =3D false,=0A=
		eventType =3D event.type;=0A=
=0A=
	event.type =3D event.data;=0A=
=0A=
	if ( related !=3D=3D this ) {=0A=
=0A=
		if ( related ) {=0A=
			inside =3D jQuery.contains( this, related );=0A=
		}=0A=
=0A=
		if ( !inside ) {=0A=
=0A=
			jQuery.event.handle.apply( this, arguments );=0A=
=0A=
			event.type =3D eventType;=0A=
		}=0A=
	}=0A=
},=0A=
=0A=
// In case of event delegation, we only need to rename the event.type,=0A=
// liveHandler will take care of the rest.=0A=
delegate =3D function( event ) {=0A=
	event.type =3D event.data;=0A=
	jQuery.event.handle.apply( this, arguments );=0A=
};=0A=
=0A=
// Create mouseenter and mouseleave events=0A=
jQuery.each({=0A=
	mouseenter: "mouseover",=0A=
	mouseleave: "mouseout"=0A=
}, function( orig, fix ) {=0A=
	jQuery.event.special[ orig ] =3D {=0A=
		setup: function( data ) {=0A=
			jQuery.event.add( this, fix, data && data.selector ? delegate : =
withinElement, orig );=0A=
		},=0A=
		teardown: function( data ) {=0A=
			jQuery.event.remove( this, fix, data && data.selector ? delegate : =
withinElement );=0A=
		}=0A=
	};=0A=
});=0A=
=0A=
// submit delegation=0A=
if ( !jQuery.support.submitBubbles ) {=0A=
=0A=
	jQuery.event.special.submit =3D {=0A=
		setup: function( data, namespaces ) {=0A=
			if ( !jQuery.nodeName( this, "form" ) ) {=0A=
				jQuery.event.add(this, "click.specialSubmit", function( e ) {=0A=
					var elem =3D e.target,=0A=
						type =3D elem.type;=0A=
=0A=
					if ( (type =3D=3D=3D "submit" || type =3D=3D=3D "image") && jQuery( =
elem ).closest("form").length ) {=0A=
						trigger( "submit", this, arguments );=0A=
					}=0A=
				});=0A=
=0A=
				jQuery.event.add(this, "keypress.specialSubmit", function( e ) {=0A=
					var elem =3D e.target,=0A=
						type =3D elem.type;=0A=
=0A=
					if ( (type =3D=3D=3D "text" || type =3D=3D=3D "password") && =
jQuery( elem ).closest("form").length && e.keyCode =3D=3D=3D 13 ) {=0A=
						trigger( "submit", this, arguments );=0A=
					}=0A=
				});=0A=
=0A=
			} else {=0A=
				return false;=0A=
			}=0A=
		},=0A=
=0A=
		teardown: function( namespaces ) {=0A=
			jQuery.event.remove( this, ".specialSubmit" );=0A=
		}=0A=
	};=0A=
=0A=
}=0A=
=0A=
// change delegation, happens here so we have bind.=0A=
if ( !jQuery.support.changeBubbles ) {=0A=
=0A=
	var changeFilters,=0A=
=0A=
	getVal =3D function( elem ) {=0A=
		var type =3D elem.type, val =3D elem.value;=0A=
=0A=
		if ( type =3D=3D=3D "radio" || type =3D=3D=3D "checkbox" ) {=0A=
			val =3D elem.checked;=0A=
=0A=
		} else if ( type =3D=3D=3D "select-multiple" ) {=0A=
			val =3D elem.selectedIndex > -1 ?=0A=
				jQuery.map( elem.options, function( elem ) {=0A=
					return elem.selected;=0A=
				}).join("-") :=0A=
				"";=0A=
=0A=
		} else if ( jQuery.nodeName( elem, "select" ) ) {=0A=
			val =3D elem.selectedIndex;=0A=
		}=0A=
=0A=
		return val;=0A=
	},=0A=
=0A=
	testChange =3D function testChange( e ) {=0A=
		var elem =3D e.target, data, val;=0A=
=0A=
		if ( !rformElems.test( elem.nodeName ) || elem.readOnly ) {=0A=
			return;=0A=
		}=0A=
=0A=
		data =3D jQuery._data( elem, "_change_data" );=0A=
		val =3D getVal(elem);=0A=
=0A=
		// the current data will be also retrieved by beforeactivate=0A=
		if ( e.type !=3D=3D "focusout" || elem.type !=3D=3D "radio" ) {=0A=
			jQuery._data( elem, "_change_data", val );=0A=
		}=0A=
=0A=
		if ( data =3D=3D=3D undefined || val =3D=3D=3D data ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( data !=3D null || val ) {=0A=
			e.type =3D "change";=0A=
			e.liveFired =3D undefined;=0A=
			jQuery.event.trigger( e, arguments[1], elem );=0A=
		}=0A=
	};=0A=
=0A=
	jQuery.event.special.change =3D {=0A=
		filters: {=0A=
			focusout: testChange,=0A=
=0A=
			beforedeactivate: testChange,=0A=
=0A=
			click: function( e ) {=0A=
				var elem =3D e.target, type =3D jQuery.nodeName( elem, "input" ) ? =
elem.type : "";=0A=
=0A=
				if ( type =3D=3D=3D "radio" || type =3D=3D=3D "checkbox" || =
jQuery.nodeName( elem, "select" ) ) {=0A=
					testChange.call( this, e );=0A=
				}=0A=
			},=0A=
=0A=
			// Change has to be called before submit=0A=
			// Keydown will be called before keypress, which is used in =
submit-event delegation=0A=
			keydown: function( e ) {=0A=
				var elem =3D e.target, type =3D jQuery.nodeName( elem, "input" ) ? =
elem.type : "";=0A=
=0A=
				if ( (e.keyCode =3D=3D=3D 13 && !jQuery.nodeName( elem, "textarea" ) =
) ||=0A=
					(e.keyCode =3D=3D=3D 32 && (type =3D=3D=3D "checkbox" || type =
=3D=3D=3D "radio")) ||=0A=
					type =3D=3D=3D "select-multiple" ) {=0A=
					testChange.call( this, e );=0A=
				}=0A=
			},=0A=
=0A=
			// Beforeactivate happens also before the previous element is blurred=0A=
			// with this event you can't trigger a change event, but you can store=0A=
			// information=0A=
			beforeactivate: function( e ) {=0A=
				var elem =3D e.target;=0A=
				jQuery._data( elem, "_change_data", getVal(elem) );=0A=
			}=0A=
		},=0A=
=0A=
		setup: function( data, namespaces ) {=0A=
			if ( this.type =3D=3D=3D "file" ) {=0A=
				return false;=0A=
			}=0A=
=0A=
			for ( var type in changeFilters ) {=0A=
				jQuery.event.add( this, type + ".specialChange", changeFilters[type] =
);=0A=
			}=0A=
=0A=
			return rformElems.test( this.nodeName );=0A=
		},=0A=
=0A=
		teardown: function( namespaces ) {=0A=
			jQuery.event.remove( this, ".specialChange" );=0A=
=0A=
			return rformElems.test( this.nodeName );=0A=
		}=0A=
	};=0A=
=0A=
	changeFilters =3D jQuery.event.special.change.filters;=0A=
=0A=
	// Handle when the input is .focus()'d=0A=
	changeFilters.focus =3D changeFilters.beforeactivate;=0A=
}=0A=
=0A=
function trigger( type, elem, args ) {=0A=
	// Piggyback on a donor event to simulate a different one.=0A=
	// Fake originalEvent to avoid donor's stopPropagation, but if the=0A=
	// simulated event prevents default then we do the same on the donor.=0A=
	// Don't pass args or remember liveFired; they apply to the donor event.=0A=
	var event =3D jQuery.extend( {}, args[ 0 ] );=0A=
	event.type =3D type;=0A=
	event.originalEvent =3D {};=0A=
	event.liveFired =3D undefined;=0A=
	jQuery.event.handle.call( elem, event );=0A=
	if ( event.isDefaultPrevented() ) {=0A=
		args[ 0 ].preventDefault();=0A=
	}=0A=
}=0A=
=0A=
// Create "bubbling" focus and blur events=0A=
if ( !jQuery.support.focusinBubbles ) {=0A=
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix =
) {=0A=
=0A=
		// Attach a single capturing handler while someone wants =
focusin/focusout=0A=
		var attaches =3D 0;=0A=
=0A=
		jQuery.event.special[ fix ] =3D {=0A=
			setup: function() {=0A=
				if ( attaches++ =3D=3D=3D 0 ) {=0A=
					document.addEventListener( orig, handler, true );=0A=
				}=0A=
			},=0A=
			teardown: function() {=0A=
				if ( --attaches =3D=3D=3D 0 ) {=0A=
					document.removeEventListener( orig, handler, true );=0A=
				}=0A=
			}=0A=
		};=0A=
=0A=
		function handler( donor ) {=0A=
			// Donor event is always a native one; fix it and switch its type.=0A=
			// Let focusin/out handler cancel the donor focus/blur event.=0A=
			var e =3D jQuery.event.fix( donor );=0A=
			e.type =3D fix;=0A=
			e.originalEvent =3D {};=0A=
			jQuery.event.trigger( e, null, e.target );=0A=
			if ( e.isDefaultPrevented() ) {=0A=
				donor.preventDefault();=0A=
			}=0A=
		}=0A=
	});=0A=
}=0A=
=0A=
jQuery.each(["bind", "one"], function( i, name ) {=0A=
	jQuery.fn[ name ] =3D function( type, data, fn ) {=0A=
		var handler;=0A=
=0A=
		// Handle object literals=0A=
		if ( typeof type =3D=3D=3D "object" ) {=0A=
			for ( var key in type ) {=0A=
				this[ name ](key, data, type[key], fn);=0A=
			}=0A=
			return this;=0A=
		}=0A=
=0A=
		if ( arguments.length =3D=3D=3D 2 || data =3D=3D=3D false ) {=0A=
			fn =3D data;=0A=
			data =3D undefined;=0A=
		}=0A=
=0A=
		if ( name =3D=3D=3D "one" ) {=0A=
			handler =3D function( event ) {=0A=
				jQuery( this ).unbind( event, handler );=0A=
				return fn.apply( this, arguments );=0A=
			};=0A=
			handler.guid =3D fn.guid || jQuery.guid++;=0A=
		} else {=0A=
			handler =3D fn;=0A=
		}=0A=
=0A=
		if ( type =3D=3D=3D "unload" && name !=3D=3D "one" ) {=0A=
			this.one( type, data, fn );=0A=
=0A=
		} else {=0A=
			for ( var i =3D 0, l =3D this.length; i < l; i++ ) {=0A=
				jQuery.event.add( this[i], type, handler, data );=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	};=0A=
});=0A=
=0A=
jQuery.fn.extend({=0A=
	unbind: function( type, fn ) {=0A=
		// Handle object literals=0A=
		if ( typeof type =3D=3D=3D "object" && !type.preventDefault ) {=0A=
			for ( var key in type ) {=0A=
				this.unbind(key, type[key]);=0A=
			}=0A=
=0A=
		} else {=0A=
			for ( var i =3D 0, l =3D this.length; i < l; i++ ) {=0A=
				jQuery.event.remove( this[i], type, fn );=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	delegate: function( selector, types, data, fn ) {=0A=
		return this.live( types, data, fn, selector );=0A=
	},=0A=
=0A=
	undelegate: function( selector, types, fn ) {=0A=
		if ( arguments.length =3D=3D=3D 0 ) {=0A=
			return this.unbind( "live" );=0A=
=0A=
		} else {=0A=
			return this.die( types, null, fn, selector );=0A=
		}=0A=
	},=0A=
=0A=
	trigger: function( type, data ) {=0A=
		return this.each(function() {=0A=
			jQuery.event.trigger( type, data, this );=0A=
		});=0A=
	},=0A=
=0A=
	triggerHandler: function( type, data ) {=0A=
		if ( this[0] ) {=0A=
			return jQuery.event.trigger( type, data, this[0], true );=0A=
		}=0A=
	},=0A=
=0A=
	toggle: function( fn ) {=0A=
		// Save reference to arguments for access in closure=0A=
		var args =3D arguments,=0A=
			guid =3D fn.guid || jQuery.guid++,=0A=
			i =3D 0,=0A=
			toggler =3D function( event ) {=0A=
				// Figure out which function to execute=0A=
				var lastToggle =3D ( jQuery.data( this, "lastToggle" + fn.guid ) || =
0 ) % i;=0A=
				jQuery.data( this, "lastToggle" + fn.guid, lastToggle + 1 );=0A=
=0A=
				// Make sure that clicks stop=0A=
				event.preventDefault();=0A=
=0A=
				// and execute the function=0A=
				return args[ lastToggle ].apply( this, arguments ) || false;=0A=
			};=0A=
=0A=
		// link all the functions, so any of them can unbind this click handler=0A=
		toggler.guid =3D guid;=0A=
		while ( i < args.length ) {=0A=
			args[ i++ ].guid =3D guid;=0A=
		}=0A=
=0A=
		return this.click( toggler );=0A=
	},=0A=
=0A=
	hover: function( fnOver, fnOut ) {=0A=
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );=0A=
	}=0A=
});=0A=
=0A=
var liveMap =3D {=0A=
	focus: "focusin",=0A=
	blur: "focusout",=0A=
	mouseenter: "mouseover",=0A=
	mouseleave: "mouseout"=0A=
};=0A=
=0A=
jQuery.each(["live", "die"], function( i, name ) {=0A=
	jQuery.fn[ name ] =3D function( types, data, fn, origSelector /* =
Internal Use Only */ ) {=0A=
		var type, i =3D 0, match, namespaces, preType,=0A=
			selector =3D origSelector || this.selector,=0A=
			context =3D origSelector ? this : jQuery( this.context );=0A=
=0A=
		if ( typeof types =3D=3D=3D "object" && !types.preventDefault ) {=0A=
			for ( var key in types ) {=0A=
				context[ name ]( key, data, types[key], selector );=0A=
			}=0A=
=0A=
			return this;=0A=
		}=0A=
=0A=
		if ( name =3D=3D=3D "die" && !types &&=0A=
					origSelector && origSelector.charAt(0) =3D=3D=3D "." ) {=0A=
=0A=
			context.unbind( origSelector );=0A=
=0A=
			return this;=0A=
		}=0A=
=0A=
		if ( data =3D=3D=3D false || jQuery.isFunction( data ) ) {=0A=
			fn =3D data || returnFalse;=0A=
			data =3D undefined;=0A=
		}=0A=
=0A=
		types =3D (types || "").split(" ");=0A=
=0A=
		while ( (type =3D types[ i++ ]) !=3D null ) {=0A=
			match =3D rnamespaces.exec( type );=0A=
			namespaces =3D "";=0A=
=0A=
			if ( match )  {=0A=
				namespaces =3D match[0];=0A=
				type =3D type.replace( rnamespaces, "" );=0A=
			}=0A=
=0A=
			if ( type =3D=3D=3D "hover" ) {=0A=
				types.push( "mouseenter" + namespaces, "mouseleave" + namespaces );=0A=
				continue;=0A=
			}=0A=
=0A=
			preType =3D type;=0A=
=0A=
			if ( liveMap[ type ] ) {=0A=
				types.push( liveMap[ type ] + namespaces );=0A=
				type =3D type + namespaces;=0A=
=0A=
			} else {=0A=
				type =3D (liveMap[ type ] || type) + namespaces;=0A=
			}=0A=
=0A=
			if ( name =3D=3D=3D "live" ) {=0A=
				// bind live handler=0A=
				for ( var j =3D 0, l =3D context.length; j < l; j++ ) {=0A=
					jQuery.event.add( context[j], "live." + liveConvert( type, selector =
),=0A=
						{ data: data, selector: selector, handler: fn, origType: type, =
origHandler: fn, preType: preType } );=0A=
				}=0A=
=0A=
			} else {=0A=
				// unbind live handler=0A=
				context.unbind( "live." + liveConvert( type, selector ), fn );=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	};=0A=
});=0A=
=0A=
function liveHandler( event ) {=0A=
	var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, =
close, namespace, ret,=0A=
		elems =3D [],=0A=
		selectors =3D [],=0A=
		events =3D jQuery._data( this, "events" );=0A=
=0A=
	// Make sure we avoid non-left-click bubbling in Firefox (#3861) and =
disabled elements in IE (#6911)=0A=
	if ( event.liveFired =3D=3D=3D this || !events || !events.live || =
event.target.disabled || event.button && event.type =3D=3D=3D "click" ) {=0A=
		return;=0A=
	}=0A=
=0A=
	if ( event.namespace ) {=0A=
		namespace =3D new RegExp("(^|\\.)" + =
event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");=0A=
	}=0A=
=0A=
	event.liveFired =3D this;=0A=
=0A=
	var live =3D events.live.slice(0);=0A=
=0A=
	for ( j =3D 0; j < live.length; j++ ) {=0A=
		handleObj =3D live[j];=0A=
=0A=
		if ( handleObj.origType.replace( rnamespaces, "" ) =3D=3D=3D =
event.type ) {=0A=
			selectors.push( handleObj.selector );=0A=
=0A=
		} else {=0A=
			live.splice( j--, 1 );=0A=
		}=0A=
	}=0A=
=0A=
	match =3D jQuery( event.target ).closest( selectors, =
event.currentTarget );=0A=
=0A=
	for ( i =3D 0, l =3D match.length; i < l; i++ ) {=0A=
		close =3D match[i];=0A=
=0A=
		for ( j =3D 0; j < live.length; j++ ) {=0A=
			handleObj =3D live[j];=0A=
=0A=
			if ( close.selector =3D=3D=3D handleObj.selector && (!namespace || =
namespace.test( handleObj.namespace )) && !close.elem.disabled ) {=0A=
				elem =3D close.elem;=0A=
				related =3D null;=0A=
=0A=
				// Those two events require additional checking=0A=
				if ( handleObj.preType =3D=3D=3D "mouseenter" || handleObj.preType =
=3D=3D=3D "mouseleave" ) {=0A=
					event.type =3D handleObj.preType;=0A=
					related =3D jQuery( event.relatedTarget ).closest( =
handleObj.selector )[0];=0A=
=0A=
					// Make sure not to accidentally match a child element with the =
same selector=0A=
					if ( related && jQuery.contains( elem, related ) ) {=0A=
						related =3D elem;=0A=
					}=0A=
				}=0A=
=0A=
				if ( !related || related !=3D=3D elem ) {=0A=
					elems.push({ elem: elem, handleObj: handleObj, level: close.level =
});=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	for ( i =3D 0, l =3D elems.length; i < l; i++ ) {=0A=
		match =3D elems[i];=0A=
=0A=
		if ( maxLevel && match.level > maxLevel ) {=0A=
			break;=0A=
		}=0A=
=0A=
		event.currentTarget =3D match.elem;=0A=
		event.data =3D match.handleObj.data;=0A=
		event.handleObj =3D match.handleObj;=0A=
=0A=
		ret =3D match.handleObj.origHandler.apply( match.elem, arguments );=0A=
=0A=
		if ( ret =3D=3D=3D false || event.isPropagationStopped() ) {=0A=
			maxLevel =3D match.level;=0A=
=0A=
			if ( ret =3D=3D=3D false ) {=0A=
				stop =3D false;=0A=
			}=0A=
			if ( event.isImmediatePropagationStopped() ) {=0A=
				break;=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return stop;=0A=
}=0A=
=0A=
function liveConvert( type, selector ) {=0A=
	return (type && type !=3D=3D "*" ? type + "." : "") + =
selector.replace(rperiod, "`").replace(rspaces, "&");=0A=
}=0A=
=0A=
jQuery.each( ("blur focus focusin focusout load resize scroll unload =
click dblclick " +=0A=
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " =
+=0A=
	"change select submit keydown keypress keyup error").split(" "), =
function( i, name ) {=0A=
=0A=
	// Handle event binding=0A=
	jQuery.fn[ name ] =3D function( data, fn ) {=0A=
		if ( fn =3D=3D null ) {=0A=
			fn =3D data;=0A=
			data =3D null;=0A=
		}=0A=
=0A=
		return arguments.length > 0 ?=0A=
			this.bind( name, data, fn ) :=0A=
			this.trigger( name );=0A=
	};=0A=
=0A=
	if ( jQuery.attrFn ) {=0A=
		jQuery.attrFn[ name ] =3D true;=0A=
	}=0A=
});=0A=
=0A=
=0A=
=0A=
/*!=0A=
 * Sizzle CSS Selector Engine=0A=
 *  Copyright 2011, The Dojo Foundation=0A=
 *  Released under the MIT, BSD, and GPL Licenses.=0A=
 *  More information: http://sizzlejs.com/=0A=
 */=0A=
(function(){=0A=
=0A=
var chunker =3D =
/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"=
]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,=0A=
	done =3D 0,=0A=
	toString =3D Object.prototype.toString,=0A=
	hasDuplicate =3D false,=0A=
	baseHasDuplicate =3D true,=0A=
	rBackslash =3D /\\/g,=0A=
	rNonWord =3D /\W/;=0A=
=0A=
// Here we check if the JavaScript engine is using some sort of=0A=
// optimization where it does not always call our comparision=0A=
// function. If that is the case, discard the hasDuplicate value.=0A=
//   Thus far that includes Google Chrome.=0A=
[0, 0].sort(function() {=0A=
	baseHasDuplicate =3D false;=0A=
	return 0;=0A=
});=0A=
=0A=
var Sizzle =3D function( selector, context, results, seed ) {=0A=
	results =3D results || [];=0A=
	context =3D context || document;=0A=
=0A=
	var origContext =3D context;=0A=
=0A=
	if ( context.nodeType !=3D=3D 1 && context.nodeType !=3D=3D 9 ) {=0A=
		return [];=0A=
	}=0A=
	=0A=
	if ( !selector || typeof selector !=3D=3D "string" ) {=0A=
		return results;=0A=
	}=0A=
=0A=
	var m, set, checkSet, extra, ret, cur, pop, i,=0A=
		prune =3D true,=0A=
		contextXML =3D Sizzle.isXML( context ),=0A=
		parts =3D [],=0A=
		soFar =3D selector;=0A=
	=0A=
	// Reset the position of the chunker regexp (start from head)=0A=
	do {=0A=
		chunker.exec( "" );=0A=
		m =3D chunker.exec( soFar );=0A=
=0A=
		if ( m ) {=0A=
			soFar =3D m[3];=0A=
		=0A=
			parts.push( m[1] );=0A=
		=0A=
			if ( m[2] ) {=0A=
				extra =3D m[3];=0A=
				break;=0A=
			}=0A=
		}=0A=
	} while ( m );=0A=
=0A=
	if ( parts.length > 1 && origPOS.exec( selector ) ) {=0A=
=0A=
		if ( parts.length =3D=3D=3D 2 && Expr.relative[ parts[0] ] ) {=0A=
			set =3D posProcess( parts[0] + parts[1], context );=0A=
=0A=
		} else {=0A=
			set =3D Expr.relative[ parts[0] ] ?=0A=
				[ context ] :=0A=
				Sizzle( parts.shift(), context );=0A=
=0A=
			while ( parts.length ) {=0A=
				selector =3D parts.shift();=0A=
=0A=
				if ( Expr.relative[ selector ] ) {=0A=
					selector +=3D parts.shift();=0A=
				}=0A=
				=0A=
				set =3D posProcess( selector, set );=0A=
			}=0A=
		}=0A=
=0A=
	} else {=0A=
		// Take a shortcut and set the context if the root selector is an ID=0A=
		// (but not if it'll be faster if the inner selector is an ID)=0A=
		if ( !seed && parts.length > 1 && context.nodeType =3D=3D=3D 9 && =
!contextXML &&=0A=
				Expr.match.ID.test(parts[0]) && =
!Expr.match.ID.test(parts[parts.length - 1]) ) {=0A=
=0A=
			ret =3D Sizzle.find( parts.shift(), context, contextXML );=0A=
			context =3D ret.expr ?=0A=
				Sizzle.filter( ret.expr, ret.set )[0] :=0A=
				ret.set[0];=0A=
		}=0A=
=0A=
		if ( context ) {=0A=
			ret =3D seed ?=0A=
				{ expr: parts.pop(), set: makeArray(seed) } :=0A=
				Sizzle.find( parts.pop(), parts.length =3D=3D=3D 1 && (parts[0] =
=3D=3D=3D "~" || parts[0] =3D=3D=3D "+") && context.parentNode ? =
context.parentNode : context, contextXML );=0A=
=0A=
			set =3D ret.expr ?=0A=
				Sizzle.filter( ret.expr, ret.set ) :=0A=
				ret.set;=0A=
=0A=
			if ( parts.length > 0 ) {=0A=
				checkSet =3D makeArray( set );=0A=
=0A=
			} else {=0A=
				prune =3D false;=0A=
			}=0A=
=0A=
			while ( parts.length ) {=0A=
				cur =3D parts.pop();=0A=
				pop =3D cur;=0A=
=0A=
				if ( !Expr.relative[ cur ] ) {=0A=
					cur =3D "";=0A=
				} else {=0A=
					pop =3D parts.pop();=0A=
				}=0A=
=0A=
				if ( pop =3D=3D null ) {=0A=
					pop =3D context;=0A=
				}=0A=
=0A=
				Expr.relative[ cur ]( checkSet, pop, contextXML );=0A=
			}=0A=
=0A=
		} else {=0A=
			checkSet =3D parts =3D [];=0A=
		}=0A=
	}=0A=
=0A=
	if ( !checkSet ) {=0A=
		checkSet =3D set;=0A=
	}=0A=
=0A=
	if ( !checkSet ) {=0A=
		Sizzle.error( cur || selector );=0A=
	}=0A=
=0A=
	if ( toString.call(checkSet) =3D=3D=3D "[object Array]" ) {=0A=
		if ( !prune ) {=0A=
			results.push.apply( results, checkSet );=0A=
=0A=
		} else if ( context && context.nodeType =3D=3D=3D 1 ) {=0A=
			for ( i =3D 0; checkSet[i] !=3D null; i++ ) {=0A=
				if ( checkSet[i] && (checkSet[i] =3D=3D=3D true || =
checkSet[i].nodeType =3D=3D=3D 1 && Sizzle.contains(context, =
checkSet[i])) ) {=0A=
					results.push( set[i] );=0A=
				}=0A=
			}=0A=
=0A=
		} else {=0A=
			for ( i =3D 0; checkSet[i] !=3D null; i++ ) {=0A=
				if ( checkSet[i] && checkSet[i].nodeType =3D=3D=3D 1 ) {=0A=
					results.push( set[i] );=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
	} else {=0A=
		makeArray( checkSet, results );=0A=
	}=0A=
=0A=
	if ( extra ) {=0A=
		Sizzle( extra, origContext, results, seed );=0A=
		Sizzle.uniqueSort( results );=0A=
	}=0A=
=0A=
	return results;=0A=
};=0A=
=0A=
Sizzle.uniqueSort =3D function( results ) {=0A=
	if ( sortOrder ) {=0A=
		hasDuplicate =3D baseHasDuplicate;=0A=
		results.sort( sortOrder );=0A=
=0A=
		if ( hasDuplicate ) {=0A=
			for ( var i =3D 1; i < results.length; i++ ) {=0A=
				if ( results[i] =3D=3D=3D results[ i - 1 ] ) {=0A=
					results.splice( i--, 1 );=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return results;=0A=
};=0A=
=0A=
Sizzle.matches =3D function( expr, set ) {=0A=
	return Sizzle( expr, null, null, set );=0A=
};=0A=
=0A=
Sizzle.matchesSelector =3D function( node, expr ) {=0A=
	return Sizzle( expr, null, null, [node] ).length > 0;=0A=
};=0A=
=0A=
Sizzle.find =3D function( expr, context, isXML ) {=0A=
	var set;=0A=
=0A=
	if ( !expr ) {=0A=
		return [];=0A=
	}=0A=
=0A=
	for ( var i =3D 0, l =3D Expr.order.length; i < l; i++ ) {=0A=
		var match,=0A=
			type =3D Expr.order[i];=0A=
		=0A=
		if ( (match =3D Expr.leftMatch[ type ].exec( expr )) ) {=0A=
			var left =3D match[1];=0A=
			match.splice( 1, 1 );=0A=
=0A=
			if ( left.substr( left.length - 1 ) !=3D=3D "\\" ) {=0A=
				match[1] =3D (match[1] || "").replace( rBackslash, "" );=0A=
				set =3D Expr.find[ type ]( match, context, isXML );=0A=
=0A=
				if ( set !=3D null ) {=0A=
					expr =3D expr.replace( Expr.match[ type ], "" );=0A=
					break;=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	if ( !set ) {=0A=
		set =3D typeof context.getElementsByTagName !=3D=3D "undefined" ?=0A=
			context.getElementsByTagName( "*" ) :=0A=
			[];=0A=
	}=0A=
=0A=
	return { set: set, expr: expr };=0A=
};=0A=
=0A=
Sizzle.filter =3D function( expr, set, inplace, not ) {=0A=
	var match, anyFound,=0A=
		old =3D expr,=0A=
		result =3D [],=0A=
		curLoop =3D set,=0A=
		isXMLFilter =3D set && set[0] && Sizzle.isXML( set[0] );=0A=
=0A=
	while ( expr && set.length ) {=0A=
		for ( var type in Expr.filter ) {=0A=
			if ( (match =3D Expr.leftMatch[ type ].exec( expr )) !=3D null && =
match[2] ) {=0A=
				var found, item,=0A=
					filter =3D Expr.filter[ type ],=0A=
					left =3D match[1];=0A=
=0A=
				anyFound =3D false;=0A=
=0A=
				match.splice(1,1);=0A=
=0A=
				if ( left.substr( left.length - 1 ) =3D=3D=3D "\\" ) {=0A=
					continue;=0A=
				}=0A=
=0A=
				if ( curLoop =3D=3D=3D result ) {=0A=
					result =3D [];=0A=
				}=0A=
=0A=
				if ( Expr.preFilter[ type ] ) {=0A=
					match =3D Expr.preFilter[ type ]( match, curLoop, inplace, result, =
not, isXMLFilter );=0A=
=0A=
					if ( !match ) {=0A=
						anyFound =3D found =3D true;=0A=
=0A=
					} else if ( match =3D=3D=3D true ) {=0A=
						continue;=0A=
					}=0A=
				}=0A=
=0A=
				if ( match ) {=0A=
					for ( var i =3D 0; (item =3D curLoop[i]) !=3D null; i++ ) {=0A=
						if ( item ) {=0A=
							found =3D filter( item, match, i, curLoop );=0A=
							var pass =3D not ^ !!found;=0A=
=0A=
							if ( inplace && found !=3D null ) {=0A=
								if ( pass ) {=0A=
									anyFound =3D true;=0A=
=0A=
								} else {=0A=
									curLoop[i] =3D false;=0A=
								}=0A=
=0A=
							} else if ( pass ) {=0A=
								result.push( item );=0A=
								anyFound =3D true;=0A=
							}=0A=
						}=0A=
					}=0A=
				}=0A=
=0A=
				if ( found !=3D=3D undefined ) {=0A=
					if ( !inplace ) {=0A=
						curLoop =3D result;=0A=
					}=0A=
=0A=
					expr =3D expr.replace( Expr.match[ type ], "" );=0A=
=0A=
					if ( !anyFound ) {=0A=
						return [];=0A=
					}=0A=
=0A=
					break;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Improper expression=0A=
		if ( expr =3D=3D=3D old ) {=0A=
			if ( anyFound =3D=3D null ) {=0A=
				Sizzle.error( expr );=0A=
=0A=
			} else {=0A=
				break;=0A=
			}=0A=
		}=0A=
=0A=
		old =3D expr;=0A=
	}=0A=
=0A=
	return curLoop;=0A=
};=0A=
=0A=
Sizzle.error =3D function( msg ) {=0A=
	throw "Syntax error, unrecognized expression: " + msg;=0A=
};=0A=
=0A=
var Expr =3D Sizzle.selectors =3D {=0A=
	order: [ "ID", "NAME", "TAG" ],=0A=
=0A=
	match: {=0A=
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,=0A=
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,=0A=
		NAME: /\[name=3D['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,=0A=
		ATTR: =
/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=3D)\s*(?:(['"])(.*?)\3|(#?=
(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,=0A=
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,=0A=
		CHILD: =
/:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)=
?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,=0A=
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=3D[^\-]|$)/,=0A=
		PSEUDO: =
/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\=
))?/=0A=
	},=0A=
=0A=
	leftMatch: {},=0A=
=0A=
	attrMap: {=0A=
		"class": "className",=0A=
		"for": "htmlFor"=0A=
	},=0A=
=0A=
	attrHandle: {=0A=
		href: function( elem ) {=0A=
			return elem.getAttribute( "href" );=0A=
		},=0A=
		type: function( elem ) {=0A=
			return elem.getAttribute( "type" );=0A=
		}=0A=
	},=0A=
=0A=
	relative: {=0A=
		"+": function(checkSet, part){=0A=
			var isPartStr =3D typeof part =3D=3D=3D "string",=0A=
				isTag =3D isPartStr && !rNonWord.test( part ),=0A=
				isPartStrNotTag =3D isPartStr && !isTag;=0A=
=0A=
			if ( isTag ) {=0A=
				part =3D part.toLowerCase();=0A=
			}=0A=
=0A=
			for ( var i =3D 0, l =3D checkSet.length, elem; i < l; i++ ) {=0A=
				if ( (elem =3D checkSet[i]) ) {=0A=
					while ( (elem =3D elem.previousSibling) && elem.nodeType !=3D=3D 1 =
) {}=0A=
=0A=
					checkSet[i] =3D isPartStrNotTag || elem && =
elem.nodeName.toLowerCase() =3D=3D=3D part ?=0A=
						elem || false :=0A=
						elem =3D=3D=3D part;=0A=
				}=0A=
			}=0A=
=0A=
			if ( isPartStrNotTag ) {=0A=
				Sizzle.filter( part, checkSet, true );=0A=
			}=0A=
		},=0A=
=0A=
		">": function( checkSet, part ) {=0A=
			var elem,=0A=
				isPartStr =3D typeof part =3D=3D=3D "string",=0A=
				i =3D 0,=0A=
				l =3D checkSet.length;=0A=
=0A=
			if ( isPartStr && !rNonWord.test( part ) ) {=0A=
				part =3D part.toLowerCase();=0A=
=0A=
				for ( ; i < l; i++ ) {=0A=
					elem =3D checkSet[i];=0A=
=0A=
					if ( elem ) {=0A=
						var parent =3D elem.parentNode;=0A=
						checkSet[i] =3D parent.nodeName.toLowerCase() =3D=3D=3D part ? =
parent : false;=0A=
					}=0A=
				}=0A=
=0A=
			} else {=0A=
				for ( ; i < l; i++ ) {=0A=
					elem =3D checkSet[i];=0A=
=0A=
					if ( elem ) {=0A=
						checkSet[i] =3D isPartStr ?=0A=
							elem.parentNode :=0A=
							elem.parentNode =3D=3D=3D part;=0A=
					}=0A=
				}=0A=
=0A=
				if ( isPartStr ) {=0A=
					Sizzle.filter( part, checkSet, true );=0A=
				}=0A=
			}=0A=
		},=0A=
=0A=
		"": function(checkSet, part, isXML){=0A=
			var nodeCheck,=0A=
				doneName =3D done++,=0A=
				checkFn =3D dirCheck;=0A=
=0A=
			if ( typeof part =3D=3D=3D "string" && !rNonWord.test( part ) ) {=0A=
				part =3D part.toLowerCase();=0A=
				nodeCheck =3D part;=0A=
				checkFn =3D dirNodeCheck;=0A=
			}=0A=
=0A=
			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );=0A=
		},=0A=
=0A=
		"~": function( checkSet, part, isXML ) {=0A=
			var nodeCheck,=0A=
				doneName =3D done++,=0A=
				checkFn =3D dirCheck;=0A=
=0A=
			if ( typeof part =3D=3D=3D "string" && !rNonWord.test( part ) ) {=0A=
				part =3D part.toLowerCase();=0A=
				nodeCheck =3D part;=0A=
				checkFn =3D dirNodeCheck;=0A=
			}=0A=
=0A=
			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, =
isXML );=0A=
		}=0A=
	},=0A=
=0A=
	find: {=0A=
		ID: function( match, context, isXML ) {=0A=
			if ( typeof context.getElementById !=3D=3D "undefined" && !isXML ) {=0A=
				var m =3D context.getElementById(match[1]);=0A=
				// Check parentNode to catch when Blackberry 4.6 returns=0A=
				// nodes that are no longer in the document #6963=0A=
				return m && m.parentNode ? [m] : [];=0A=
			}=0A=
		},=0A=
=0A=
		NAME: function( match, context ) {=0A=
			if ( typeof context.getElementsByName !=3D=3D "undefined" ) {=0A=
				var ret =3D [],=0A=
					results =3D context.getElementsByName( match[1] );=0A=
=0A=
				for ( var i =3D 0, l =3D results.length; i < l; i++ ) {=0A=
					if ( results[i].getAttribute("name") =3D=3D=3D match[1] ) {=0A=
						ret.push( results[i] );=0A=
					}=0A=
				}=0A=
=0A=
				return ret.length =3D=3D=3D 0 ? null : ret;=0A=
			}=0A=
		},=0A=
=0A=
		TAG: function( match, context ) {=0A=
			if ( typeof context.getElementsByTagName !=3D=3D "undefined" ) {=0A=
				return context.getElementsByTagName( match[1] );=0A=
			}=0A=
		}=0A=
	},=0A=
	preFilter: {=0A=
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {=0A=
			match =3D " " + match[1].replace( rBackslash, "" ) + " ";=0A=
=0A=
			if ( isXML ) {=0A=
				return match;=0A=
			}=0A=
=0A=
			for ( var i =3D 0, elem; (elem =3D curLoop[i]) !=3D null; i++ ) {=0A=
				if ( elem ) {=0A=
					if ( not ^ (elem.className && (" " + elem.className + " =
").replace(/[\t\n\r]/g, " ").indexOf(match) >=3D 0) ) {=0A=
						if ( !inplace ) {=0A=
							result.push( elem );=0A=
						}=0A=
=0A=
					} else if ( inplace ) {=0A=
						curLoop[i] =3D false;=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			return false;=0A=
		},=0A=
=0A=
		ID: function( match ) {=0A=
			return match[1].replace( rBackslash, "" );=0A=
		},=0A=
=0A=
		TAG: function( match, curLoop ) {=0A=
			return match[1].replace( rBackslash, "" ).toLowerCase();=0A=
		},=0A=
=0A=
		CHILD: function( match ) {=0A=
			if ( match[1] =3D=3D=3D "nth" ) {=0A=
				if ( !match[2] ) {=0A=
					Sizzle.error( match[0] );=0A=
				}=0A=
=0A=
				match[2] =3D match[2].replace(/^\+|\s*/g, '');=0A=
=0A=
				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', =
'-n+6'=0A=
				var test =3D /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(=0A=
					match[2] =3D=3D=3D "even" && "2n" || match[2] =3D=3D=3D "odd" && =
"2n+1" ||=0A=
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);=0A=
=0A=
				// calculate the numbers (first)n+(last) including if they are =
negative=0A=
				match[2] =3D (test[1] + (test[2] || 1)) - 0;=0A=
				match[3] =3D test[3] - 0;=0A=
			}=0A=
			else if ( match[2] ) {=0A=
				Sizzle.error( match[0] );=0A=
			}=0A=
=0A=
			// TODO: Move to normal caching system=0A=
			match[0] =3D done++;=0A=
=0A=
			return match;=0A=
		},=0A=
=0A=
		ATTR: function( match, curLoop, inplace, result, not, isXML ) {=0A=
			var name =3D match[1] =3D match[1].replace( rBackslash, "" );=0A=
			=0A=
			if ( !isXML && Expr.attrMap[name] ) {=0A=
				match[1] =3D Expr.attrMap[name];=0A=
			}=0A=
=0A=
			// Handle if an un-quoted value was used=0A=
			match[4] =3D ( match[4] || match[5] || "" ).replace( rBackslash, "" );=0A=
=0A=
			if ( match[2] =3D=3D=3D "~=3D" ) {=0A=
				match[4] =3D " " + match[4] + " ";=0A=
			}=0A=
=0A=
			return match;=0A=
		},=0A=
=0A=
		PSEUDO: function( match, curLoop, inplace, result, not ) {=0A=
			if ( match[1] =3D=3D=3D "not" ) {=0A=
				// If we're dealing with a complex expression, or a simple one=0A=
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || =
/^\w/.test(match[3]) ) {=0A=
					match[3] =3D Sizzle(match[3], null, null, curLoop);=0A=
=0A=
				} else {=0A=
					var ret =3D Sizzle.filter(match[3], curLoop, inplace, true ^ not);=0A=
=0A=
					if ( !inplace ) {=0A=
						result.push.apply( result, ret );=0A=
					}=0A=
=0A=
					return false;=0A=
				}=0A=
=0A=
			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( =
match[0] ) ) {=0A=
				return true;=0A=
			}=0A=
			=0A=
			return match;=0A=
		},=0A=
=0A=
		POS: function( match ) {=0A=
			match.unshift( true );=0A=
=0A=
			return match;=0A=
		}=0A=
	},=0A=
	=0A=
	filters: {=0A=
		enabled: function( elem ) {=0A=
			return elem.disabled =3D=3D=3D false && elem.type !=3D=3D "hidden";=0A=
		},=0A=
=0A=
		disabled: function( elem ) {=0A=
			return elem.disabled =3D=3D=3D true;=0A=
		},=0A=
=0A=
		checked: function( elem ) {=0A=
			return elem.checked =3D=3D=3D true;=0A=
		},=0A=
		=0A=
		selected: function( elem ) {=0A=
			// Accessing this property makes selected-by-default=0A=
			// options in Safari work properly=0A=
			if ( elem.parentNode ) {=0A=
				elem.parentNode.selectedIndex;=0A=
			}=0A=
			=0A=
			return elem.selected =3D=3D=3D true;=0A=
		},=0A=
=0A=
		parent: function( elem ) {=0A=
			return !!elem.firstChild;=0A=
		},=0A=
=0A=
		empty: function( elem ) {=0A=
			return !elem.firstChild;=0A=
		},=0A=
=0A=
		has: function( elem, i, match ) {=0A=
			return !!Sizzle( match[3], elem ).length;=0A=
		},=0A=
=0A=
		header: function( elem ) {=0A=
			return (/h\d/i).test( elem.nodeName );=0A=
		},=0A=
=0A=
		text: function( elem ) {=0A=
			var attr =3D elem.getAttribute( "type" ), type =3D elem.type;=0A=
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types =
(search, etc) =0A=
			// use getAttribute instead to test this case=0A=
			return elem.nodeName.toLowerCase() =3D=3D=3D "input" && "text" =
=3D=3D=3D type && ( attr =3D=3D=3D type || attr =3D=3D=3D null );=0A=
		},=0A=
=0A=
		radio: function( elem ) {=0A=
			return elem.nodeName.toLowerCase() =3D=3D=3D "input" && "radio" =
=3D=3D=3D elem.type;=0A=
		},=0A=
=0A=
		checkbox: function( elem ) {=0A=
			return elem.nodeName.toLowerCase() =3D=3D=3D "input" && "checkbox" =
=3D=3D=3D elem.type;=0A=
		},=0A=
=0A=
		file: function( elem ) {=0A=
			return elem.nodeName.toLowerCase() =3D=3D=3D "input" && "file" =
=3D=3D=3D elem.type;=0A=
		},=0A=
=0A=
		password: function( elem ) {=0A=
			return elem.nodeName.toLowerCase() =3D=3D=3D "input" && "password" =
=3D=3D=3D elem.type;=0A=
		},=0A=
=0A=
		submit: function( elem ) {=0A=
			var name =3D elem.nodeName.toLowerCase();=0A=
			return (name =3D=3D=3D "input" || name =3D=3D=3D "button") && =
"submit" =3D=3D=3D elem.type;=0A=
		},=0A=
=0A=
		image: function( elem ) {=0A=
			return elem.nodeName.toLowerCase() =3D=3D=3D "input" && "image" =
=3D=3D=3D elem.type;=0A=
		},=0A=
=0A=
		reset: function( elem ) {=0A=
			var name =3D elem.nodeName.toLowerCase();=0A=
			return (name =3D=3D=3D "input" || name =3D=3D=3D "button") && "reset" =
=3D=3D=3D elem.type;=0A=
		},=0A=
=0A=
		button: function( elem ) {=0A=
			var name =3D elem.nodeName.toLowerCase();=0A=
			return name =3D=3D=3D "input" && "button" =3D=3D=3D elem.type || name =
=3D=3D=3D "button";=0A=
		},=0A=
=0A=
		input: function( elem ) {=0A=
			return (/input|select|textarea|button/i).test( elem.nodeName );=0A=
		},=0A=
=0A=
		focus: function( elem ) {=0A=
			return elem =3D=3D=3D elem.ownerDocument.activeElement;=0A=
		}=0A=
	},=0A=
	setFilters: {=0A=
		first: function( elem, i ) {=0A=
			return i =3D=3D=3D 0;=0A=
		},=0A=
=0A=
		last: function( elem, i, match, array ) {=0A=
			return i =3D=3D=3D array.length - 1;=0A=
		},=0A=
=0A=
		even: function( elem, i ) {=0A=
			return i % 2 =3D=3D=3D 0;=0A=
		},=0A=
=0A=
		odd: function( elem, i ) {=0A=
			return i % 2 =3D=3D=3D 1;=0A=
		},=0A=
=0A=
		lt: function( elem, i, match ) {=0A=
			return i < match[3] - 0;=0A=
		},=0A=
=0A=
		gt: function( elem, i, match ) {=0A=
			return i > match[3] - 0;=0A=
		},=0A=
=0A=
		nth: function( elem, i, match ) {=0A=
			return match[3] - 0 =3D=3D=3D i;=0A=
		},=0A=
=0A=
		eq: function( elem, i, match ) {=0A=
			return match[3] - 0 =3D=3D=3D i;=0A=
		}=0A=
	},=0A=
	filter: {=0A=
		PSEUDO: function( elem, match, i, array ) {=0A=
			var name =3D match[1],=0A=
				filter =3D Expr.filters[ name ];=0A=
=0A=
			if ( filter ) {=0A=
				return filter( elem, i, match, array );=0A=
=0A=
			} else if ( name =3D=3D=3D "contains" ) {=0A=
				return (elem.textContent || elem.innerText || Sizzle.getText([ elem =
]) || "").indexOf(match[3]) >=3D 0;=0A=
=0A=
			} else if ( name =3D=3D=3D "not" ) {=0A=
				var not =3D match[3];=0A=
=0A=
				for ( var j =3D 0, l =3D not.length; j < l; j++ ) {=0A=
					if ( not[j] =3D=3D=3D elem ) {=0A=
						return false;=0A=
					}=0A=
				}=0A=
=0A=
				return true;=0A=
=0A=
			} else {=0A=
				Sizzle.error( name );=0A=
			}=0A=
		},=0A=
=0A=
		CHILD: function( elem, match ) {=0A=
			var type =3D match[1],=0A=
				node =3D elem;=0A=
=0A=
			switch ( type ) {=0A=
				case "only":=0A=
				case "first":=0A=
					while ( (node =3D node.previousSibling) )	 {=0A=
						if ( node.nodeType =3D=3D=3D 1 ) { =0A=
							return false; =0A=
						}=0A=
					}=0A=
=0A=
					if ( type =3D=3D=3D "first" ) { =0A=
						return true; =0A=
					}=0A=
=0A=
					node =3D elem;=0A=
=0A=
				case "last":=0A=
					while ( (node =3D node.nextSibling) )	 {=0A=
						if ( node.nodeType =3D=3D=3D 1 ) { =0A=
							return false; =0A=
						}=0A=
					}=0A=
=0A=
					return true;=0A=
=0A=
				case "nth":=0A=
					var first =3D match[2],=0A=
						last =3D match[3];=0A=
=0A=
					if ( first =3D=3D=3D 1 && last =3D=3D=3D 0 ) {=0A=
						return true;=0A=
					}=0A=
					=0A=
					var doneName =3D match[0],=0A=
						parent =3D elem.parentNode;=0A=
	=0A=
					if ( parent && (parent.sizcache !=3D=3D doneName || =
!elem.nodeIndex) ) {=0A=
						var count =3D 0;=0A=
						=0A=
						for ( node =3D parent.firstChild; node; node =3D node.nextSibling =
) {=0A=
							if ( node.nodeType =3D=3D=3D 1 ) {=0A=
								node.nodeIndex =3D ++count;=0A=
							}=0A=
						} =0A=
=0A=
						parent.sizcache =3D doneName;=0A=
					}=0A=
					=0A=
					var diff =3D elem.nodeIndex - last;=0A=
=0A=
					if ( first =3D=3D=3D 0 ) {=0A=
						return diff =3D=3D=3D 0;=0A=
=0A=
					} else {=0A=
						return ( diff % first =3D=3D=3D 0 && diff / first >=3D 0 );=0A=
					}=0A=
			}=0A=
		},=0A=
=0A=
		ID: function( elem, match ) {=0A=
			return elem.nodeType =3D=3D=3D 1 && elem.getAttribute("id") =3D=3D=3D =
match;=0A=
		},=0A=
=0A=
		TAG: function( elem, match ) {=0A=
			return (match =3D=3D=3D "*" && elem.nodeType =3D=3D=3D 1) || =
elem.nodeName.toLowerCase() =3D=3D=3D match;=0A=
		},=0A=
		=0A=
		CLASS: function( elem, match ) {=0A=
			return (" " + (elem.className || elem.getAttribute("class")) + " ")=0A=
				.indexOf( match ) > -1;=0A=
		},=0A=
=0A=
		ATTR: function( elem, match ) {=0A=
			var name =3D match[1],=0A=
				result =3D Expr.attrHandle[ name ] ?=0A=
					Expr.attrHandle[ name ]( elem ) :=0A=
					elem[ name ] !=3D null ?=0A=
						elem[ name ] :=0A=
						elem.getAttribute( name ),=0A=
				value =3D result + "",=0A=
				type =3D match[2],=0A=
				check =3D match[4];=0A=
=0A=
			return result =3D=3D null ?=0A=
				type =3D=3D=3D "!=3D" :=0A=
				type =3D=3D=3D "=3D" ?=0A=
				value =3D=3D=3D check :=0A=
				type =3D=3D=3D "*=3D" ?=0A=
				value.indexOf(check) >=3D 0 :=0A=
				type =3D=3D=3D "~=3D" ?=0A=
				(" " + value + " ").indexOf(check) >=3D 0 :=0A=
				!check ?=0A=
				value && result !=3D=3D false :=0A=
				type =3D=3D=3D "!=3D" ?=0A=
				value !=3D=3D check :=0A=
				type =3D=3D=3D "^=3D" ?=0A=
				value.indexOf(check) =3D=3D=3D 0 :=0A=
				type =3D=3D=3D "$=3D" ?=0A=
				value.substr(value.length - check.length) =3D=3D=3D check :=0A=
				type =3D=3D=3D "|=3D" ?=0A=
				value =3D=3D=3D check || value.substr(0, check.length + 1) =3D=3D=3D =
check + "-" :=0A=
				false;=0A=
		},=0A=
=0A=
		POS: function( elem, match, i, array ) {=0A=
			var name =3D match[2],=0A=
				filter =3D Expr.setFilters[ name ];=0A=
=0A=
			if ( filter ) {=0A=
				return filter( elem, i, match, array );=0A=
			}=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
var origPOS =3D Expr.match.POS,=0A=
	fescape =3D function(all, num){=0A=
		return "\\" + (num - 0 + 1);=0A=
	};=0A=
=0A=
for ( var type in Expr.match ) {=0A=
	Expr.match[ type ] =3D new RegExp( Expr.match[ type ].source + =
(/(?![^\[]*\])(?![^\(]*\))/.source) );=0A=
	Expr.leftMatch[ type ] =3D new RegExp( /(^(?:.|\r|\n)*?)/.source + =
Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );=0A=
}=0A=
=0A=
var makeArray =3D function( array, results ) {=0A=
	array =3D Array.prototype.slice.call( array, 0 );=0A=
=0A=
	if ( results ) {=0A=
		results.push.apply( results, array );=0A=
		return results;=0A=
	}=0A=
	=0A=
	return array;=0A=
};=0A=
=0A=
// Perform a simple check to determine if the browser is capable of=0A=
// converting a NodeList to an array using builtin methods.=0A=
// Also verifies that the returned array holds DOM nodes=0A=
// (which is not the case in the Blackberry browser)=0A=
try {=0A=
	Array.prototype.slice.call( document.documentElement.childNodes, 0 =
)[0].nodeType;=0A=
=0A=
// Provide a fallback method if it does not work=0A=
} catch( e ) {=0A=
	makeArray =3D function( array, results ) {=0A=
		var i =3D 0,=0A=
			ret =3D results || [];=0A=
=0A=
		if ( toString.call(array) =3D=3D=3D "[object Array]" ) {=0A=
			Array.prototype.push.apply( ret, array );=0A=
=0A=
		} else {=0A=
			if ( typeof array.length =3D=3D=3D "number" ) {=0A=
				for ( var l =3D array.length; i < l; i++ ) {=0A=
					ret.push( array[i] );=0A=
				}=0A=
=0A=
			} else {=0A=
				for ( ; array[i]; i++ ) {=0A=
					ret.push( array[i] );=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return ret;=0A=
	};=0A=
}=0A=
=0A=
var sortOrder, siblingCheck;=0A=
=0A=
if ( document.documentElement.compareDocumentPosition ) {=0A=
	sortOrder =3D function( a, b ) {=0A=
		if ( a =3D=3D=3D b ) {=0A=
			hasDuplicate =3D true;=0A=
			return 0;=0A=
		}=0A=
=0A=
		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {=0A=
			return a.compareDocumentPosition ? -1 : 1;=0A=
		}=0A=
=0A=
		return a.compareDocumentPosition(b) & 4 ? -1 : 1;=0A=
	};=0A=
=0A=
} else {=0A=
	sortOrder =3D function( a, b ) {=0A=
		// The nodes are identical, we can exit early=0A=
		if ( a =3D=3D=3D b ) {=0A=
			hasDuplicate =3D true;=0A=
			return 0;=0A=
=0A=
		// Fallback to using sourceIndex (in IE) if it's available on both =
nodes=0A=
		} else if ( a.sourceIndex && b.sourceIndex ) {=0A=
			return a.sourceIndex - b.sourceIndex;=0A=
		}=0A=
=0A=
		var al, bl,=0A=
			ap =3D [],=0A=
			bp =3D [],=0A=
			aup =3D a.parentNode,=0A=
			bup =3D b.parentNode,=0A=
			cur =3D aup;=0A=
=0A=
		// If the nodes are siblings (or identical) we can do a quick check=0A=
		if ( aup =3D=3D=3D bup ) {=0A=
			return siblingCheck( a, b );=0A=
=0A=
		// If no parents were found then the nodes are disconnected=0A=
		} else if ( !aup ) {=0A=
			return -1;=0A=
=0A=
		} else if ( !bup ) {=0A=
			return 1;=0A=
		}=0A=
=0A=
		// Otherwise they're somewhere else in the tree so we need=0A=
		// to build up a full list of the parentNodes for comparison=0A=
		while ( cur ) {=0A=
			ap.unshift( cur );=0A=
			cur =3D cur.parentNode;=0A=
		}=0A=
=0A=
		cur =3D bup;=0A=
=0A=
		while ( cur ) {=0A=
			bp.unshift( cur );=0A=
			cur =3D cur.parentNode;=0A=
		}=0A=
=0A=
		al =3D ap.length;=0A=
		bl =3D bp.length;=0A=
=0A=
		// Start walking down the tree looking for a discrepancy=0A=
		for ( var i =3D 0; i < al && i < bl; i++ ) {=0A=
			if ( ap[i] !=3D=3D bp[i] ) {=0A=
				return siblingCheck( ap[i], bp[i] );=0A=
			}=0A=
		}=0A=
=0A=
		// We ended someplace up the tree so do a sibling check=0A=
		return i =3D=3D=3D al ?=0A=
			siblingCheck( a, bp[i], -1 ) :=0A=
			siblingCheck( ap[i], b, 1 );=0A=
	};=0A=
=0A=
	siblingCheck =3D function( a, b, ret ) {=0A=
		if ( a =3D=3D=3D b ) {=0A=
			return ret;=0A=
		}=0A=
=0A=
		var cur =3D a.nextSibling;=0A=
=0A=
		while ( cur ) {=0A=
			if ( cur =3D=3D=3D b ) {=0A=
				return -1;=0A=
			}=0A=
=0A=
			cur =3D cur.nextSibling;=0A=
		}=0A=
=0A=
		return 1;=0A=
	};=0A=
}=0A=
=0A=
// Utility function for retreiving the text value of an array of DOM =
nodes=0A=
Sizzle.getText =3D function( elems ) {=0A=
	var ret =3D "", elem;=0A=
=0A=
	for ( var i =3D 0; elems[i]; i++ ) {=0A=
		elem =3D elems[i];=0A=
=0A=
		// Get the text from text nodes and CDATA nodes=0A=
		if ( elem.nodeType =3D=3D=3D 3 || elem.nodeType =3D=3D=3D 4 ) {=0A=
			ret +=3D elem.nodeValue;=0A=
=0A=
		// Traverse everything else, except comment nodes=0A=
		} else if ( elem.nodeType !=3D=3D 8 ) {=0A=
			ret +=3D Sizzle.getText( elem.childNodes );=0A=
		}=0A=
	}=0A=
=0A=
	return ret;=0A=
};=0A=
=0A=
// Check to see if the browser returns elements by name when=0A=
// querying by getElementById (and provide a workaround)=0A=
(function(){=0A=
	// We're going to inject a fake input element with a specified name=0A=
	var form =3D document.createElement("div"),=0A=
		id =3D "script" + (new Date()).getTime(),=0A=
		root =3D document.documentElement;=0A=
=0A=
	form.innerHTML =3D "<a name=3D'" + id + "'/>";=0A=
=0A=
	// Inject it into the root element, check its status, and remove it =
quickly=0A=
	root.insertBefore( form, root.firstChild );=0A=
=0A=
	// The workaround has to do additional checks after a getElementById=0A=
	// Which slows things down for other browsers (hence the branching)=0A=
	if ( document.getElementById( id ) ) {=0A=
		Expr.find.ID =3D function( match, context, isXML ) {=0A=
			if ( typeof context.getElementById !=3D=3D "undefined" && !isXML ) {=0A=
				var m =3D context.getElementById(match[1]);=0A=
=0A=
				return m ?=0A=
					m.id =3D=3D=3D match[1] || typeof m.getAttributeNode !=3D=3D =
"undefined" && m.getAttributeNode("id").nodeValue =3D=3D=3D match[1] ?=0A=
						[m] :=0A=
						undefined :=0A=
					[];=0A=
			}=0A=
		};=0A=
=0A=
		Expr.filter.ID =3D function( elem, match ) {=0A=
			var node =3D typeof elem.getAttributeNode !=3D=3D "undefined" && =
elem.getAttributeNode("id");=0A=
=0A=
			return elem.nodeType =3D=3D=3D 1 && node && node.nodeValue =3D=3D=3D =
match;=0A=
		};=0A=
	}=0A=
=0A=
	root.removeChild( form );=0A=
=0A=
	// release memory in IE=0A=
	root =3D form =3D null;=0A=
})();=0A=
=0A=
(function(){=0A=
	// Check to see if the browser returns only elements=0A=
	// when doing getElementsByTagName("*")=0A=
=0A=
	// Create a fake element=0A=
	var div =3D document.createElement("div");=0A=
	div.appendChild( document.createComment("") );=0A=
=0A=
	// Make sure no comments are found=0A=
	if ( div.getElementsByTagName("*").length > 0 ) {=0A=
		Expr.find.TAG =3D function( match, context ) {=0A=
			var results =3D context.getElementsByTagName( match[1] );=0A=
=0A=
			// Filter out possible comments=0A=
			if ( match[1] =3D=3D=3D "*" ) {=0A=
				var tmp =3D [];=0A=
=0A=
				for ( var i =3D 0; results[i]; i++ ) {=0A=
					if ( results[i].nodeType =3D=3D=3D 1 ) {=0A=
						tmp.push( results[i] );=0A=
					}=0A=
				}=0A=
=0A=
				results =3D tmp;=0A=
			}=0A=
=0A=
			return results;=0A=
		};=0A=
	}=0A=
=0A=
	// Check to see if an attribute returns normalized href attributes=0A=
	div.innerHTML =3D "<a href=3D'#'></a>";=0A=
=0A=
	if ( div.firstChild && typeof div.firstChild.getAttribute !=3D=3D =
"undefined" &&=0A=
			div.firstChild.getAttribute("href") !=3D=3D "#" ) {=0A=
=0A=
		Expr.attrHandle.href =3D function( elem ) {=0A=
			return elem.getAttribute( "href", 2 );=0A=
		};=0A=
	}=0A=
=0A=
	// release memory in IE=0A=
	div =3D null;=0A=
})();=0A=
=0A=
if ( document.querySelectorAll ) {=0A=
	(function(){=0A=
		var oldSizzle =3D Sizzle,=0A=
			div =3D document.createElement("div"),=0A=
			id =3D "__sizzle__";=0A=
=0A=
		div.innerHTML =3D "<p class=3D'TEST'></p>";=0A=
=0A=
		// Safari can't handle uppercase or unicode characters when=0A=
		// in quirks mode.=0A=
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length =
=3D=3D=3D 0 ) {=0A=
			return;=0A=
		}=0A=
	=0A=
		Sizzle =3D function( query, context, extra, seed ) {=0A=
			context =3D context || document;=0A=
=0A=
			// Only use querySelectorAll on non-XML documents=0A=
			// (ID selectors don't work in non-HTML documents)=0A=
			if ( !seed && !Sizzle.isXML(context) ) {=0A=
				// See if we find a selector to speed up=0A=
				var match =3D /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );=0A=
				=0A=
				if ( match && (context.nodeType =3D=3D=3D 1 || context.nodeType =
=3D=3D=3D 9) ) {=0A=
					// Speed-up: Sizzle("TAG")=0A=
					if ( match[1] ) {=0A=
						return makeArray( context.getElementsByTagName( query ), extra );=0A=
					=0A=
					// Speed-up: Sizzle(".CLASS")=0A=
					} else if ( match[2] && Expr.find.CLASS && =
context.getElementsByClassName ) {=0A=
						return makeArray( context.getElementsByClassName( match[2] ), =
extra );=0A=
					}=0A=
				}=0A=
				=0A=
				if ( context.nodeType =3D=3D=3D 9 ) {=0A=
					// Speed-up: Sizzle("body")=0A=
					// The body element only exists once, optimize finding it=0A=
					if ( query =3D=3D=3D "body" && context.body ) {=0A=
						return makeArray( [ context.body ], extra );=0A=
						=0A=
					// Speed-up: Sizzle("#ID")=0A=
					} else if ( match && match[3] ) {=0A=
						var elem =3D context.getElementById( match[3] );=0A=
=0A=
						// Check parentNode to catch when Blackberry 4.6 returns=0A=
						// nodes that are no longer in the document #6963=0A=
						if ( elem && elem.parentNode ) {=0A=
							// Handle the case where IE and Opera return items=0A=
							// by name instead of ID=0A=
							if ( elem.id =3D=3D=3D match[3] ) {=0A=
								return makeArray( [ elem ], extra );=0A=
							}=0A=
							=0A=
						} else {=0A=
							return makeArray( [], extra );=0A=
						}=0A=
					}=0A=
					=0A=
					try {=0A=
						return makeArray( context.querySelectorAll(query), extra );=0A=
					} catch(qsaError) {}=0A=
=0A=
				// qSA works strangely on Element-rooted queries=0A=
				// We can work around this by specifying an extra ID on the root=0A=
				// and working up from there (Thanks to Andrew Dupont for the =
technique)=0A=
				// IE 8 doesn't work on object elements=0A=
				} else if ( context.nodeType =3D=3D=3D 1 && =
context.nodeName.toLowerCase() !=3D=3D "object" ) {=0A=
					var oldContext =3D context,=0A=
						old =3D context.getAttribute( "id" ),=0A=
						nid =3D old || id,=0A=
						hasParent =3D context.parentNode,=0A=
						relativeHierarchySelector =3D /^\s*[+~]/.test( query );=0A=
=0A=
					if ( !old ) {=0A=
						context.setAttribute( "id", nid );=0A=
					} else {=0A=
						nid =3D nid.replace( /'/g, "\\$&" );=0A=
					}=0A=
					if ( relativeHierarchySelector && hasParent ) {=0A=
						context =3D context.parentNode;=0A=
					}=0A=
=0A=
					try {=0A=
						if ( !relativeHierarchySelector || hasParent ) {=0A=
							return makeArray( context.querySelectorAll( "[id=3D'" + nid + "'] =
" + query ), extra );=0A=
						}=0A=
=0A=
					} catch(pseudoError) {=0A=
					} finally {=0A=
						if ( !old ) {=0A=
							oldContext.removeAttribute( "id" );=0A=
						}=0A=
					}=0A=
				}=0A=
			}=0A=
		=0A=
			return oldSizzle(query, context, extra, seed);=0A=
		};=0A=
=0A=
		for ( var prop in oldSizzle ) {=0A=
			Sizzle[ prop ] =3D oldSizzle[ prop ];=0A=
		}=0A=
=0A=
		// release memory in IE=0A=
		div =3D null;=0A=
	})();=0A=
}=0A=
=0A=
(function(){=0A=
	var html =3D document.documentElement,=0A=
		matches =3D html.matchesSelector || html.mozMatchesSelector || =
html.webkitMatchesSelector || html.msMatchesSelector;=0A=
=0A=
	if ( matches ) {=0A=
		// Check to see if it's possible to do matchesSelector=0A=
		// on a disconnected node (IE 9 fails this)=0A=
		var disconnectedMatch =3D !matches.call( document.createElement( "div" =
), "div" ),=0A=
			pseudoWorks =3D false;=0A=
=0A=
		try {=0A=
			// This should fail with an exception=0A=
			// Gecko does not error, returns false instead=0A=
			matches.call( document.documentElement, "[test!=3D'']:sizzle" );=0A=
	=0A=
		} catch( pseudoError ) {=0A=
			pseudoWorks =3D true;=0A=
		}=0A=
=0A=
		Sizzle.matchesSelector =3D function( node, expr ) {=0A=
			// Make sure that attribute selectors are quoted=0A=
			expr =3D expr.replace(/\=3D\s*([^'"\]]*)\s*\]/g, "=3D'$1']");=0A=
=0A=
			if ( !Sizzle.isXML( node ) ) {=0A=
				try { =0A=
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && =
!/!=3D/.test( expr ) ) {=0A=
						var ret =3D matches.call( node, expr );=0A=
=0A=
						// IE 9's matchesSelector returns false on disconnected nodes=0A=
						if ( ret || !disconnectedMatch ||=0A=
								// As well, disconnected nodes are said to be in a document=0A=
								// fragment in IE 9, so check for that=0A=
								node.document && node.document.nodeType !=3D=3D 11 ) {=0A=
							return ret;=0A=
						}=0A=
					}=0A=
				} catch(e) {}=0A=
			}=0A=
=0A=
			return Sizzle(expr, null, null, [node]).length > 0;=0A=
		};=0A=
	}=0A=
})();=0A=
=0A=
(function(){=0A=
	var div =3D document.createElement("div");=0A=
=0A=
	div.innerHTML =3D "<div class=3D'test e'></div><div =
class=3D'test'></div>";=0A=
=0A=
	// Opera can't find a second classname (in 9.6)=0A=
	// Also, make sure that getElementsByClassName actually exists=0A=
	if ( !div.getElementsByClassName || =
div.getElementsByClassName("e").length =3D=3D=3D 0 ) {=0A=
		return;=0A=
	}=0A=
=0A=
	// Safari caches class attributes, doesn't catch changes (in 3.2)=0A=
	div.lastChild.className =3D "e";=0A=
=0A=
	if ( div.getElementsByClassName("e").length =3D=3D=3D 1 ) {=0A=
		return;=0A=
	}=0A=
	=0A=
	Expr.order.splice(1, 0, "CLASS");=0A=
	Expr.find.CLASS =3D function( match, context, isXML ) {=0A=
		if ( typeof context.getElementsByClassName !=3D=3D "undefined" && =
!isXML ) {=0A=
			return context.getElementsByClassName(match[1]);=0A=
		}=0A=
	};=0A=
=0A=
	// release memory in IE=0A=
	div =3D null;=0A=
})();=0A=
=0A=
function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {=0A=
	for ( var i =3D 0, l =3D checkSet.length; i < l; i++ ) {=0A=
		var elem =3D checkSet[i];=0A=
=0A=
		if ( elem ) {=0A=
			var match =3D false;=0A=
=0A=
			elem =3D elem[dir];=0A=
=0A=
			while ( elem ) {=0A=
				if ( elem.sizcache =3D=3D=3D doneName ) {=0A=
					match =3D checkSet[elem.sizset];=0A=
					break;=0A=
				}=0A=
=0A=
				if ( elem.nodeType =3D=3D=3D 1 && !isXML ){=0A=
					elem.sizcache =3D doneName;=0A=
					elem.sizset =3D i;=0A=
				}=0A=
=0A=
				if ( elem.nodeName.toLowerCase() =3D=3D=3D cur ) {=0A=
					match =3D elem;=0A=
					break;=0A=
				}=0A=
=0A=
				elem =3D elem[dir];=0A=
			}=0A=
=0A=
			checkSet[i] =3D match;=0A=
		}=0A=
	}=0A=
}=0A=
=0A=
function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {=0A=
	for ( var i =3D 0, l =3D checkSet.length; i < l; i++ ) {=0A=
		var elem =3D checkSet[i];=0A=
=0A=
		if ( elem ) {=0A=
			var match =3D false;=0A=
			=0A=
			elem =3D elem[dir];=0A=
=0A=
			while ( elem ) {=0A=
				if ( elem.sizcache =3D=3D=3D doneName ) {=0A=
					match =3D checkSet[elem.sizset];=0A=
					break;=0A=
				}=0A=
=0A=
				if ( elem.nodeType =3D=3D=3D 1 ) {=0A=
					if ( !isXML ) {=0A=
						elem.sizcache =3D doneName;=0A=
						elem.sizset =3D i;=0A=
					}=0A=
=0A=
					if ( typeof cur !=3D=3D "string" ) {=0A=
						if ( elem =3D=3D=3D cur ) {=0A=
							match =3D true;=0A=
							break;=0A=
						}=0A=
=0A=
					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {=0A=
						match =3D elem;=0A=
						break;=0A=
					}=0A=
				}=0A=
=0A=
				elem =3D elem[dir];=0A=
			}=0A=
=0A=
			checkSet[i] =3D match;=0A=
		}=0A=
	}=0A=
}=0A=
=0A=
if ( document.documentElement.contains ) {=0A=
	Sizzle.contains =3D function( a, b ) {=0A=
		return a !=3D=3D b && (a.contains ? a.contains(b) : true);=0A=
	};=0A=
=0A=
} else if ( document.documentElement.compareDocumentPosition ) {=0A=
	Sizzle.contains =3D function( a, b ) {=0A=
		return !!(a.compareDocumentPosition(b) & 16);=0A=
	};=0A=
=0A=
} else {=0A=
	Sizzle.contains =3D function() {=0A=
		return false;=0A=
	};=0A=
}=0A=
=0A=
Sizzle.isXML =3D function( elem ) {=0A=
	// documentElement is verified for cases where it doesn't yet exist=0A=
	// (such as loading iframes in IE - #4833) =0A=
	var documentElement =3D (elem ? elem.ownerDocument || elem : =
0).documentElement;=0A=
=0A=
	return documentElement ? documentElement.nodeName !=3D=3D "HTML" : =
false;=0A=
};=0A=
=0A=
var posProcess =3D function( selector, context ) {=0A=
	var match,=0A=
		tmpSet =3D [],=0A=
		later =3D "",=0A=
		root =3D context.nodeType ? [context] : context;=0A=
=0A=
	// Position selectors must be done after the filter=0A=
	// And so must :not(positional) so we move all PSEUDOs to the end=0A=
	while ( (match =3D Expr.match.PSEUDO.exec( selector )) ) {=0A=
		later +=3D match[0];=0A=
		selector =3D selector.replace( Expr.match.PSEUDO, "" );=0A=
	}=0A=
=0A=
	selector =3D Expr.relative[selector] ? selector + "*" : selector;=0A=
=0A=
	for ( var i =3D 0, l =3D root.length; i < l; i++ ) {=0A=
		Sizzle( selector, root[i], tmpSet );=0A=
	}=0A=
=0A=
	return Sizzle.filter( later, tmpSet );=0A=
};=0A=
=0A=
// EXPOSE=0A=
jQuery.find =3D Sizzle;=0A=
jQuery.expr =3D Sizzle.selectors;=0A=
jQuery.expr[":"] =3D jQuery.expr.filters;=0A=
jQuery.unique =3D Sizzle.uniqueSort;=0A=
jQuery.text =3D Sizzle.getText;=0A=
jQuery.isXMLDoc =3D Sizzle.isXML;=0A=
jQuery.contains =3D Sizzle.contains;=0A=
=0A=
=0A=
})();=0A=
=0A=
=0A=
var runtil =3D /Until$/,=0A=
	rparentsprev =3D /^(?:parents|prevUntil|prevAll)/,=0A=
	// Note: This RegExp should be improved, or likely pulled from Sizzle=0A=
	rmultiselector =3D /,/,=0A=
	isSimple =3D /^.[^:#\[\.,]*$/,=0A=
	slice =3D Array.prototype.slice,=0A=
	POS =3D jQuery.expr.match.POS,=0A=
	// methods guaranteed to produce a unique set when starting from a =
unique set=0A=
	guaranteedUnique =3D {=0A=
		children: true,=0A=
		contents: true,=0A=
		next: true,=0A=
		prev: true=0A=
	};=0A=
=0A=
jQuery.fn.extend({=0A=
	find: function( selector ) {=0A=
		var self =3D this,=0A=
			i, l;=0A=
=0A=
		if ( typeof selector !=3D=3D "string" ) {=0A=
			return jQuery( selector ).filter(function() {=0A=
				for ( i =3D 0, l =3D self.length; i < l; i++ ) {=0A=
					if ( jQuery.contains( self[ i ], this ) ) {=0A=
						return true;=0A=
					}=0A=
				}=0A=
			});=0A=
		}=0A=
=0A=
		var ret =3D this.pushStack( "", "find", selector ),=0A=
			length, n, r;=0A=
=0A=
		for ( i =3D 0, l =3D this.length; i < l; i++ ) {=0A=
			length =3D ret.length;=0A=
			jQuery.find( selector, this[i], ret );=0A=
=0A=
			if ( i > 0 ) {=0A=
				// Make sure that the results are unique=0A=
				for ( n =3D length; n < ret.length; n++ ) {=0A=
					for ( r =3D 0; r < length; r++ ) {=0A=
						if ( ret[r] =3D=3D=3D ret[n] ) {=0A=
							ret.splice(n--, 1);=0A=
							break;=0A=
						}=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return ret;=0A=
	},=0A=
=0A=
	has: function( target ) {=0A=
		var targets =3D jQuery( target );=0A=
		return this.filter(function() {=0A=
			for ( var i =3D 0, l =3D targets.length; i < l; i++ ) {=0A=
				if ( jQuery.contains( this, targets[i] ) ) {=0A=
					return true;=0A=
				}=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	not: function( selector ) {=0A=
		return this.pushStack( winnow(this, selector, false), "not", selector);=0A=
	},=0A=
=0A=
	filter: function( selector ) {=0A=
		return this.pushStack( winnow(this, selector, true), "filter", =
selector );=0A=
	},=0A=
=0A=
	is: function( selector ) {=0A=
		return !!selector && ( typeof selector =3D=3D=3D "string" ?=0A=
			jQuery.filter( selector, this ).length > 0 :=0A=
			this.filter( selector ).length > 0 );=0A=
	},=0A=
=0A=
	closest: function( selectors, context ) {=0A=
		var ret =3D [], i, l, cur =3D this[0];=0A=
		=0A=
		// Array=0A=
		if ( jQuery.isArray( selectors ) ) {=0A=
			var match, selector,=0A=
				matches =3D {},=0A=
				level =3D 1;=0A=
=0A=
			if ( cur && selectors.length ) {=0A=
				for ( i =3D 0, l =3D selectors.length; i < l; i++ ) {=0A=
					selector =3D selectors[i];=0A=
=0A=
					if ( !matches[ selector ] ) {=0A=
						matches[ selector ] =3D POS.test( selector ) ?=0A=
							jQuery( selector, context || this.context ) :=0A=
							selector;=0A=
					}=0A=
				}=0A=
=0A=
				while ( cur && cur.ownerDocument && cur !=3D=3D context ) {=0A=
					for ( selector in matches ) {=0A=
						match =3D matches[ selector ];=0A=
=0A=
						if ( match.jquery ? match.index( cur ) > -1 : jQuery( cur ).is( =
match ) ) {=0A=
							ret.push({ selector: selector, elem: cur, level: level });=0A=
						}=0A=
					}=0A=
=0A=
					cur =3D cur.parentNode;=0A=
					level++;=0A=
				}=0A=
			}=0A=
=0A=
			return ret;=0A=
		}=0A=
=0A=
		// String=0A=
		var pos =3D POS.test( selectors ) || typeof selectors !=3D=3D "string" =
?=0A=
				jQuery( selectors, context || this.context ) :=0A=
				0;=0A=
=0A=
		for ( i =3D 0, l =3D this.length; i < l; i++ ) {=0A=
			cur =3D this[i];=0A=
=0A=
			while ( cur ) {=0A=
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, =
selectors) ) {=0A=
					ret.push( cur );=0A=
					break;=0A=
=0A=
				} else {=0A=
					cur =3D cur.parentNode;=0A=
					if ( !cur || !cur.ownerDocument || cur =3D=3D=3D context || =
cur.nodeType =3D=3D=3D 11 ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		ret =3D ret.length > 1 ? jQuery.unique( ret ) : ret;=0A=
=0A=
		return this.pushStack( ret, "closest", selectors );=0A=
	},=0A=
=0A=
	// Determine the position of an element within=0A=
	// the matched set of elements=0A=
	index: function( elem ) {=0A=
		if ( !elem || typeof elem =3D=3D=3D "string" ) {=0A=
			return jQuery.inArray( this[0],=0A=
				// If it receives a string, the selector is used=0A=
				// If it receives nothing, the siblings are used=0A=
				elem ? jQuery( elem ) : this.parent().children() );=0A=
		}=0A=
		// Locate the position of the desired element=0A=
		return jQuery.inArray(=0A=
			// If it receives a jQuery object, the first element is used=0A=
			elem.jquery ? elem[0] : elem, this );=0A=
	},=0A=
=0A=
	add: function( selector, context ) {=0A=
		var set =3D typeof selector =3D=3D=3D "string" ?=0A=
				jQuery( selector, context ) :=0A=
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : =
selector ),=0A=
			all =3D jQuery.merge( this.get(), set );=0A=
=0A=
		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( =
all[0] ) ?=0A=
			all :=0A=
			jQuery.unique( all ) );=0A=
	},=0A=
=0A=
	andSelf: function() {=0A=
		return this.add( this.prevObject );=0A=
	}=0A=
});=0A=
=0A=
// A painfully simple check to see if an element is disconnected=0A=
// from a document (should be improved, where feasible).=0A=
function isDisconnected( node ) {=0A=
	return !node || !node.parentNode || node.parentNode.nodeType =3D=3D=3D =
11;=0A=
}=0A=
=0A=
jQuery.each({=0A=
	parent: function( elem ) {=0A=
		var parent =3D elem.parentNode;=0A=
		return parent && parent.nodeType !=3D=3D 11 ? parent : null;=0A=
	},=0A=
	parents: function( elem ) {=0A=
		return jQuery.dir( elem, "parentNode" );=0A=
	},=0A=
	parentsUntil: function( elem, i, until ) {=0A=
		return jQuery.dir( elem, "parentNode", until );=0A=
	},=0A=
	next: function( elem ) {=0A=
		return jQuery.nth( elem, 2, "nextSibling" );=0A=
	},=0A=
	prev: function( elem ) {=0A=
		return jQuery.nth( elem, 2, "previousSibling" );=0A=
	},=0A=
	nextAll: function( elem ) {=0A=
		return jQuery.dir( elem, "nextSibling" );=0A=
	},=0A=
	prevAll: function( elem ) {=0A=
		return jQuery.dir( elem, "previousSibling" );=0A=
	},=0A=
	nextUntil: function( elem, i, until ) {=0A=
		return jQuery.dir( elem, "nextSibling", until );=0A=
	},=0A=
	prevUntil: function( elem, i, until ) {=0A=
		return jQuery.dir( elem, "previousSibling", until );=0A=
	},=0A=
	siblings: function( elem ) {=0A=
		return jQuery.sibling( elem.parentNode.firstChild, elem );=0A=
	},=0A=
	children: function( elem ) {=0A=
		return jQuery.sibling( elem.firstChild );=0A=
	},=0A=
	contents: function( elem ) {=0A=
		return jQuery.nodeName( elem, "iframe" ) ?=0A=
			elem.contentDocument || elem.contentWindow.document :=0A=
			jQuery.makeArray( elem.childNodes );=0A=
	}=0A=
}, function( name, fn ) {=0A=
	jQuery.fn[ name ] =3D function( until, selector ) {=0A=
		var ret =3D jQuery.map( this, fn, until ),=0A=
			// The variable 'args' was introduced in=0A=
			// https://github.com/jquery/jquery/commit/52a0238=0A=
			// to work around a bug in Chrome 10 (Dev) and should be removed when =
the bug is fixed.=0A=
			// http://code.google.com/p/v8/issues/detail?id=3D1050=0A=
			args =3D slice.call(arguments);=0A=
=0A=
		if ( !runtil.test( name ) ) {=0A=
			selector =3D until;=0A=
		}=0A=
=0A=
		if ( selector && typeof selector =3D=3D=3D "string" ) {=0A=
			ret =3D jQuery.filter( selector, ret );=0A=
		}=0A=
=0A=
		ret =3D this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( =
ret ) : ret;=0A=
=0A=
		if ( (this.length > 1 || rmultiselector.test( selector )) && =
rparentsprev.test( name ) ) {=0A=
			ret =3D ret.reverse();=0A=
		}=0A=
=0A=
		return this.pushStack( ret, name, args.join(",") );=0A=
	};=0A=
});=0A=
=0A=
jQuery.extend({=0A=
	filter: function( expr, elems, not ) {=0A=
		if ( not ) {=0A=
			expr =3D ":not(" + expr + ")";=0A=
		}=0A=
=0A=
		return elems.length =3D=3D=3D 1 ?=0A=
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :=0A=
			jQuery.find.matches(expr, elems);=0A=
	},=0A=
=0A=
	dir: function( elem, dir, until ) {=0A=
		var matched =3D [],=0A=
			cur =3D elem[ dir ];=0A=
=0A=
		while ( cur && cur.nodeType !=3D=3D 9 && (until =3D=3D=3D undefined || =
cur.nodeType !=3D=3D 1 || !jQuery( cur ).is( until )) ) {=0A=
			if ( cur.nodeType =3D=3D=3D 1 ) {=0A=
				matched.push( cur );=0A=
			}=0A=
			cur =3D cur[dir];=0A=
		}=0A=
		return matched;=0A=
	},=0A=
=0A=
	nth: function( cur, result, dir, elem ) {=0A=
		result =3D result || 1;=0A=
		var num =3D 0;=0A=
=0A=
		for ( ; cur; cur =3D cur[dir] ) {=0A=
			if ( cur.nodeType =3D=3D=3D 1 && ++num =3D=3D=3D result ) {=0A=
				break;=0A=
			}=0A=
		}=0A=
=0A=
		return cur;=0A=
	},=0A=
=0A=
	sibling: function( n, elem ) {=0A=
		var r =3D [];=0A=
=0A=
		for ( ; n; n =3D n.nextSibling ) {=0A=
			if ( n.nodeType =3D=3D=3D 1 && n !=3D=3D elem ) {=0A=
				r.push( n );=0A=
			}=0A=
		}=0A=
=0A=
		return r;=0A=
	}=0A=
});=0A=
=0A=
// Implement the identical functionality for filter and not=0A=
function winnow( elements, qualifier, keep ) {=0A=
=0A=
	// Can't pass null or undefined to indexOf in Firefox 4=0A=
	// Set to 0 to skip string check=0A=
	qualifier =3D qualifier || 0;=0A=
=0A=
	if ( jQuery.isFunction( qualifier ) ) {=0A=
		return jQuery.grep(elements, function( elem, i ) {=0A=
			var retVal =3D !!qualifier.call( elem, i, elem );=0A=
			return retVal =3D=3D=3D keep;=0A=
		});=0A=
=0A=
	} else if ( qualifier.nodeType ) {=0A=
		return jQuery.grep(elements, function( elem, i ) {=0A=
			return (elem =3D=3D=3D qualifier) =3D=3D=3D keep;=0A=
		});=0A=
=0A=
	} else if ( typeof qualifier =3D=3D=3D "string" ) {=0A=
		var filtered =3D jQuery.grep(elements, function( elem ) {=0A=
			return elem.nodeType =3D=3D=3D 1;=0A=
		});=0A=
=0A=
		if ( isSimple.test( qualifier ) ) {=0A=
			return jQuery.filter(qualifier, filtered, !keep);=0A=
		} else {=0A=
			qualifier =3D jQuery.filter( qualifier, filtered );=0A=
		}=0A=
	}=0A=
=0A=
	return jQuery.grep(elements, function( elem, i ) {=0A=
		return (jQuery.inArray( elem, qualifier ) >=3D 0) =3D=3D=3D keep;=0A=
	});=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
var rinlinejQuery =3D / jQuery\d+=3D"(?:\d+|null)"/g,=0A=
	rleadingWhitespace =3D /^\s+/,=0A=
	rxhtmlTag =3D =
/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig=
,=0A=
	rtagName =3D /<([\w:]+)/,=0A=
	rtbody =3D /<tbody/i,=0A=
	rhtml =3D /<|&#?\w+;/,=0A=
	rnocache =3D /<(?:script|object|embed|option|style)/i,=0A=
	// checked=3D"checked" or checked=0A=
	rchecked =3D /checked\s*(?:[^=3D]|=3D\s*.checked.)/i,=0A=
	rscriptType =3D /\/(java|ecma)script/i,=0A=
	rcleanScript =3D /^\s*<!(?:\[CDATA\[|\-\-)/,=0A=
	wrapMap =3D {=0A=
		option: [ 1, "<select multiple=3D'multiple'>", "</select>" ],=0A=
		legend: [ 1, "<fieldset>", "</fieldset>" ],=0A=
		thead: [ 1, "<table>", "</table>" ],=0A=
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],=0A=
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],=0A=
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],=0A=
		area: [ 1, "<map>", "</map>" ],=0A=
		_default: [ 0, "", "" ]=0A=
	};=0A=
=0A=
wrapMap.optgroup =3D wrapMap.option;=0A=
wrapMap.tbody =3D wrapMap.tfoot =3D wrapMap.colgroup =3D wrapMap.caption =
=3D wrapMap.thead;=0A=
wrapMap.th =3D wrapMap.td;=0A=
=0A=
// IE can't serialize <link> and <script> tags normally=0A=
if ( !jQuery.support.htmlSerialize ) {=0A=
	wrapMap._default =3D [ 1, "div<div>", "</div>" ];=0A=
}=0A=
=0A=
jQuery.fn.extend({=0A=
	text: function( text ) {=0A=
		if ( jQuery.isFunction(text) ) {=0A=
			return this.each(function(i) {=0A=
				var self =3D jQuery( this );=0A=
=0A=
				self.text( text.call(this, i, self.text()) );=0A=
			});=0A=
		}=0A=
=0A=
		if ( typeof text !=3D=3D "object" && text !=3D=3D undefined ) {=0A=
			return this.empty().append( (this[0] && this[0].ownerDocument || =
document).createTextNode( text ) );=0A=
		}=0A=
=0A=
		return jQuery.text( this );=0A=
	},=0A=
=0A=
	wrapAll: function( html ) {=0A=
		if ( jQuery.isFunction( html ) ) {=0A=
			return this.each(function(i) {=0A=
				jQuery(this).wrapAll( html.call(this, i) );=0A=
			});=0A=
		}=0A=
=0A=
		if ( this[0] ) {=0A=
			// The elements to wrap the target around=0A=
			var wrap =3D jQuery( html, this[0].ownerDocument ).eq(0).clone(true);=0A=
=0A=
			if ( this[0].parentNode ) {=0A=
				wrap.insertBefore( this[0] );=0A=
			}=0A=
=0A=
			wrap.map(function() {=0A=
				var elem =3D this;=0A=
=0A=
				while ( elem.firstChild && elem.firstChild.nodeType =3D=3D=3D 1 ) {=0A=
					elem =3D elem.firstChild;=0A=
				}=0A=
=0A=
				return elem;=0A=
			}).append( this );=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	wrapInner: function( html ) {=0A=
		if ( jQuery.isFunction( html ) ) {=0A=
			return this.each(function(i) {=0A=
				jQuery(this).wrapInner( html.call(this, i) );=0A=
			});=0A=
		}=0A=
=0A=
		return this.each(function() {=0A=
			var self =3D jQuery( this ),=0A=
				contents =3D self.contents();=0A=
=0A=
			if ( contents.length ) {=0A=
				contents.wrapAll( html );=0A=
=0A=
			} else {=0A=
				self.append( html );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	wrap: function( html ) {=0A=
		return this.each(function() {=0A=
			jQuery( this ).wrapAll( html );=0A=
		});=0A=
	},=0A=
=0A=
	unwrap: function() {=0A=
		return this.parent().each(function() {=0A=
			if ( !jQuery.nodeName( this, "body" ) ) {=0A=
				jQuery( this ).replaceWith( this.childNodes );=0A=
			}=0A=
		}).end();=0A=
	},=0A=
=0A=
	append: function() {=0A=
		return this.domManip(arguments, true, function( elem ) {=0A=
			if ( this.nodeType =3D=3D=3D 1 ) {=0A=
				this.appendChild( elem );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	prepend: function() {=0A=
		return this.domManip(arguments, true, function( elem ) {=0A=
			if ( this.nodeType =3D=3D=3D 1 ) {=0A=
				this.insertBefore( elem, this.firstChild );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	before: function() {=0A=
		if ( this[0] && this[0].parentNode ) {=0A=
			return this.domManip(arguments, false, function( elem ) {=0A=
				this.parentNode.insertBefore( elem, this );=0A=
			});=0A=
		} else if ( arguments.length ) {=0A=
			var set =3D jQuery(arguments[0]);=0A=
			set.push.apply( set, this.toArray() );=0A=
			return this.pushStack( set, "before", arguments );=0A=
		}=0A=
	},=0A=
=0A=
	after: function() {=0A=
		if ( this[0] && this[0].parentNode ) {=0A=
			return this.domManip(arguments, false, function( elem ) {=0A=
				this.parentNode.insertBefore( elem, this.nextSibling );=0A=
			});=0A=
		} else if ( arguments.length ) {=0A=
			var set =3D this.pushStack( this, "after", arguments );=0A=
			set.push.apply( set, jQuery(arguments[0]).toArray() );=0A=
			return set;=0A=
		}=0A=
	},=0A=
=0A=
	// keepData is for internal use only--do not document=0A=
	remove: function( selector, keepData ) {=0A=
		for ( var i =3D 0, elem; (elem =3D this[i]) !=3D null; i++ ) {=0A=
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {=0A=
				if ( !keepData && elem.nodeType =3D=3D=3D 1 ) {=0A=
					jQuery.cleanData( elem.getElementsByTagName("*") );=0A=
					jQuery.cleanData( [ elem ] );=0A=
				}=0A=
=0A=
				if ( elem.parentNode ) {=0A=
					elem.parentNode.removeChild( elem );=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	empty: function() {=0A=
		for ( var i =3D 0, elem; (elem =3D this[i]) !=3D null; i++ ) {=0A=
			// Remove element nodes and prevent memory leaks=0A=
			if ( elem.nodeType =3D=3D=3D 1 ) {=0A=
				jQuery.cleanData( elem.getElementsByTagName("*") );=0A=
			}=0A=
=0A=
			// Remove any remaining nodes=0A=
			while ( elem.firstChild ) {=0A=
				elem.removeChild( elem.firstChild );=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	clone: function( dataAndEvents, deepDataAndEvents ) {=0A=
		dataAndEvents =3D dataAndEvents =3D=3D null ? false : dataAndEvents;=0A=
		deepDataAndEvents =3D deepDataAndEvents =3D=3D null ? dataAndEvents : =
deepDataAndEvents;=0A=
=0A=
		return this.map( function () {=0A=
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );=0A=
		});=0A=
	},=0A=
=0A=
	html: function( value ) {=0A=
		if ( value =3D=3D=3D undefined ) {=0A=
			return this[0] && this[0].nodeType =3D=3D=3D 1 ?=0A=
				this[0].innerHTML.replace(rinlinejQuery, "") :=0A=
				null;=0A=
=0A=
		// See if we can take a shortcut and just use innerHTML=0A=
		} else if ( typeof value =3D=3D=3D "string" && !rnocache.test( value ) =
&&=0A=
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value =
)) &&=0A=
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {=0A=
=0A=
			value =3D value.replace(rxhtmlTag, "<$1></$2>");=0A=
=0A=
			try {=0A=
				for ( var i =3D 0, l =3D this.length; i < l; i++ ) {=0A=
					// Remove element nodes and prevent memory leaks=0A=
					if ( this[i].nodeType =3D=3D=3D 1 ) {=0A=
						jQuery.cleanData( this[i].getElementsByTagName("*") );=0A=
						this[i].innerHTML =3D value;=0A=
					}=0A=
				}=0A=
=0A=
			// If using innerHTML throws an exception, use the fallback method=0A=
			} catch(e) {=0A=
				this.empty().append( value );=0A=
			}=0A=
=0A=
		} else if ( jQuery.isFunction( value ) ) {=0A=
			this.each(function(i){=0A=
				var self =3D jQuery( this );=0A=
=0A=
				self.html( value.call(this, i, self.html()) );=0A=
			});=0A=
=0A=
		} else {=0A=
			this.empty().append( value );=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	replaceWith: function( value ) {=0A=
		if ( this[0] && this[0].parentNode ) {=0A=
			// Make sure that the elements are removed from the DOM before they =
are inserted=0A=
			// this can help fix replacing a parent with child elements=0A=
			if ( jQuery.isFunction( value ) ) {=0A=
				return this.each(function(i) {=0A=
					var self =3D jQuery(this), old =3D self.html();=0A=
					self.replaceWith( value.call( this, i, old ) );=0A=
				});=0A=
			}=0A=
=0A=
			if ( typeof value !=3D=3D "string" ) {=0A=
				value =3D jQuery( value ).detach();=0A=
			}=0A=
=0A=
			return this.each(function() {=0A=
				var next =3D this.nextSibling,=0A=
					parent =3D this.parentNode;=0A=
=0A=
				jQuery( this ).remove();=0A=
=0A=
				if ( next ) {=0A=
					jQuery(next).before( value );=0A=
				} else {=0A=
					jQuery(parent).append( value );=0A=
				}=0A=
			});=0A=
		} else {=0A=
			return this.length ?=0A=
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), =
"replaceWith", value ) :=0A=
				this;=0A=
		}=0A=
	},=0A=
=0A=
	detach: function( selector ) {=0A=
		return this.remove( selector, true );=0A=
	},=0A=
=0A=
	domManip: function( args, table, callback ) {=0A=
		var results, first, fragment, parent,=0A=
			value =3D args[0],=0A=
			scripts =3D [];=0A=
=0A=
		// We can't cloneNode fragments that contain checked, in WebKit=0A=
		if ( !jQuery.support.checkClone && arguments.length =3D=3D=3D 3 && =
typeof value =3D=3D=3D "string" && rchecked.test( value ) ) {=0A=
			return this.each(function() {=0A=
				jQuery(this).domManip( args, table, callback, true );=0A=
			});=0A=
		}=0A=
=0A=
		if ( jQuery.isFunction(value) ) {=0A=
			return this.each(function(i) {=0A=
				var self =3D jQuery(this);=0A=
				args[0] =3D value.call(this, i, table ? self.html() : undefined);=0A=
				self.domManip( args, table, callback );=0A=
			});=0A=
		}=0A=
=0A=
		if ( this[0] ) {=0A=
			parent =3D value && value.parentNode;=0A=
=0A=
			// If we're in a fragment, just use that instead of building a new one=0A=
			if ( jQuery.support.parentNode && parent && parent.nodeType =3D=3D=3D =
11 && parent.childNodes.length =3D=3D=3D this.length ) {=0A=
				results =3D { fragment: parent };=0A=
=0A=
			} else {=0A=
				results =3D jQuery.buildFragment( args, this, scripts );=0A=
			}=0A=
=0A=
			fragment =3D results.fragment;=0A=
=0A=
			if ( fragment.childNodes.length =3D=3D=3D 1 ) {=0A=
				first =3D fragment =3D fragment.firstChild;=0A=
			} else {=0A=
				first =3D fragment.firstChild;=0A=
			}=0A=
=0A=
			if ( first ) {=0A=
				table =3D table && jQuery.nodeName( first, "tr" );=0A=
=0A=
				for ( var i =3D 0, l =3D this.length, lastIndex =3D l - 1; i < l; =
i++ ) {=0A=
					callback.call(=0A=
						table ?=0A=
							root(this[i], first) :=0A=
							this[i],=0A=
						// Make sure that we do not leak memory by inadvertently discarding=0A=
						// the original fragment (which might have attached data) instead =
of=0A=
						// using it; in addition, use the original fragment object for the =
last=0A=
						// item instead of first because it can end up being emptied =
incorrectly=0A=
						// in certain situations (Bug #8070).=0A=
						// Fragments from the fragment cache must always be cloned and =
never used=0A=
						// in place.=0A=
						results.cacheable || (l > 1 && i < lastIndex) ?=0A=
							jQuery.clone( fragment, true, true ) :=0A=
							fragment=0A=
					);=0A=
				}=0A=
			}=0A=
=0A=
			if ( scripts.length ) {=0A=
				jQuery.each( scripts, evalScript );=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	}=0A=
});=0A=
=0A=
function root( elem, cur ) {=0A=
	return jQuery.nodeName(elem, "table") ?=0A=
		(elem.getElementsByTagName("tbody")[0] ||=0A=
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :=0A=
		elem;=0A=
}=0A=
=0A=
function cloneCopyEvent( src, dest ) {=0A=
=0A=
	if ( dest.nodeType !=3D=3D 1 || !jQuery.hasData( src ) ) {=0A=
		return;=0A=
	}=0A=
=0A=
	var internalKey =3D jQuery.expando,=0A=
		oldData =3D jQuery.data( src ),=0A=
		curData =3D jQuery.data( dest, oldData );=0A=
=0A=
	// Switch to use the internal data object, if it exists, for the next=0A=
	// stage of data copying=0A=
	if ( (oldData =3D oldData[ internalKey ]) ) {=0A=
		var events =3D oldData.events;=0A=
				curData =3D curData[ internalKey ] =3D jQuery.extend({}, oldData);=0A=
=0A=
		if ( events ) {=0A=
			delete curData.handle;=0A=
			curData.events =3D {};=0A=
=0A=
			for ( var type in events ) {=0A=
				for ( var i =3D 0, l =3D events[ type ].length; i < l; i++ ) {=0A=
					jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? =
"." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ =
type ][ i ].data );=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
}=0A=
=0A=
function cloneFixAttributes( src, dest ) {=0A=
	var nodeName;=0A=
=0A=
	// We do not need to do anything for non-Elements=0A=
	if ( dest.nodeType !=3D=3D 1 ) {=0A=
		return;=0A=
	}=0A=
=0A=
	// clearAttributes removes the attributes, which we don't want,=0A=
	// but also removes the attachEvent events, which we *do* want=0A=
	if ( dest.clearAttributes ) {=0A=
		dest.clearAttributes();=0A=
	}=0A=
=0A=
	// mergeAttributes, in contrast, only merges back on the=0A=
	// original attributes, not the events=0A=
	if ( dest.mergeAttributes ) {=0A=
		dest.mergeAttributes( src );=0A=
	}=0A=
=0A=
	nodeName =3D dest.nodeName.toLowerCase();=0A=
=0A=
	// IE6-8 fail to clone children inside object elements that use=0A=
	// the proprietary classid attribute value (rather than the type=0A=
	// attribute) to identify the type of content to display=0A=
	if ( nodeName =3D=3D=3D "object" ) {=0A=
		dest.outerHTML =3D src.outerHTML;=0A=
=0A=
	} else if ( nodeName =3D=3D=3D "input" && (src.type =3D=3D=3D =
"checkbox" || src.type =3D=3D=3D "radio") ) {=0A=
		// IE6-8 fails to persist the checked state of a cloned checkbox=0A=
		// or radio button. Worse, IE6-7 fail to give the cloned element=0A=
		// a checked appearance if the defaultChecked value isn't also set=0A=
		if ( src.checked ) {=0A=
			dest.defaultChecked =3D dest.checked =3D src.checked;=0A=
		}=0A=
=0A=
		// IE6-7 get confused and end up setting the value of a cloned=0A=
		// checkbox/radio button to an empty string instead of "on"=0A=
		if ( dest.value !=3D=3D src.value ) {=0A=
			dest.value =3D src.value;=0A=
		}=0A=
=0A=
	// IE6-8 fails to return the selected option to the default selected=0A=
	// state when cloning options=0A=
	} else if ( nodeName =3D=3D=3D "option" ) {=0A=
		dest.selected =3D src.defaultSelected;=0A=
=0A=
	// IE6-8 fails to set the defaultValue to the correct value when=0A=
	// cloning other types of input fields=0A=
	} else if ( nodeName =3D=3D=3D "input" || nodeName =3D=3D=3D "textarea" =
) {=0A=
		dest.defaultValue =3D src.defaultValue;=0A=
	}=0A=
=0A=
	// Event data gets referenced instead of copied if the expando=0A=
	// gets copied too=0A=
	dest.removeAttribute( jQuery.expando );=0A=
}=0A=
=0A=
jQuery.buildFragment =3D function( args, nodes, scripts ) {=0A=
	var fragment, cacheable, cacheresults, doc;=0A=
=0A=
  // nodes may contain either an explicit document object,=0A=
  // a jQuery collection or context object.=0A=
  // If nodes[0] contains a valid object to assign to doc=0A=
  if ( nodes && nodes[0] ) {=0A=
    doc =3D nodes[0].ownerDocument || nodes[0];=0A=
  }=0A=
=0A=
  // Ensure that an attr object doesn't incorrectly stand in as a =
document object=0A=
	// Chrome and Firefox seem to allow this to occur and will throw =
exception=0A=
	// Fixes #8950=0A=
	if ( !doc.createDocumentFragment ) {=0A=
		doc =3D document;=0A=
	}=0A=
=0A=
	// Only cache "small" (1/2 KB) HTML strings that are associated with =
the main document=0A=
	// Cloning options loses the selected state, so don't cache them=0A=
	// IE 6 doesn't like it when you put <object> or <embed> elements in a =
fragment=0A=
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so =
don't cache=0A=
	if ( args.length =3D=3D=3D 1 && typeof args[0] =3D=3D=3D "string" && =
args[0].length < 512 && doc =3D=3D=3D document &&=0A=
		args[0].charAt(0) =3D=3D=3D "<" && !rnocache.test( args[0] ) && =
(jQuery.support.checkClone || !rchecked.test( args[0] )) ) {=0A=
=0A=
		cacheable =3D true;=0A=
=0A=
		cacheresults =3D jQuery.fragments[ args[0] ];=0A=
		if ( cacheresults && cacheresults !=3D=3D 1 ) {=0A=
			fragment =3D cacheresults;=0A=
		}=0A=
	}=0A=
=0A=
	if ( !fragment ) {=0A=
		fragment =3D doc.createDocumentFragment();=0A=
		jQuery.clean( args, doc, fragment, scripts );=0A=
	}=0A=
=0A=
	if ( cacheable ) {=0A=
		jQuery.fragments[ args[0] ] =3D cacheresults ? fragment : 1;=0A=
	}=0A=
=0A=
	return { fragment: fragment, cacheable: cacheable };=0A=
};=0A=
=0A=
jQuery.fragments =3D {};=0A=
=0A=
jQuery.each({=0A=
	appendTo: "append",=0A=
	prependTo: "prepend",=0A=
	insertBefore: "before",=0A=
	insertAfter: "after",=0A=
	replaceAll: "replaceWith"=0A=
}, function( name, original ) {=0A=
	jQuery.fn[ name ] =3D function( selector ) {=0A=
		var ret =3D [],=0A=
			insert =3D jQuery( selector ),=0A=
			parent =3D this.length =3D=3D=3D 1 && this[0].parentNode;=0A=
=0A=
		if ( parent && parent.nodeType =3D=3D=3D 11 && =
parent.childNodes.length =3D=3D=3D 1 && insert.length =3D=3D=3D 1 ) {=0A=
			insert[ original ]( this[0] );=0A=
			return this;=0A=
=0A=
		} else {=0A=
			for ( var i =3D 0, l =3D insert.length; i < l; i++ ) {=0A=
				var elems =3D (i > 0 ? this.clone(true) : this).get();=0A=
				jQuery( insert[i] )[ original ]( elems );=0A=
				ret =3D ret.concat( elems );=0A=
			}=0A=
=0A=
			return this.pushStack( ret, name, insert.selector );=0A=
		}=0A=
	};=0A=
});=0A=
=0A=
function getAll( elem ) {=0A=
	if ( "getElementsByTagName" in elem ) {=0A=
		return elem.getElementsByTagName( "*" );=0A=
=0A=
	} else if ( "querySelectorAll" in elem ) {=0A=
		return elem.querySelectorAll( "*" );=0A=
=0A=
	} else {=0A=
		return [];=0A=
	}=0A=
}=0A=
=0A=
// Used in clean, fixes the defaultChecked property=0A=
function fixDefaultChecked( elem ) {=0A=
	if ( elem.type =3D=3D=3D "checkbox" || elem.type =3D=3D=3D "radio" ) {=0A=
		elem.defaultChecked =3D elem.checked;=0A=
	}=0A=
}=0A=
// Finds all inputs and passes them to fixDefaultChecked=0A=
function findInputs( elem ) {=0A=
	if ( jQuery.nodeName( elem, "input" ) ) {=0A=
		fixDefaultChecked( elem );=0A=
	} else if ( "getElementsByTagName" in elem ) {=0A=
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );=0A=
	}=0A=
}=0A=
=0A=
jQuery.extend({=0A=
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {=0A=
		var clone =3D elem.cloneNode(true),=0A=
				srcElements,=0A=
				destElements,=0A=
				i;=0A=
=0A=
		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) =
&&=0A=
				(elem.nodeType =3D=3D=3D 1 || elem.nodeType =3D=3D=3D 11) && =
!jQuery.isXMLDoc(elem) ) {=0A=
			// IE copies events bound via attachEvent when using cloneNode.=0A=
			// Calling detachEvent on the clone will also remove the events=0A=
			// from the original. In order to get around this, we use some=0A=
			// proprietary methods to clear the events. Thanks to MooTools=0A=
			// guys for this hotness.=0A=
=0A=
			cloneFixAttributes( elem, clone );=0A=
=0A=
			// Using Sizzle here is crazy slow, so we use getElementsByTagName=0A=
			// instead=0A=
			srcElements =3D getAll( elem );=0A=
			destElements =3D getAll( clone );=0A=
=0A=
			// Weird iteration because IE will replace the length property=0A=
			// with an element if you are cloning the body and one of the=0A=
			// elements on the page has a name or id of "length"=0A=
			for ( i =3D 0; srcElements[i]; ++i ) {=0A=
				cloneFixAttributes( srcElements[i], destElements[i] );=0A=
			}=0A=
		}=0A=
=0A=
		// Copy the events from the original to the clone=0A=
		if ( dataAndEvents ) {=0A=
			cloneCopyEvent( elem, clone );=0A=
=0A=
			if ( deepDataAndEvents ) {=0A=
				srcElements =3D getAll( elem );=0A=
				destElements =3D getAll( clone );=0A=
=0A=
				for ( i =3D 0; srcElements[i]; ++i ) {=0A=
					cloneCopyEvent( srcElements[i], destElements[i] );=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		srcElements =3D destElements =3D null;=0A=
=0A=
		// Return the cloned set=0A=
		return clone;=0A=
	},=0A=
=0A=
	clean: function( elems, context, fragment, scripts ) {=0A=
		var checkScriptType;=0A=
=0A=
		context =3D context || document;=0A=
=0A=
		// !context.createElement fails in IE with an error but returns typeof =
'object'=0A=
		if ( typeof context.createElement =3D=3D=3D "undefined" ) {=0A=
			context =3D context.ownerDocument || context[0] && =
context[0].ownerDocument || document;=0A=
		}=0A=
=0A=
		var ret =3D [], j;=0A=
=0A=
		for ( var i =3D 0, elem; (elem =3D elems[i]) !=3D null; i++ ) {=0A=
			if ( typeof elem =3D=3D=3D "number" ) {=0A=
				elem +=3D "";=0A=
			}=0A=
=0A=
			if ( !elem ) {=0A=
				continue;=0A=
			}=0A=
=0A=
			// Convert html string into DOM nodes=0A=
			if ( typeof elem =3D=3D=3D "string" ) {=0A=
				if ( !rhtml.test( elem ) ) {=0A=
					elem =3D context.createTextNode( elem );=0A=
				} else {=0A=
					// Fix "XHTML"-style tags in all browsers=0A=
					elem =3D elem.replace(rxhtmlTag, "<$1></$2>");=0A=
=0A=
					// Trim whitespace, otherwise indexOf won't work as expected=0A=
					var tag =3D (rtagName.exec( elem ) || ["", ""])[1].toLowerCase(),=0A=
						wrap =3D wrapMap[ tag ] || wrapMap._default,=0A=
						depth =3D wrap[0],=0A=
						div =3D context.createElement("div");=0A=
=0A=
					// Go to html and back, then peel off extra wrappers=0A=
					div.innerHTML =3D wrap[1] + elem + wrap[2];=0A=
=0A=
					// Move to the right depth=0A=
					while ( depth-- ) {=0A=
						div =3D div.lastChild;=0A=
					}=0A=
=0A=
					// Remove IE's autoinserted <tbody> from table fragments=0A=
					if ( !jQuery.support.tbody ) {=0A=
=0A=
						// String was a <table>, *may* have spurious <tbody>=0A=
						var hasBody =3D rtbody.test(elem),=0A=
							tbody =3D tag =3D=3D=3D "table" && !hasBody ?=0A=
								div.firstChild && div.firstChild.childNodes :=0A=
=0A=
								// String was a bare <thead> or <tfoot>=0A=
								wrap[1] =3D=3D=3D "<table>" && !hasBody ?=0A=
									div.childNodes :=0A=
									[];=0A=
=0A=
						for ( j =3D tbody.length - 1; j >=3D 0 ; --j ) {=0A=
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j =
].childNodes.length ) {=0A=
								tbody[ j ].parentNode.removeChild( tbody[ j ] );=0A=
							}=0A=
						}=0A=
					}=0A=
=0A=
					// IE completely kills leading whitespace when innerHTML is used=0A=
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( =
elem ) ) {=0A=
						div.insertBefore( context.createTextNode( =
rleadingWhitespace.exec(elem)[0] ), div.firstChild );=0A=
					}=0A=
=0A=
					elem =3D div.childNodes;=0A=
				}=0A=
			}=0A=
=0A=
			// Resets defaultChecked for any radios and checkboxes=0A=
			// about to be appended to the DOM in IE 6/7 (#8060)=0A=
			var len;=0A=
			if ( !jQuery.support.appendChecked ) {=0A=
				if ( elem[0] && typeof (len =3D elem.length) =3D=3D=3D "number" ) {=0A=
					for ( j =3D 0; j < len; j++ ) {=0A=
						findInputs( elem[j] );=0A=
					}=0A=
				} else {=0A=
					findInputs( elem );=0A=
				}=0A=
			}=0A=
=0A=
			if ( elem.nodeType ) {=0A=
				ret.push( elem );=0A=
			} else {=0A=
				ret =3D jQuery.merge( ret, elem );=0A=
			}=0A=
		}=0A=
=0A=
		if ( fragment ) {=0A=
			checkScriptType =3D function( elem ) {=0A=
				return !elem.type || rscriptType.test( elem.type );=0A=
			};=0A=
			for ( i =3D 0; ret[i]; i++ ) {=0A=
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type =
|| ret[i].type.toLowerCase() =3D=3D=3D "text/javascript") ) {=0A=
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( =
ret[i] ) : ret[i] );=0A=
=0A=
				} else {=0A=
					if ( ret[i].nodeType =3D=3D=3D 1 ) {=0A=
						var jsTags =3D jQuery.grep( ret[i].getElementsByTagName( "script" =
), checkScriptType );=0A=
=0A=
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );=0A=
					}=0A=
					fragment.appendChild( ret[i] );=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return ret;=0A=
	},=0A=
=0A=
	cleanData: function( elems ) {=0A=
		var data, id, cache =3D jQuery.cache, internalKey =3D jQuery.expando, =
special =3D jQuery.event.special,=0A=
			deleteExpando =3D jQuery.support.deleteExpando;=0A=
=0A=
		for ( var i =3D 0, elem; (elem =3D elems[i]) !=3D null; i++ ) {=0A=
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {=0A=
				continue;=0A=
			}=0A=
=0A=
			id =3D elem[ jQuery.expando ];=0A=
=0A=
			if ( id ) {=0A=
				data =3D cache[ id ] && cache[ id ][ internalKey ];=0A=
=0A=
				if ( data && data.events ) {=0A=
					for ( var type in data.events ) {=0A=
						if ( special[ type ] ) {=0A=
							jQuery.event.remove( elem, type );=0A=
=0A=
						// This is a shortcut to avoid jQuery.event.remove's overhead=0A=
						} else {=0A=
							jQuery.removeEvent( elem, type, data.handle );=0A=
						}=0A=
					}=0A=
=0A=
					// Null the DOM reference to avoid IE6/7/8 leak (#7054)=0A=
					if ( data.handle ) {=0A=
						data.handle.elem =3D null;=0A=
					}=0A=
				}=0A=
=0A=
				if ( deleteExpando ) {=0A=
					delete elem[ jQuery.expando ];=0A=
=0A=
				} else if ( elem.removeAttribute ) {=0A=
					elem.removeAttribute( jQuery.expando );=0A=
				}=0A=
=0A=
				delete cache[ id ];=0A=
			}=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
function evalScript( i, elem ) {=0A=
	if ( elem.src ) {=0A=
		jQuery.ajax({=0A=
			url: elem.src,=0A=
			async: false,=0A=
			dataType: "script"=0A=
		});=0A=
	} else {=0A=
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML =
|| "" ).replace( rcleanScript, "/*$0*/" ) );=0A=
	}=0A=
=0A=
	if ( elem.parentNode ) {=0A=
		elem.parentNode.removeChild( elem );=0A=
	}=0A=
}=0A=
=0A=
=0A=
=0A=
var ralpha =3D /alpha\([^)]*\)/i,=0A=
	ropacity =3D /opacity=3D([^)]*)/,=0A=
	// fixed for IE9, see #8346=0A=
	rupper =3D /([A-Z]|^ms)/g,=0A=
	rnumpx =3D /^-?\d+(?:px)?$/i,=0A=
	rnum =3D /^-?\d/,=0A=
	rrelNum =3D /^[+\-]=3D/,=0A=
	rrelNumFilter =3D /[^+\-\.\de]+/g,=0A=
=0A=
	cssShow =3D { position: "absolute", visibility: "hidden", display: =
"block" },=0A=
	cssWidth =3D [ "Left", "Right" ],=0A=
	cssHeight =3D [ "Top", "Bottom" ],=0A=
	curCSS,=0A=
=0A=
	getComputedStyle,=0A=
	currentStyle;=0A=
=0A=
jQuery.fn.css =3D function( name, value ) {=0A=
	// Setting 'undefined' is a no-op=0A=
	if ( arguments.length =3D=3D=3D 2 && value =3D=3D=3D undefined ) {=0A=
		return this;=0A=
	}=0A=
=0A=
	return jQuery.access( this, name, value, true, function( elem, name, =
value ) {=0A=
		return value !=3D=3D undefined ?=0A=
			jQuery.style( elem, name, value ) :=0A=
			jQuery.css( elem, name );=0A=
	});=0A=
};=0A=
=0A=
jQuery.extend({=0A=
	// Add in style property hooks for overriding the default=0A=
	// behavior of getting and setting a style property=0A=
	cssHooks: {=0A=
		opacity: {=0A=
			get: function( elem, computed ) {=0A=
				if ( computed ) {=0A=
					// We should always get a number back from opacity=0A=
					var ret =3D curCSS( elem, "opacity", "opacity" );=0A=
					return ret =3D=3D=3D "" ? "1" : ret;=0A=
=0A=
				} else {=0A=
					return elem.style.opacity;=0A=
				}=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	// Exclude the following css properties to add px=0A=
	cssNumber: {=0A=
		"fillOpacity": true,=0A=
		"fontWeight": true,=0A=
		"lineHeight": true,=0A=
		"opacity": true,=0A=
		"orphans": true,=0A=
		"widows": true,=0A=
		"zIndex": true,=0A=
		"zoom": true=0A=
	},=0A=
=0A=
	// Add in properties whose names you wish to fix before=0A=
	// setting or getting the value=0A=
	cssProps: {=0A=
		// normalize float css property=0A=
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"=0A=
	},=0A=
=0A=
	// Get and set the style property on a DOM Node=0A=
	style: function( elem, name, value, extra ) {=0A=
		// Don't set styles on text and comment nodes=0A=
		if ( !elem || elem.nodeType =3D=3D=3D 3 || elem.nodeType =3D=3D=3D 8 =
|| !elem.style ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Make sure that we're working with the right name=0A=
		var ret, type, origName =3D jQuery.camelCase( name ),=0A=
			style =3D elem.style, hooks =3D jQuery.cssHooks[ origName ];=0A=
=0A=
		name =3D jQuery.cssProps[ origName ] || origName;=0A=
=0A=
		// Check if we're setting a value=0A=
		if ( value !=3D=3D undefined ) {=0A=
			type =3D typeof value;=0A=
=0A=
			// Make sure that NaN and null values aren't set. See: #7116=0A=
			if ( type =3D=3D=3D "number" && isNaN( value ) || value =3D=3D null ) =
{=0A=
				return;=0A=
			}=0A=
=0A=
			// convert relative number strings (+=3D or -=3D) to relative =
numbers. #7345=0A=
			if ( type =3D=3D=3D "string" && rrelNum.test( value ) ) {=0A=
				value =3D +value.replace( rrelNumFilter, "" ) + parseFloat( =
jQuery.css( elem, name ) );=0A=
				// Fixes bug #9237=0A=
				type =3D "number";=0A=
			}=0A=
=0A=
			// If a number was passed in, add 'px' to the (except for certain CSS =
properties)=0A=
			if ( type =3D=3D=3D "number" && !jQuery.cssNumber[ origName ] ) {=0A=
				value +=3D "px";=0A=
			}=0A=
=0A=
			// If a hook was provided, use that value, otherwise just set the =
specified value=0A=
			if ( !hooks || !("set" in hooks) || (value =3D hooks.set( elem, value =
)) !=3D=3D undefined ) {=0A=
				// Wrapped to prevent IE from throwing errors when 'invalid' values =
are provided=0A=
				// Fixes bug #5509=0A=
				try {=0A=
					style[ name ] =3D value;=0A=
				} catch(e) {}=0A=
			}=0A=
=0A=
		} else {=0A=
			// If a hook was provided get the non-computed value from there=0A=
			if ( hooks && "get" in hooks && (ret =3D hooks.get( elem, false, =
extra )) !=3D=3D undefined ) {=0A=
				return ret;=0A=
			}=0A=
=0A=
			// Otherwise just get the value from the style object=0A=
			return style[ name ];=0A=
		}=0A=
	},=0A=
=0A=
	css: function( elem, name, extra ) {=0A=
		var ret, hooks;=0A=
=0A=
		// Make sure that we're working with the right name=0A=
		name =3D jQuery.camelCase( name );=0A=
		hooks =3D jQuery.cssHooks[ name ];=0A=
		name =3D jQuery.cssProps[ name ] || name;=0A=
=0A=
		// cssFloat needs a special treatment=0A=
		if ( name =3D=3D=3D "cssFloat" ) {=0A=
			name =3D "float";=0A=
		}=0A=
=0A=
		// If a hook was provided get the computed value from there=0A=
		if ( hooks && "get" in hooks && (ret =3D hooks.get( elem, true, extra =
)) !=3D=3D undefined ) {=0A=
			return ret;=0A=
=0A=
		// Otherwise, if a way to get the computed value exists, use that=0A=
		} else if ( curCSS ) {=0A=
			return curCSS( elem, name );=0A=
		}=0A=
	},=0A=
=0A=
	// A method for quickly swapping in/out CSS properties to get correct =
calculations=0A=
	swap: function( elem, options, callback ) {=0A=
		var old =3D {};=0A=
=0A=
		// Remember the old values, and insert the new ones=0A=
		for ( var name in options ) {=0A=
			old[ name ] =3D elem.style[ name ];=0A=
			elem.style[ name ] =3D options[ name ];=0A=
		}=0A=
=0A=
		callback.call( elem );=0A=
=0A=
		// Revert the old values=0A=
		for ( name in options ) {=0A=
			elem.style[ name ] =3D old[ name ];=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
// DEPRECATED, Use jQuery.css() instead=0A=
jQuery.curCSS =3D jQuery.css;=0A=
=0A=
jQuery.each(["height", "width"], function( i, name ) {=0A=
	jQuery.cssHooks[ name ] =3D {=0A=
		get: function( elem, computed, extra ) {=0A=
			var val;=0A=
=0A=
			if ( computed ) {=0A=
				if ( elem.offsetWidth !=3D=3D 0 ) {=0A=
					return getWH( elem, name, extra );=0A=
				} else {=0A=
					jQuery.swap( elem, cssShow, function() {=0A=
						val =3D getWH( elem, name, extra );=0A=
					});=0A=
				}=0A=
=0A=
				return val;=0A=
			}=0A=
		},=0A=
=0A=
		set: function( elem, value ) {=0A=
			if ( rnumpx.test( value ) ) {=0A=
				// ignore negative width and height values #1599=0A=
				value =3D parseFloat( value );=0A=
=0A=
				if ( value >=3D 0 ) {=0A=
					return value + "px";=0A=
				}=0A=
=0A=
			} else {=0A=
				return value;=0A=
			}=0A=
		}=0A=
	};=0A=
});=0A=
=0A=
if ( !jQuery.support.opacity ) {=0A=
	jQuery.cssHooks.opacity =3D {=0A=
		get: function( elem, computed ) {=0A=
			// IE uses filters for opacity=0A=
			return ropacity.test( (computed && elem.currentStyle ? =
elem.currentStyle.filter : elem.style.filter) || "" ) ?=0A=
				( parseFloat( RegExp.$1 ) / 100 ) + "" :=0A=
				computed ? "1" : "";=0A=
		},=0A=
=0A=
		set: function( elem, value ) {=0A=
			var style =3D elem.style,=0A=
				currentStyle =3D elem.currentStyle;=0A=
=0A=
			// IE has trouble with opacity if it does not have layout=0A=
			// Force it by setting the zoom level=0A=
			style.zoom =3D 1;=0A=
=0A=
			// Set the alpha filter to set the opacity=0A=
			var opacity =3D jQuery.isNaN( value ) ?=0A=
				"" :=0A=
				"alpha(opacity=3D" + value * 100 + ")",=0A=
				filter =3D currentStyle && currentStyle.filter || style.filter || "";=0A=
=0A=
			style.filter =3D ralpha.test( filter ) ?=0A=
				filter.replace( ralpha, opacity ) :=0A=
				filter + " " + opacity;=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
jQuery(function() {=0A=
	// This hook cannot be added until DOM ready because the support test=0A=
	// for it is not run until after DOM ready=0A=
	if ( !jQuery.support.reliableMarginRight ) {=0A=
		jQuery.cssHooks.marginRight =3D {=0A=
			get: function( elem, computed ) {=0A=
				// WebKit Bug 13343 - getComputedStyle returns wrong value for =
margin-right=0A=
				// Work around by temporarily setting element display to inline-block=0A=
				var ret;=0A=
				jQuery.swap( elem, { "display": "inline-block" }, function() {=0A=
					if ( computed ) {=0A=
						ret =3D curCSS( elem, "margin-right", "marginRight" );=0A=
					} else {=0A=
						ret =3D elem.style.marginRight;=0A=
					}=0A=
				});=0A=
				return ret;=0A=
			}=0A=
		};=0A=
	}=0A=
});=0A=
=0A=
if ( document.defaultView && document.defaultView.getComputedStyle ) {=0A=
	getComputedStyle =3D function( elem, name ) {=0A=
		var ret, defaultView, computedStyle;=0A=
=0A=
		name =3D name.replace( rupper, "-$1" ).toLowerCase();=0A=
=0A=
		if ( !(defaultView =3D elem.ownerDocument.defaultView) ) {=0A=
			return undefined;=0A=
		}=0A=
=0A=
		if ( (computedStyle =3D defaultView.getComputedStyle( elem, null )) ) {=0A=
			ret =3D computedStyle.getPropertyValue( name );=0A=
			if ( ret =3D=3D=3D "" && !jQuery.contains( =
elem.ownerDocument.documentElement, elem ) ) {=0A=
				ret =3D jQuery.style( elem, name );=0A=
			}=0A=
		}=0A=
=0A=
		return ret;=0A=
	};=0A=
}=0A=
=0A=
if ( document.documentElement.currentStyle ) {=0A=
	currentStyle =3D function( elem, name ) {=0A=
		var left,=0A=
			ret =3D elem.currentStyle && elem.currentStyle[ name ],=0A=
			rsLeft =3D elem.runtimeStyle && elem.runtimeStyle[ name ],=0A=
			style =3D elem.style;=0A=
=0A=
		// From the awesome hack by Dean Edwards=0A=
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291=0A=
=0A=
		// If we're not dealing with a regular pixel number=0A=
		// but a number that has a weird ending, we need to convert it to =
pixels=0A=
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {=0A=
			// Remember the original values=0A=
			left =3D style.left;=0A=
=0A=
			// Put in the new values to get a computed value out=0A=
			if ( rsLeft ) {=0A=
				elem.runtimeStyle.left =3D elem.currentStyle.left;=0A=
			}=0A=
			style.left =3D name =3D=3D=3D "fontSize" ? "1em" : (ret || 0);=0A=
			ret =3D style.pixelLeft + "px";=0A=
=0A=
			// Revert the changed values=0A=
			style.left =3D left;=0A=
			if ( rsLeft ) {=0A=
				elem.runtimeStyle.left =3D rsLeft;=0A=
			}=0A=
		}=0A=
=0A=
		return ret =3D=3D=3D "" ? "auto" : ret;=0A=
	};=0A=
}=0A=
=0A=
curCSS =3D getComputedStyle || currentStyle;=0A=
=0A=
function getWH( elem, name, extra ) {=0A=
=0A=
	// Start with offset property=0A=
	var val =3D name =3D=3D=3D "width" ? elem.offsetWidth : =
elem.offsetHeight,=0A=
		which =3D name =3D=3D=3D "width" ? cssWidth : cssHeight;=0A=
=0A=
	if ( val > 0 ) {=0A=
		if ( extra !=3D=3D "border" ) {=0A=
			jQuery.each( which, function() {=0A=
				if ( !extra ) {=0A=
					val -=3D parseFloat( jQuery.css( elem, "padding" + this ) ) || 0;=0A=
				}=0A=
				if ( extra =3D=3D=3D "margin" ) {=0A=
					val +=3D parseFloat( jQuery.css( elem, extra + this ) ) || 0;=0A=
				} else {=0A=
					val -=3D parseFloat( jQuery.css( elem, "border" + this + "Width" ) =
) || 0;=0A=
				}=0A=
			});=0A=
		}=0A=
=0A=
		return val + "px";=0A=
	}=0A=
=0A=
	// Fall back to computed then uncomputed css if necessary=0A=
	val =3D curCSS( elem, name, name );=0A=
	if ( val < 0 || val =3D=3D null ) {=0A=
		val =3D elem.style[ name ] || 0;=0A=
	}=0A=
	// Normalize "", auto, and prepare for extra=0A=
	val =3D parseFloat( val ) || 0;=0A=
=0A=
	// Add padding, border, margin=0A=
	if ( extra ) {=0A=
		jQuery.each( which, function() {=0A=
			val +=3D parseFloat( jQuery.css( elem, "padding" + this ) ) || 0;=0A=
			if ( extra !=3D=3D "padding" ) {=0A=
				val +=3D parseFloat( jQuery.css( elem, "border" + this + "Width" ) ) =
|| 0;=0A=
			}=0A=
			if ( extra =3D=3D=3D "margin" ) {=0A=
				val +=3D parseFloat( jQuery.css( elem, extra + this ) ) || 0;=0A=
			}=0A=
		});=0A=
	}=0A=
=0A=
	return val + "px";=0A=
}=0A=
=0A=
if ( jQuery.expr && jQuery.expr.filters ) {=0A=
	jQuery.expr.filters.hidden =3D function( elem ) {=0A=
		var width =3D elem.offsetWidth,=0A=
			height =3D elem.offsetHeight;=0A=
=0A=
		return (width =3D=3D=3D 0 && height =3D=3D=3D 0) || =
(!jQuery.support.reliableHiddenOffsets && (elem.style.display || =
jQuery.css( elem, "display" )) =3D=3D=3D "none");=0A=
	};=0A=
=0A=
	jQuery.expr.filters.visible =3D function( elem ) {=0A=
		return !jQuery.expr.filters.hidden( elem );=0A=
	};=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
var r20 =3D /%20/g,=0A=
	rbracket =3D /\[\]$/,=0A=
	rCRLF =3D /\r?\n/g,=0A=
	rhash =3D /#.*$/,=0A=
	rheaders =3D /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r =
character at EOL=0A=
	rinput =3D =
/^(?:color|date|datetime|email|hidden|month|number|password|range|search|=
tel|text|time|url|week)$/i,=0A=
	// #7653, #8125, #8152: local protocol detection=0A=
	rlocalProtocol =3D =
/^(?:about|app|app\-storage|.+\-extension|file|widget):$/,=0A=
	rnoContent =3D /^(?:GET|HEAD)$/,=0A=
	rprotocol =3D /^\/\//,=0A=
	rquery =3D /\?/,=0A=
	rscript =3D /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,=0A=
	rselectTextarea =3D /^(?:select|textarea)/i,=0A=
	rspacesAjax =3D /\s+/,=0A=
	rts =3D /([?&])_=3D[^&]*/,=0A=
	rurl =3D /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,=0A=
=0A=
	// Keep a copy of the old load method=0A=
	_load =3D jQuery.fn.load,=0A=
=0A=
	/* Prefilters=0A=
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js =
for an example)=0A=
	 * 2) These are called:=0A=
	 *    - BEFORE asking for a transport=0A=
	 *    - AFTER param serialization (s.data is a string if s.processData =
is true)=0A=
	 * 3) key is the dataType=0A=
	 * 4) the catchall symbol "*" can be used=0A=
	 * 5) execution will start with transport dataType and THEN continue =
down to "*" if needed=0A=
	 */=0A=
	prefilters =3D {},=0A=
=0A=
	/* Transports bindings=0A=
	 * 1) key is the dataType=0A=
	 * 2) the catchall symbol "*" can be used=0A=
	 * 3) selection will start with transport dataType and THEN go to "*" =
if needed=0A=
	 */=0A=
	transports =3D {},=0A=
=0A=
	// Document location=0A=
	ajaxLocation,=0A=
=0A=
	// Document location segments=0A=
	ajaxLocParts;=0A=
=0A=
// #8138, IE may throw an exception when accessing=0A=
// a field from window.location if document.domain has been set=0A=
try {=0A=
	ajaxLocation =3D location.href;=0A=
} catch( e ) {=0A=
	// Use the href attribute of an A element=0A=
	// since IE will modify it given document.location=0A=
	ajaxLocation =3D document.createElement( "a" );=0A=
	ajaxLocation.href =3D "";=0A=
	ajaxLocation =3D ajaxLocation.href;=0A=
}=0A=
=0A=
// Segment location into parts=0A=
ajaxLocParts =3D rurl.exec( ajaxLocation.toLowerCase() ) || [];=0A=
=0A=
// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport=0A=
function addToPrefiltersOrTransports( structure ) {=0A=
=0A=
	// dataTypeExpression is optional and defaults to "*"=0A=
	return function( dataTypeExpression, func ) {=0A=
=0A=
		if ( typeof dataTypeExpression !=3D=3D "string" ) {=0A=
			func =3D dataTypeExpression;=0A=
			dataTypeExpression =3D "*";=0A=
		}=0A=
=0A=
		if ( jQuery.isFunction( func ) ) {=0A=
			var dataTypes =3D dataTypeExpression.toLowerCase().split( rspacesAjax =
),=0A=
				i =3D 0,=0A=
				length =3D dataTypes.length,=0A=
				dataType,=0A=
				list,=0A=
				placeBefore;=0A=
=0A=
			// For each dataType in the dataTypeExpression=0A=
			for(; i < length; i++ ) {=0A=
				dataType =3D dataTypes[ i ];=0A=
				// We control if we're asked to add before=0A=
				// any existing element=0A=
				placeBefore =3D /^\+/.test( dataType );=0A=
				if ( placeBefore ) {=0A=
					dataType =3D dataType.substr( 1 ) || "*";=0A=
				}=0A=
				list =3D structure[ dataType ] =3D structure[ dataType ] || [];=0A=
				// then we add to the structure accordingly=0A=
				list[ placeBefore ? "unshift" : "push" ]( func );=0A=
			}=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
// Base inspection function for prefilters and transports=0A=
function inspectPrefiltersOrTransports( structure, options, =
originalOptions, jqXHR,=0A=
		dataType /* internal */, inspected /* internal */ ) {=0A=
=0A=
	dataType =3D dataType || options.dataTypes[ 0 ];=0A=
	inspected =3D inspected || {};=0A=
=0A=
	inspected[ dataType ] =3D true;=0A=
=0A=
	var list =3D structure[ dataType ],=0A=
		i =3D 0,=0A=
		length =3D list ? list.length : 0,=0A=
		executeOnly =3D ( structure =3D=3D=3D prefilters ),=0A=
		selection;=0A=
=0A=
	for(; i < length && ( executeOnly || !selection ); i++ ) {=0A=
		selection =3D list[ i ]( options, originalOptions, jqXHR );=0A=
		// If we got redirected to another dataType=0A=
		// we try there if executing only and not done already=0A=
		if ( typeof selection =3D=3D=3D "string" ) {=0A=
			if ( !executeOnly || inspected[ selection ] ) {=0A=
				selection =3D undefined;=0A=
			} else {=0A=
				options.dataTypes.unshift( selection );=0A=
				selection =3D inspectPrefiltersOrTransports(=0A=
						structure, options, originalOptions, jqXHR, selection, inspected );=0A=
			}=0A=
		}=0A=
	}=0A=
	// If we're only executing or nothing was selected=0A=
	// we try the catchall dataType if not done already=0A=
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {=0A=
		selection =3D inspectPrefiltersOrTransports(=0A=
				structure, options, originalOptions, jqXHR, "*", inspected );=0A=
	}=0A=
	// unnecessary when only executing (prefilters)=0A=
	// but it'll be ignored by the caller in that case=0A=
	return selection;=0A=
}=0A=
=0A=
jQuery.fn.extend({=0A=
	load: function( url, params, callback ) {=0A=
		if ( typeof url !=3D=3D "string" && _load ) {=0A=
			return _load.apply( this, arguments );=0A=
=0A=
		// Don't do a request if no elements are being requested=0A=
		} else if ( !this.length ) {=0A=
			return this;=0A=
		}=0A=
=0A=
		var off =3D url.indexOf( " " );=0A=
		if ( off >=3D 0 ) {=0A=
			var selector =3D url.slice( off, url.length );=0A=
			url =3D url.slice( 0, off );=0A=
		}=0A=
=0A=
		// Default to a GET request=0A=
		var type =3D "GET";=0A=
=0A=
		// If the second parameter was provided=0A=
		if ( params ) {=0A=
			// If it's a function=0A=
			if ( jQuery.isFunction( params ) ) {=0A=
				// We assume that it's the callback=0A=
				callback =3D params;=0A=
				params =3D undefined;=0A=
=0A=
			// Otherwise, build a param string=0A=
			} else if ( typeof params =3D=3D=3D "object" ) {=0A=
				params =3D jQuery.param( params, jQuery.ajaxSettings.traditional );=0A=
				type =3D "POST";=0A=
			}=0A=
		}=0A=
=0A=
		var self =3D this;=0A=
=0A=
		// Request the remote document=0A=
		jQuery.ajax({=0A=
			url: url,=0A=
			type: type,=0A=
			dataType: "html",=0A=
			data: params,=0A=
			// Complete callback (responseText is used internally)=0A=
			complete: function( jqXHR, status, responseText ) {=0A=
				// Store the response as specified by the jqXHR object=0A=
				responseText =3D jqXHR.responseText;=0A=
				// If successful, inject the HTML into all the matched elements=0A=
				if ( jqXHR.isResolved() ) {=0A=
					// #4825: Get the actual response in case=0A=
					// a dataFilter is present in ajaxSettings=0A=
					jqXHR.done(function( r ) {=0A=
						responseText =3D r;=0A=
					});=0A=
					// See if a selector was specified=0A=
					self.html( selector ?=0A=
						// Create a dummy div to hold the results=0A=
						jQuery("<div>")=0A=
							// inject the contents of the document in, removing the scripts=0A=
							// to avoid any 'Permission Denied' errors in IE=0A=
							.append(responseText.replace(rscript, ""))=0A=
=0A=
							// Locate the specified elements=0A=
							.find(selector) :=0A=
=0A=
						// If not, just inject the full result=0A=
						responseText );=0A=
				}=0A=
=0A=
				if ( callback ) {=0A=
					self.each( callback, [ responseText, status, jqXHR ] );=0A=
				}=0A=
			}=0A=
		});=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	serialize: function() {=0A=
		return jQuery.param( this.serializeArray() );=0A=
	},=0A=
=0A=
	serializeArray: function() {=0A=
		return this.map(function(){=0A=
			return this.elements ? jQuery.makeArray( this.elements ) : this;=0A=
		})=0A=
		.filter(function(){=0A=
			return this.name && !this.disabled &&=0A=
				( this.checked || rselectTextarea.test( this.nodeName ) ||=0A=
					rinput.test( this.type ) );=0A=
		})=0A=
		.map(function( i, elem ){=0A=
			var val =3D jQuery( this ).val();=0A=
=0A=
			return val =3D=3D null ?=0A=
				null :=0A=
				jQuery.isArray( val ) ?=0A=
					jQuery.map( val, function( val, i ){=0A=
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };=0A=
					}) :=0A=
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };=0A=
		}).get();=0A=
	}=0A=
});=0A=
=0A=
// Attach a bunch of functions for handling common AJAX events=0A=
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess =
ajaxSend".split( " " ), function( i, o ){=0A=
	jQuery.fn[ o ] =3D function( f ){=0A=
		return this.bind( o, f );=0A=
	};=0A=
});=0A=
=0A=
jQuery.each( [ "get", "post" ], function( i, method ) {=0A=
	jQuery[ method ] =3D function( url, data, callback, type ) {=0A=
		// shift arguments if data argument was omitted=0A=
		if ( jQuery.isFunction( data ) ) {=0A=
			type =3D type || callback;=0A=
			callback =3D data;=0A=
			data =3D undefined;=0A=
		}=0A=
=0A=
		return jQuery.ajax({=0A=
			type: method,=0A=
			url: url,=0A=
			data: data,=0A=
			success: callback,=0A=
			dataType: type=0A=
		});=0A=
	};=0A=
});=0A=
=0A=
jQuery.extend({=0A=
=0A=
	getScript: function( url, callback ) {=0A=
		return jQuery.get( url, undefined, callback, "script" );=0A=
	},=0A=
=0A=
	getJSON: function( url, data, callback ) {=0A=
		return jQuery.get( url, data, callback, "json" );=0A=
	},=0A=
=0A=
	// Creates a full fledged settings object into target=0A=
	// with both ajaxSettings and settings fields.=0A=
	// If target is omitted, writes into ajaxSettings.=0A=
	ajaxSetup: function ( target, settings ) {=0A=
		if ( !settings ) {=0A=
			// Only one parameter, we extend ajaxSettings=0A=
			settings =3D target;=0A=
			target =3D jQuery.extend( true, jQuery.ajaxSettings, settings );=0A=
		} else {=0A=
			// target was provided, we extend into it=0A=
			jQuery.extend( true, target, jQuery.ajaxSettings, settings );=0A=
		}=0A=
		// Flatten fields we don't want deep extended=0A=
		for( var field in { context: 1, url: 1 } ) {=0A=
			if ( field in settings ) {=0A=
				target[ field ] =3D settings[ field ];=0A=
			} else if( field in jQuery.ajaxSettings ) {=0A=
				target[ field ] =3D jQuery.ajaxSettings[ field ];=0A=
			}=0A=
		}=0A=
		return target;=0A=
	},=0A=
=0A=
	ajaxSettings: {=0A=
		url: ajaxLocation,=0A=
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),=0A=
		global: true,=0A=
		type: "GET",=0A=
		contentType: "application/x-www-form-urlencoded",=0A=
		processData: true,=0A=
		async: true,=0A=
		/*=0A=
		timeout: 0,=0A=
		data: null,=0A=
		dataType: null,=0A=
		username: null,=0A=
		password: null,=0A=
		cache: null,=0A=
		traditional: false,=0A=
		headers: {},=0A=
		*/=0A=
=0A=
		accepts: {=0A=
			xml: "application/xml, text/xml",=0A=
			html: "text/html",=0A=
			text: "text/plain",=0A=
			json: "application/json, text/javascript",=0A=
			"*": "*/*"=0A=
		},=0A=
=0A=
		contents: {=0A=
			xml: /xml/,=0A=
			html: /html/,=0A=
			json: /json/=0A=
		},=0A=
=0A=
		responseFields: {=0A=
			xml: "responseXML",=0A=
			text: "responseText"=0A=
		},=0A=
=0A=
		// List of data converters=0A=
		// 1) key format is "source_type destination_type" (a single space =
in-between)=0A=
		// 2) the catchall symbol "*" can be used for source_type=0A=
		converters: {=0A=
=0A=
			// Convert anything to text=0A=
			"* text": window.String,=0A=
=0A=
			// Text to html (true =3D no transformation)=0A=
			"text html": true,=0A=
=0A=
			// Evaluate text as a json expression=0A=
			"text json": jQuery.parseJSON,=0A=
=0A=
			// Parse text as xml=0A=
			"text xml": jQuery.parseXML=0A=
		}=0A=
	},=0A=
=0A=
	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),=0A=
	ajaxTransport: addToPrefiltersOrTransports( transports ),=0A=
=0A=
	// Main method=0A=
	ajax: function( url, options ) {=0A=
=0A=
		// If url is an object, simulate pre-1.5 signature=0A=
		if ( typeof url =3D=3D=3D "object" ) {=0A=
			options =3D url;=0A=
			url =3D undefined;=0A=
		}=0A=
=0A=
		// Force options to be an object=0A=
		options =3D options || {};=0A=
=0A=
		var // Create the final options object=0A=
			s =3D jQuery.ajaxSetup( {}, options ),=0A=
			// Callbacks context=0A=
			callbackContext =3D s.context || s,=0A=
			// Context for global events=0A=
			// It's the callbackContext if one was provided in the options=0A=
			// and if it's a DOM node or a jQuery collection=0A=
			globalEventContext =3D callbackContext !=3D=3D s &&=0A=
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?=0A=
						jQuery( callbackContext ) : jQuery.event,=0A=
			// Deferreds=0A=
			deferred =3D jQuery.Deferred(),=0A=
			completeDeferred =3D jQuery._Deferred(),=0A=
			// Status-dependent callbacks=0A=
			statusCode =3D s.statusCode || {},=0A=
			// ifModified key=0A=
			ifModifiedKey,=0A=
			// Headers (they are sent all at once)=0A=
			requestHeaders =3D {},=0A=
			requestHeadersNames =3D {},=0A=
			// Response headers=0A=
			responseHeadersString,=0A=
			responseHeaders,=0A=
			// transport=0A=
			transport,=0A=
			// timeout handle=0A=
			timeoutTimer,=0A=
			// Cross-domain detection vars=0A=
			parts,=0A=
			// The jqXHR state=0A=
			state =3D 0,=0A=
			// To know if global events are to be dispatched=0A=
			fireGlobals,=0A=
			// Loop variable=0A=
			i,=0A=
			// Fake xhr=0A=
			jqXHR =3D {=0A=
=0A=
				readyState: 0,=0A=
=0A=
				// Caches the header=0A=
				setRequestHeader: function( name, value ) {=0A=
					if ( !state ) {=0A=
						var lname =3D name.toLowerCase();=0A=
						name =3D requestHeadersNames[ lname ] =3D requestHeadersNames[ =
lname ] || name;=0A=
						requestHeaders[ name ] =3D value;=0A=
					}=0A=
					return this;=0A=
				},=0A=
=0A=
				// Raw string=0A=
				getAllResponseHeaders: function() {=0A=
					return state =3D=3D=3D 2 ? responseHeadersString : null;=0A=
				},=0A=
=0A=
				// Builds headers hashtable if needed=0A=
				getResponseHeader: function( key ) {=0A=
					var match;=0A=
					if ( state =3D=3D=3D 2 ) {=0A=
						if ( !responseHeaders ) {=0A=
							responseHeaders =3D {};=0A=
							while( ( match =3D rheaders.exec( responseHeadersString ) ) ) {=0A=
								responseHeaders[ match[1].toLowerCase() ] =3D match[ 2 ];=0A=
							}=0A=
						}=0A=
						match =3D responseHeaders[ key.toLowerCase() ];=0A=
					}=0A=
					return match =3D=3D=3D undefined ? null : match;=0A=
				},=0A=
=0A=
				// Overrides response content-type header=0A=
				overrideMimeType: function( type ) {=0A=
					if ( !state ) {=0A=
						s.mimeType =3D type;=0A=
					}=0A=
					return this;=0A=
				},=0A=
=0A=
				// Cancel the request=0A=
				abort: function( statusText ) {=0A=
					statusText =3D statusText || "abort";=0A=
					if ( transport ) {=0A=
						transport.abort( statusText );=0A=
					}=0A=
					done( 0, statusText );=0A=
					return this;=0A=
				}=0A=
			};=0A=
=0A=
		// Callback for when everything is done=0A=
		// It is defined here because jslint complains if it is declared=0A=
		// at the end of the function (which would be more logical and =
readable)=0A=
		function done( status, statusText, responses, headers ) {=0A=
=0A=
			// Called once=0A=
			if ( state =3D=3D=3D 2 ) {=0A=
				return;=0A=
			}=0A=
=0A=
			// State is "done" now=0A=
			state =3D 2;=0A=
=0A=
			// Clear timeout if it exists=0A=
			if ( timeoutTimer ) {=0A=
				clearTimeout( timeoutTimer );=0A=
			}=0A=
=0A=
			// Dereference transport for early garbage collection=0A=
			// (no matter how long the jqXHR object will be used)=0A=
			transport =3D undefined;=0A=
=0A=
			// Cache response headers=0A=
			responseHeadersString =3D headers || "";=0A=
=0A=
			// Set readyState=0A=
			jqXHR.readyState =3D status ? 4 : 0;=0A=
=0A=
			var isSuccess,=0A=
				success,=0A=
				error,=0A=
				response =3D responses ? ajaxHandleResponses( s, jqXHR, responses ) =
: undefined,=0A=
				lastModified,=0A=
				etag;=0A=
=0A=
			// If successful, handle type chaining=0A=
			if ( status >=3D 200 && status < 300 || status =3D=3D=3D 304 ) {=0A=
=0A=
				// Set the If-Modified-Since and/or If-None-Match header, if in =
ifModified mode.=0A=
				if ( s.ifModified ) {=0A=
=0A=
					if ( ( lastModified =3D jqXHR.getResponseHeader( "Last-Modified" ) =
) ) {=0A=
						jQuery.lastModified[ ifModifiedKey ] =3D lastModified;=0A=
					}=0A=
					if ( ( etag =3D jqXHR.getResponseHeader( "Etag" ) ) ) {=0A=
						jQuery.etag[ ifModifiedKey ] =3D etag;=0A=
					}=0A=
				}=0A=
=0A=
				// If not modified=0A=
				if ( status =3D=3D=3D 304 ) {=0A=
=0A=
					statusText =3D "notmodified";=0A=
					isSuccess =3D true;=0A=
=0A=
				// If we have data=0A=
				} else {=0A=
=0A=
					try {=0A=
						success =3D ajaxConvert( s, response );=0A=
						statusText =3D "success";=0A=
						isSuccess =3D true;=0A=
					} catch(e) {=0A=
						// We have a parsererror=0A=
						statusText =3D "parsererror";=0A=
						error =3D e;=0A=
					}=0A=
				}=0A=
			} else {=0A=
				// We extract error from statusText=0A=
				// then normalize statusText and status for non-aborts=0A=
				error =3D statusText;=0A=
				if( !statusText || status ) {=0A=
					statusText =3D "error";=0A=
					if ( status < 0 ) {=0A=
						status =3D 0;=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			// Set data for the fake xhr object=0A=
			jqXHR.status =3D status;=0A=
			jqXHR.statusText =3D statusText;=0A=
=0A=
			// Success/Error=0A=
			if ( isSuccess ) {=0A=
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR =
] );=0A=
			} else {=0A=
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );=0A=
			}=0A=
=0A=
			// Status-dependent callbacks=0A=
			jqXHR.statusCode( statusCode );=0A=
			statusCode =3D undefined;=0A=
=0A=
			if ( fireGlobals ) {=0A=
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : =
"Error" ),=0A=
						[ jqXHR, s, isSuccess ? success : error ] );=0A=
			}=0A=
=0A=
			// Complete=0A=
			completeDeferred.resolveWith( callbackContext, [ jqXHR, statusText ] =
);=0A=
=0A=
			if ( fireGlobals ) {=0A=
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s] );=0A=
				// Handle the global AJAX counter=0A=
				if ( !( --jQuery.active ) ) {=0A=
					jQuery.event.trigger( "ajaxStop" );=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Attach deferreds=0A=
		deferred.promise( jqXHR );=0A=
		jqXHR.success =3D jqXHR.done;=0A=
		jqXHR.error =3D jqXHR.fail;=0A=
		jqXHR.complete =3D completeDeferred.done;=0A=
=0A=
		// Status-dependent callbacks=0A=
		jqXHR.statusCode =3D function( map ) {=0A=
			if ( map ) {=0A=
				var tmp;=0A=
				if ( state < 2 ) {=0A=
					for( tmp in map ) {=0A=
						statusCode[ tmp ] =3D [ statusCode[tmp], map[tmp] ];=0A=
					}=0A=
				} else {=0A=
					tmp =3D map[ jqXHR.status ];=0A=
					jqXHR.then( tmp, tmp );=0A=
				}=0A=
			}=0A=
			return this;=0A=
		};=0A=
=0A=
		// Remove hash character (#7531: and string promotion)=0A=
		// Add protocol if not provided (#5866: IE7 issue with protocol-less =
urls)=0A=
		// We also use the url parameter if available=0A=
		s.url =3D ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( =
rprotocol, ajaxLocParts[ 1 ] + "//" );=0A=
=0A=
		// Extract dataTypes list=0A=
		s.dataTypes =3D jQuery.trim( s.dataType || "*" ).toLowerCase().split( =
rspacesAjax );=0A=
=0A=
		// Determine if a cross-domain request is in order=0A=
		if ( s.crossDomain =3D=3D null ) {=0A=
			parts =3D rurl.exec( s.url.toLowerCase() );=0A=
			s.crossDomain =3D !!( parts &&=0A=
				( parts[ 1 ] !=3D ajaxLocParts[ 1 ] || parts[ 2 ] !=3D ajaxLocParts[ =
2 ] ||=0A=
					( parts[ 3 ] || ( parts[ 1 ] =3D=3D=3D "http:" ? 80 : 443 ) ) !=3D=0A=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] =3D=3D=3D "http:" ? 80 =
: 443 ) ) )=0A=
			);=0A=
		}=0A=
=0A=
		// Convert data if not already a string=0A=
		if ( s.data && s.processData && typeof s.data !=3D=3D "string" ) {=0A=
			s.data =3D jQuery.param( s.data, s.traditional );=0A=
		}=0A=
=0A=
		// Apply prefilters=0A=
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );=0A=
=0A=
		// If request was aborted inside a prefiler, stop there=0A=
		if ( state =3D=3D=3D 2 ) {=0A=
			return false;=0A=
		}=0A=
=0A=
		// We can fire global events as of now if asked to=0A=
		fireGlobals =3D s.global;=0A=
=0A=
		// Uppercase the type=0A=
		s.type =3D s.type.toUpperCase();=0A=
=0A=
		// Determine if request has content=0A=
		s.hasContent =3D !rnoContent.test( s.type );=0A=
=0A=
		// Watch for a new set of requests=0A=
		if ( fireGlobals && jQuery.active++ =3D=3D=3D 0 ) {=0A=
			jQuery.event.trigger( "ajaxStart" );=0A=
		}=0A=
=0A=
		// More options handling for requests with no content=0A=
		if ( !s.hasContent ) {=0A=
=0A=
			// If data is available, append data to url=0A=
			if ( s.data ) {=0A=
				s.url +=3D ( rquery.test( s.url ) ? "&" : "?" ) + s.data;=0A=
			}=0A=
=0A=
			// Get ifModifiedKey before adding the anti-cache parameter=0A=
			ifModifiedKey =3D s.url;=0A=
=0A=
			// Add anti-cache in url if needed=0A=
			if ( s.cache =3D=3D=3D false ) {=0A=
=0A=
				var ts =3D jQuery.now(),=0A=
					// try replacing _=3D if it is there=0A=
					ret =3D s.url.replace( rts, "$1_=3D" + ts );=0A=
=0A=
				// if nothing was replaced, add timestamp to the end=0A=
				s.url =3D ret + ( (ret =3D=3D=3D s.url ) ? ( rquery.test( s.url ) ? =
"&" : "?" ) + "_=3D" + ts : "" );=0A=
			}=0A=
		}=0A=
=0A=
		// Set the correct header, if data is being sent=0A=
		if ( s.data && s.hasContent && s.contentType !=3D=3D false || =
options.contentType ) {=0A=
			jqXHR.setRequestHeader( "Content-Type", s.contentType );=0A=
		}=0A=
=0A=
		// Set the If-Modified-Since and/or If-None-Match header, if in =
ifModified mode.=0A=
		if ( s.ifModified ) {=0A=
			ifModifiedKey =3D ifModifiedKey || s.url;=0A=
			if ( jQuery.lastModified[ ifModifiedKey ] ) {=0A=
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ =
ifModifiedKey ] );=0A=
			}=0A=
			if ( jQuery.etag[ ifModifiedKey ] ) {=0A=
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey =
] );=0A=
			}=0A=
		}=0A=
=0A=
		// Set the Accepts header for the server, depending on the dataType=0A=
		jqXHR.setRequestHeader(=0A=
			"Accept",=0A=
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?=0A=
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !=3D=3D "*" ? ", =
*/*; q=3D0.01" : "" ) :=0A=
				s.accepts[ "*" ]=0A=
		);=0A=
=0A=
		// Check for headers option=0A=
		for ( i in s.headers ) {=0A=
			jqXHR.setRequestHeader( i, s.headers[ i ] );=0A=
		}=0A=
=0A=
		// Allow custom headers/mimetypes and early abort=0A=
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) =
=3D=3D=3D false || state =3D=3D=3D 2 ) ) {=0A=
				// Abort if not done already=0A=
				jqXHR.abort();=0A=
				return false;=0A=
=0A=
		}=0A=
=0A=
		// Install callbacks on deferreds=0A=
		for ( i in { success: 1, error: 1, complete: 1 } ) {=0A=
			jqXHR[ i ]( s[ i ] );=0A=
		}=0A=
=0A=
		// Get transport=0A=
		transport =3D inspectPrefiltersOrTransports( transports, s, options, =
jqXHR );=0A=
=0A=
		// If no transport, we auto-abort=0A=
		if ( !transport ) {=0A=
			done( -1, "No Transport" );=0A=
		} else {=0A=
			jqXHR.readyState =3D 1;=0A=
			// Send global event=0A=
			if ( fireGlobals ) {=0A=
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );=0A=
			}=0A=
			// Timeout=0A=
			if ( s.async && s.timeout > 0 ) {=0A=
				timeoutTimer =3D setTimeout( function(){=0A=
					jqXHR.abort( "timeout" );=0A=
				}, s.timeout );=0A=
			}=0A=
=0A=
			try {=0A=
				state =3D 1;=0A=
				transport.send( requestHeaders, done );=0A=
			} catch (e) {=0A=
				// Propagate exception as error if not done=0A=
				if ( status < 2 ) {=0A=
					done( -1, e );=0A=
				// Simply rethrow otherwise=0A=
				} else {=0A=
					jQuery.error( e );=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return jqXHR;=0A=
	},=0A=
=0A=
	// Serialize an array of form elements or a set of=0A=
	// key/values into a query string=0A=
	param: function( a, traditional ) {=0A=
		var s =3D [],=0A=
			add =3D function( key, value ) {=0A=
				// If value is a function, invoke it and return its value=0A=
				value =3D jQuery.isFunction( value ) ? value() : value;=0A=
				s[ s.length ] =3D encodeURIComponent( key ) + "=3D" + =
encodeURIComponent( value );=0A=
			};=0A=
=0A=
		// Set traditional to true for jQuery <=3D 1.3.2 behavior.=0A=
		if ( traditional =3D=3D=3D undefined ) {=0A=
			traditional =3D jQuery.ajaxSettings.traditional;=0A=
		}=0A=
=0A=
		// If an array was passed in, assume that it is an array of form =
elements.=0A=
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) =
) {=0A=
			// Serialize the form elements=0A=
			jQuery.each( a, function() {=0A=
				add( this.name, this.value );=0A=
			});=0A=
=0A=
		} else {=0A=
			// If traditional, encode the "old" way (the way 1.3.2 or older=0A=
			// did it), otherwise encode params recursively.=0A=
			for ( var prefix in a ) {=0A=
				buildParams( prefix, a[ prefix ], traditional, add );=0A=
			}=0A=
		}=0A=
=0A=
		// Return the resulting serialization=0A=
		return s.join( "&" ).replace( r20, "+" );=0A=
	}=0A=
});=0A=
=0A=
function buildParams( prefix, obj, traditional, add ) {=0A=
	if ( jQuery.isArray( obj ) ) {=0A=
		// Serialize array item.=0A=
		jQuery.each( obj, function( i, v ) {=0A=
			if ( traditional || rbracket.test( prefix ) ) {=0A=
				// Treat each array item as a scalar.=0A=
				add( prefix, v );=0A=
=0A=
			} else {=0A=
				// If array item is non-scalar (array or object), encode its=0A=
				// numeric index to resolve deserialization ambiguity issues.=0A=
				// Note that rack (as of 1.0.0) can't currently deserialize=0A=
				// nested arrays properly, and attempting to do so may cause=0A=
				// a server error. Possible fixes are to modify rack's=0A=
				// deserialization algorithm or to provide an option or flag=0A=
				// to force array serialization to be shallow.=0A=
				buildParams( prefix + "[" + ( typeof v =3D=3D=3D "object" || =
jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );=0A=
			}=0A=
		});=0A=
=0A=
	} else if ( !traditional && obj !=3D null && typeof obj =3D=3D=3D =
"object" ) {=0A=
		// Serialize object item.=0A=
		for ( var name in obj ) {=0A=
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add =
);=0A=
		}=0A=
=0A=
	} else {=0A=
		// Serialize scalar item.=0A=
		add( prefix, obj );=0A=
	}=0A=
}=0A=
=0A=
// This is still on the jQuery object... for now=0A=
// Want to move this to jQuery.ajax some day=0A=
jQuery.extend({=0A=
=0A=
	// Counter for holding the number of active queries=0A=
	active: 0,=0A=
=0A=
	// Last-Modified header cache for next request=0A=
	lastModified: {},=0A=
	etag: {}=0A=
=0A=
});=0A=
=0A=
/* Handles responses to an ajax request:=0A=
 * - sets all responseXXX fields accordingly=0A=
 * - finds the right dataType (mediates between content-type and =
expected dataType)=0A=
 * - returns the corresponding response=0A=
 */=0A=
function ajaxHandleResponses( s, jqXHR, responses ) {=0A=
=0A=
	var contents =3D s.contents,=0A=
		dataTypes =3D s.dataTypes,=0A=
		responseFields =3D s.responseFields,=0A=
		ct,=0A=
		type,=0A=
		finalDataType,=0A=
		firstDataType;=0A=
=0A=
	// Fill responseXXX fields=0A=
	for( type in responseFields ) {=0A=
		if ( type in responses ) {=0A=
			jqXHR[ responseFields[type] ] =3D responses[ type ];=0A=
		}=0A=
	}=0A=
=0A=
	// Remove auto dataType and get content-type in the process=0A=
	while( dataTypes[ 0 ] =3D=3D=3D "*" ) {=0A=
		dataTypes.shift();=0A=
		if ( ct =3D=3D=3D undefined ) {=0A=
			ct =3D s.mimeType || jqXHR.getResponseHeader( "content-type" );=0A=
		}=0A=
	}=0A=
=0A=
	// Check if we're dealing with a known content-type=0A=
	if ( ct ) {=0A=
		for ( type in contents ) {=0A=
			if ( contents[ type ] && contents[ type ].test( ct ) ) {=0A=
				dataTypes.unshift( type );=0A=
				break;=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	// Check to see if we have a response for the expected dataType=0A=
	if ( dataTypes[ 0 ] in responses ) {=0A=
		finalDataType =3D dataTypes[ 0 ];=0A=
	} else {=0A=
		// Try convertible dataTypes=0A=
		for ( type in responses ) {=0A=
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {=0A=
				finalDataType =3D type;=0A=
				break;=0A=
			}=0A=
			if ( !firstDataType ) {=0A=
				firstDataType =3D type;=0A=
			}=0A=
		}=0A=
		// Or just use first one=0A=
		finalDataType =3D finalDataType || firstDataType;=0A=
	}=0A=
=0A=
	// If we found a dataType=0A=
	// We add the dataType to the list if needed=0A=
	// and return the corresponding response=0A=
	if ( finalDataType ) {=0A=
		if ( finalDataType !=3D=3D dataTypes[ 0 ] ) {=0A=
			dataTypes.unshift( finalDataType );=0A=
		}=0A=
		return responses[ finalDataType ];=0A=
	}=0A=
}=0A=
=0A=
// Chain conversions given the request and the original response=0A=
function ajaxConvert( s, response ) {=0A=
=0A=
	// Apply the dataFilter if provided=0A=
	if ( s.dataFilter ) {=0A=
		response =3D s.dataFilter( response, s.dataType );=0A=
	}=0A=
=0A=
	var dataTypes =3D s.dataTypes,=0A=
		converters =3D {},=0A=
		i,=0A=
		key,=0A=
		length =3D dataTypes.length,=0A=
		tmp,=0A=
		// Current and previous dataTypes=0A=
		current =3D dataTypes[ 0 ],=0A=
		prev,=0A=
		// Conversion expression=0A=
		conversion,=0A=
		// Conversion function=0A=
		conv,=0A=
		// Conversion functions (transitive conversion)=0A=
		conv1,=0A=
		conv2;=0A=
=0A=
	// For each dataType in the chain=0A=
	for( i =3D 1; i < length; i++ ) {=0A=
=0A=
		// Create converters map=0A=
		// with lowercased keys=0A=
		if ( i =3D=3D=3D 1 ) {=0A=
			for( key in s.converters ) {=0A=
				if( typeof key =3D=3D=3D "string" ) {=0A=
					converters[ key.toLowerCase() ] =3D s.converters[ key ];=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Get the dataTypes=0A=
		prev =3D current;=0A=
		current =3D dataTypes[ i ];=0A=
=0A=
		// If current is auto dataType, update it to prev=0A=
		if( current =3D=3D=3D "*" ) {=0A=
			current =3D prev;=0A=
		// If no auto and dataTypes are actually different=0A=
		} else if ( prev !=3D=3D "*" && prev !=3D=3D current ) {=0A=
=0A=
			// Get the converter=0A=
			conversion =3D prev + " " + current;=0A=
			conv =3D converters[ conversion ] || converters[ "* " + current ];=0A=
=0A=
			// If there is no direct converter, search transitively=0A=
			if ( !conv ) {=0A=
				conv2 =3D undefined;=0A=
				for( conv1 in converters ) {=0A=
					tmp =3D conv1.split( " " );=0A=
					if ( tmp[ 0 ] =3D=3D=3D prev || tmp[ 0 ] =3D=3D=3D "*" ) {=0A=
						conv2 =3D converters[ tmp[1] + " " + current ];=0A=
						if ( conv2 ) {=0A=
							conv1 =3D converters[ conv1 ];=0A=
							if ( conv1 =3D=3D=3D true ) {=0A=
								conv =3D conv2;=0A=
							} else if ( conv2 =3D=3D=3D true ) {=0A=
								conv =3D conv1;=0A=
							}=0A=
							break;=0A=
						}=0A=
					}=0A=
				}=0A=
			}=0A=
			// If we found no converter, dispatch an error=0A=
			if ( !( conv || conv2 ) ) {=0A=
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") =
);=0A=
			}=0A=
			// If found converter is not an equivalence=0A=
			if ( conv !=3D=3D true ) {=0A=
				// Convert with 1 or 2 converters accordingly=0A=
				response =3D conv ? conv( response ) : conv2( conv1(response) );=0A=
			}=0A=
		}=0A=
	}=0A=
	return response;=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
var jsc =3D jQuery.now(),=0A=
	jsre =3D /(\=3D)\?(&|$)|\?\?/i;=0A=
=0A=
// Default jsonp settings=0A=
jQuery.ajaxSetup({=0A=
	jsonp: "callback",=0A=
	jsonpCallback: function() {=0A=
		return jQuery.expando + "_" + ( jsc++ );=0A=
	}=0A=
});=0A=
=0A=
// Detect, normalize options and install callbacks for jsonp requests=0A=
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR =
) {=0A=
=0A=
	var inspectData =3D s.contentType =3D=3D=3D =
"application/x-www-form-urlencoded" &&=0A=
		( typeof s.data =3D=3D=3D "string" );=0A=
=0A=
	if ( s.dataTypes[ 0 ] =3D=3D=3D "jsonp" ||=0A=
		s.jsonp !=3D=3D false && ( jsre.test( s.url ) ||=0A=
				inspectData && jsre.test( s.data ) ) ) {=0A=
=0A=
		var responseContainer,=0A=
			jsonpCallback =3D s.jsonpCallback =3D=0A=
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : =
s.jsonpCallback,=0A=
			previous =3D window[ jsonpCallback ],=0A=
			url =3D s.url,=0A=
			data =3D s.data,=0A=
			replace =3D "$1" + jsonpCallback + "$2";=0A=
=0A=
		if ( s.jsonp !=3D=3D false ) {=0A=
			url =3D url.replace( jsre, replace );=0A=
			if ( s.url =3D=3D=3D url ) {=0A=
				if ( inspectData ) {=0A=
					data =3D data.replace( jsre, replace );=0A=
				}=0A=
				if ( s.data =3D=3D=3D data ) {=0A=
					// Add callback manually=0A=
					url +=3D (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=3D" + =
jsonpCallback;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		s.url =3D url;=0A=
		s.data =3D data;=0A=
=0A=
		// Install callback=0A=
		window[ jsonpCallback ] =3D function( response ) {=0A=
			responseContainer =3D [ response ];=0A=
		};=0A=
=0A=
		// Clean-up function=0A=
		jqXHR.always(function() {=0A=
			// Set callback back to previous value=0A=
			window[ jsonpCallback ] =3D previous;=0A=
			// Call if it was a function and we have a response=0A=
			if ( responseContainer && jQuery.isFunction( previous ) ) {=0A=
				window[ jsonpCallback ]( responseContainer[ 0 ] );=0A=
			}=0A=
		});=0A=
=0A=
		// Use data converter to retrieve json after script execution=0A=
		s.converters["script json"] =3D function() {=0A=
			if ( !responseContainer ) {=0A=
				jQuery.error( jsonpCallback + " was not called" );=0A=
			}=0A=
			return responseContainer[ 0 ];=0A=
		};=0A=
=0A=
		// force json dataType=0A=
		s.dataTypes[ 0 ] =3D "json";=0A=
=0A=
		// Delegate to script=0A=
		return "script";=0A=
	}=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
// Install script dataType=0A=
jQuery.ajaxSetup({=0A=
	accepts: {=0A=
		script: "text/javascript, application/javascript, =
application/ecmascript, application/x-ecmascript"=0A=
	},=0A=
	contents: {=0A=
		script: /javascript|ecmascript/=0A=
	},=0A=
	converters: {=0A=
		"text script": function( text ) {=0A=
			jQuery.globalEval( text );=0A=
			return text;=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
// Handle cache's special case and global=0A=
jQuery.ajaxPrefilter( "script", function( s ) {=0A=
	if ( s.cache =3D=3D=3D undefined ) {=0A=
		s.cache =3D false;=0A=
	}=0A=
	if ( s.crossDomain ) {=0A=
		s.type =3D "GET";=0A=
		s.global =3D false;=0A=
	}=0A=
});=0A=
=0A=
// Bind script tag hack transport=0A=
jQuery.ajaxTransport( "script", function(s) {=0A=
=0A=
	// This transport only deals with cross domain requests=0A=
	if ( s.crossDomain ) {=0A=
=0A=
		var script,=0A=
			head =3D document.head || document.getElementsByTagName( "head" )[0] =
|| document.documentElement;=0A=
=0A=
		return {=0A=
=0A=
			send: function( _, callback ) {=0A=
=0A=
				script =3D document.createElement( "script" );=0A=
=0A=
				script.async =3D "async";=0A=
=0A=
				if ( s.scriptCharset ) {=0A=
					script.charset =3D s.scriptCharset;=0A=
				}=0A=
=0A=
				script.src =3D s.url;=0A=
=0A=
				// Attach handlers for all browsers=0A=
				script.onload =3D script.onreadystatechange =3D function( _, isAbort =
) {=0A=
=0A=
					if ( isAbort || !script.readyState || /loaded|complete/.test( =
script.readyState ) ) {=0A=
=0A=
						// Handle memory leak in IE=0A=
						script.onload =3D script.onreadystatechange =3D null;=0A=
=0A=
						// Remove the script=0A=
						if ( head && script.parentNode ) {=0A=
							head.removeChild( script );=0A=
						}=0A=
=0A=
						// Dereference the script=0A=
						script =3D undefined;=0A=
=0A=
						// Callback if not abort=0A=
						if ( !isAbort ) {=0A=
							callback( 200, "success" );=0A=
						}=0A=
					}=0A=
				};=0A=
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.=0A=
				// This arises when a base node is used (#2709 and #4378).=0A=
				head.insertBefore( script, head.firstChild );=0A=
			},=0A=
=0A=
			abort: function() {=0A=
				if ( script ) {=0A=
					script.onload( 0, 1 );=0A=
				}=0A=
			}=0A=
		};=0A=
	}=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
var // #5280: Internet Explorer will keep connections alive if we don't =
abort on unload=0A=
	xhrOnUnloadAbort =3D window.ActiveXObject ? function() {=0A=
		// Abort all pending requests=0A=
		for ( var key in xhrCallbacks ) {=0A=
			xhrCallbacks[ key ]( 0, 1 );=0A=
		}=0A=
	} : false,=0A=
	xhrId =3D 0,=0A=
	xhrCallbacks;=0A=
=0A=
// Functions to create xhrs=0A=
function createStandardXHR() {=0A=
	try {=0A=
		return new window.XMLHttpRequest();=0A=
	} catch( e ) {}=0A=
}=0A=
=0A=
function createActiveXHR() {=0A=
	try {=0A=
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );=0A=
	} catch( e ) {}=0A=
}=0A=
=0A=
// Create the request object=0A=
// (This is still attached to ajaxSettings for backward compatibility)=0A=
jQuery.ajaxSettings.xhr =3D window.ActiveXObject ?=0A=
	/* Microsoft failed to properly=0A=
	 * implement the XMLHttpRequest in IE7 (can't request local files),=0A=
	 * so we use the ActiveXObject when it is available=0A=
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so=0A=
	 * we need a fallback.=0A=
	 */=0A=
	function() {=0A=
		return !this.isLocal && createStandardXHR() || createActiveXHR();=0A=
	} :=0A=
	// For all other browsers, use the standard XMLHttpRequest object=0A=
	createStandardXHR;=0A=
=0A=
// Determine support properties=0A=
(function( xhr ) {=0A=
	jQuery.extend( jQuery.support, {=0A=
		ajax: !!xhr,=0A=
		cors: !!xhr && ( "withCredentials" in xhr )=0A=
	});=0A=
})( jQuery.ajaxSettings.xhr() );=0A=
=0A=
// Create transport if the browser can provide an xhr=0A=
if ( jQuery.support.ajax ) {=0A=
=0A=
	jQuery.ajaxTransport(function( s ) {=0A=
		// Cross domain only allowed if supported through XMLHttpRequest=0A=
		if ( !s.crossDomain || jQuery.support.cors ) {=0A=
=0A=
			var callback;=0A=
=0A=
			return {=0A=
				send: function( headers, complete ) {=0A=
=0A=
					// Get a new xhr=0A=
					var xhr =3D s.xhr(),=0A=
						handle,=0A=
						i;=0A=
=0A=
					// Open the socket=0A=
					// Passing null username, generates a login popup on Opera (#2865)=0A=
					if ( s.username ) {=0A=
						xhr.open( s.type, s.url, s.async, s.username, s.password );=0A=
					} else {=0A=
						xhr.open( s.type, s.url, s.async );=0A=
					}=0A=
=0A=
					// Apply custom fields if provided=0A=
					if ( s.xhrFields ) {=0A=
						for ( i in s.xhrFields ) {=0A=
							xhr[ i ] =3D s.xhrFields[ i ];=0A=
						}=0A=
					}=0A=
=0A=
					// Override mime type if needed=0A=
					if ( s.mimeType && xhr.overrideMimeType ) {=0A=
						xhr.overrideMimeType( s.mimeType );=0A=
					}=0A=
=0A=
					// X-Requested-With header=0A=
					// For cross-domain requests, seeing as conditions for a preflight =
are=0A=
					// akin to a jigsaw puzzle, we simply never set it to be sure.=0A=
					// (it can always be set on a per-request basis or even using =
ajaxSetup)=0A=
					// For same-domain requests, won't change header if already =
provided.=0A=
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {=0A=
						headers[ "X-Requested-With" ] =3D "XMLHttpRequest";=0A=
					}=0A=
=0A=
					// Need an extra try/catch for cross domain requests in Firefox 3=0A=
					try {=0A=
						for ( i in headers ) {=0A=
							xhr.setRequestHeader( i, headers[ i ] );=0A=
						}=0A=
					} catch( _ ) {}=0A=
=0A=
					// Do send the request=0A=
					// This may raise an exception which is actually=0A=
					// handled in jQuery.ajax (so no try/catch here)=0A=
					xhr.send( ( s.hasContent && s.data ) || null );=0A=
=0A=
					// Listener=0A=
					callback =3D function( _, isAbort ) {=0A=
=0A=
						var status,=0A=
							statusText,=0A=
							responseHeaders,=0A=
							responses,=0A=
							xml;=0A=
=0A=
						// Firefox throws exceptions when accessing properties=0A=
						// of an xhr when a network error occured=0A=
						// =
http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:=
_0x80040111_(NS_ERROR_NOT_AVAILABLE)=0A=
						try {=0A=
=0A=
							// Was never called and is aborted or complete=0A=
							if ( callback && ( isAbort || xhr.readyState =3D=3D=3D 4 ) ) {=0A=
=0A=
								// Only called once=0A=
								callback =3D undefined;=0A=
=0A=
								// Do not keep as active anymore=0A=
								if ( handle ) {=0A=
									xhr.onreadystatechange =3D jQuery.noop;=0A=
									if ( xhrOnUnloadAbort ) {=0A=
										delete xhrCallbacks[ handle ];=0A=
									}=0A=
								}=0A=
=0A=
								// If it's an abort=0A=
								if ( isAbort ) {=0A=
									// Abort it manually if needed=0A=
									if ( xhr.readyState !=3D=3D 4 ) {=0A=
										xhr.abort();=0A=
									}=0A=
								} else {=0A=
									status =3D xhr.status;=0A=
									responseHeaders =3D xhr.getAllResponseHeaders();=0A=
									responses =3D {};=0A=
									xml =3D xhr.responseXML;=0A=
=0A=
									// Construct response list=0A=
									if ( xml && xml.documentElement /* #4958 */ ) {=0A=
										responses.xml =3D xml;=0A=
									}=0A=
									responses.text =3D xhr.responseText;=0A=
=0A=
									// Firefox throws an exception when accessing=0A=
									// statusText for faulty cross-domain requests=0A=
									try {=0A=
										statusText =3D xhr.statusText;=0A=
									} catch( e ) {=0A=
										// We normalize with Webkit giving an empty statusText=0A=
										statusText =3D "";=0A=
									}=0A=
=0A=
									// Filter status for non standard behaviors=0A=
=0A=
									// If the request is local and we have data: assume a success=0A=
									// (success with no data won't get notified, that's the best we=0A=
									// can do given current implementations)=0A=
									if ( !status && s.isLocal && !s.crossDomain ) {=0A=
										status =3D responses.text ? 200 : 404;=0A=
									// IE - #1450: sometimes returns 1223 when it should be 204=0A=
									} else if ( status =3D=3D=3D 1223 ) {=0A=
										status =3D 204;=0A=
									}=0A=
								}=0A=
							}=0A=
						} catch( firefoxAccessException ) {=0A=
							if ( !isAbort ) {=0A=
								complete( -1, firefoxAccessException );=0A=
							}=0A=
						}=0A=
=0A=
						// Call complete if needed=0A=
						if ( responses ) {=0A=
							complete( status, statusText, responses, responseHeaders );=0A=
						}=0A=
					};=0A=
=0A=
					// if we're in sync mode or it's in cache=0A=
					// and has been retrieved directly (IE6 & IE7)=0A=
					// we need to manually fire the callback=0A=
					if ( !s.async || xhr.readyState =3D=3D=3D 4 ) {=0A=
						callback();=0A=
					} else {=0A=
						handle =3D ++xhrId;=0A=
						if ( xhrOnUnloadAbort ) {=0A=
							// Create the active xhrs callbacks list if needed=0A=
							// and attach the unload handler=0A=
							if ( !xhrCallbacks ) {=0A=
								xhrCallbacks =3D {};=0A=
								jQuery( window ).unload( xhrOnUnloadAbort );=0A=
							}=0A=
							// Add to list of active xhrs callbacks=0A=
							xhrCallbacks[ handle ] =3D callback;=0A=
						}=0A=
						xhr.onreadystatechange =3D callback;=0A=
					}=0A=
				},=0A=
=0A=
				abort: function() {=0A=
					if ( callback ) {=0A=
						callback(0,1);=0A=
					}=0A=
				}=0A=
			};=0A=
		}=0A=
	});=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
var elemdisplay =3D {},=0A=
	iframe, iframeDoc,=0A=
	rfxtypes =3D /^(?:toggle|show|hide)$/,=0A=
	rfxnum =3D /^([+\-]=3D)?([\d+.\-]+)([a-z%]*)$/i,=0A=
	timerId,=0A=
	fxAttrs =3D [=0A=
		// height animations=0A=
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" =
],=0A=
		// width animations=0A=
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" =
],=0A=
		// opacity animations=0A=
		[ "opacity" ]=0A=
	],=0A=
	fxNow,=0A=
	requestAnimationFrame =3D window.webkitRequestAnimationFrame ||=0A=
		window.mozRequestAnimationFrame ||=0A=
		window.oRequestAnimationFrame;=0A=
=0A=
jQuery.fn.extend({=0A=
	show: function( speed, easing, callback ) {=0A=
		var elem, display;=0A=
=0A=
		if ( speed || speed =3D=3D=3D 0 ) {=0A=
			return this.animate( genFx("show", 3), speed, easing, callback);=0A=
=0A=
		} else {=0A=
			for ( var i =3D 0, j =3D this.length; i < j; i++ ) {=0A=
				elem =3D this[i];=0A=
=0A=
				if ( elem.style ) {=0A=
					display =3D elem.style.display;=0A=
=0A=
					// Reset the inline display of this element to learn if it is=0A=
					// being hidden by cascaded rules or not=0A=
					if ( !jQuery._data(elem, "olddisplay") && display =3D=3D=3D "none" =
) {=0A=
						display =3D elem.style.display =3D "";=0A=
					}=0A=
=0A=
					// Set elements which have been overridden with display: none=0A=
					// in a stylesheet to whatever the default browser style is=0A=
					// for such an element=0A=
					if ( display =3D=3D=3D "" && jQuery.css( elem, "display" ) =
=3D=3D=3D "none" ) {=0A=
						jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			// Set the display of most of the elements in a second loop=0A=
			// to avoid the constant reflow=0A=
			for ( i =3D 0; i < j; i++ ) {=0A=
				elem =3D this[i];=0A=
=0A=
				if ( elem.style ) {=0A=
					display =3D elem.style.display;=0A=
=0A=
					if ( display =3D=3D=3D "" || display =3D=3D=3D "none" ) {=0A=
						elem.style.display =3D jQuery._data(elem, "olddisplay") || "";=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			return this;=0A=
		}=0A=
	},=0A=
=0A=
	hide: function( speed, easing, callback ) {=0A=
		if ( speed || speed =3D=3D=3D 0 ) {=0A=
			return this.animate( genFx("hide", 3), speed, easing, callback);=0A=
=0A=
		} else {=0A=
			for ( var i =3D 0, j =3D this.length; i < j; i++ ) {=0A=
				if ( this[i].style ) {=0A=
					var display =3D jQuery.css( this[i], "display" );=0A=
=0A=
					if ( display !=3D=3D "none" && !jQuery._data( this[i], "olddisplay" =
) ) {=0A=
						jQuery._data( this[i], "olddisplay", display );=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			// Set the display of the elements in a second loop=0A=
			// to avoid the constant reflow=0A=
			for ( i =3D 0; i < j; i++ ) {=0A=
				if ( this[i].style ) {=0A=
					this[i].style.display =3D "none";=0A=
				}=0A=
			}=0A=
=0A=
			return this;=0A=
		}=0A=
	},=0A=
=0A=
	// Save the old toggle function=0A=
	_toggle: jQuery.fn.toggle,=0A=
=0A=
	toggle: function( fn, fn2, callback ) {=0A=
		var bool =3D typeof fn =3D=3D=3D "boolean";=0A=
=0A=
		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {=0A=
			this._toggle.apply( this, arguments );=0A=
=0A=
		} else if ( fn =3D=3D null || bool ) {=0A=
			this.each(function() {=0A=
				var state =3D bool ? fn : jQuery(this).is(":hidden");=0A=
				jQuery(this)[ state ? "show" : "hide" ]();=0A=
			});=0A=
=0A=
		} else {=0A=
			this.animate(genFx("toggle", 3), fn, fn2, callback);=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	fadeTo: function( speed, to, easing, callback ) {=0A=
		return this.filter(":hidden").css("opacity", 0).show().end()=0A=
					.animate({opacity: to}, speed, easing, callback);=0A=
	},=0A=
=0A=
	animate: function( prop, speed, easing, callback ) {=0A=
		var optall =3D jQuery.speed(speed, easing, callback);=0A=
=0A=
		if ( jQuery.isEmptyObject( prop ) ) {=0A=
			return this.each( optall.complete, [ false ] );=0A=
		}=0A=
=0A=
		// Do not change referenced properties as per-property easing will be =
lost=0A=
		prop =3D jQuery.extend( {}, prop );=0A=
=0A=
		return this[ optall.queue =3D=3D=3D false ? "each" : "queue" =
](function() {=0A=
			// XXX 'this' does not always have a nodeName when running the=0A=
			// test suite=0A=
=0A=
			if ( optall.queue =3D=3D=3D false ) {=0A=
				jQuery._mark( this );=0A=
			}=0A=
=0A=
			var opt =3D jQuery.extend( {}, optall ),=0A=
				isElement =3D this.nodeType =3D=3D=3D 1,=0A=
				hidden =3D isElement && jQuery(this).is(":hidden"),=0A=
				name, val, p,=0A=
				display, e,=0A=
				parts, start, end, unit;=0A=
=0A=
			// will store per property easing and be used to determine when an =
animation is complete=0A=
			opt.animatedProperties =3D {};=0A=
=0A=
			for ( p in prop ) {=0A=
=0A=
				// property name normalization=0A=
				name =3D jQuery.camelCase( p );=0A=
				if ( p !=3D=3D name ) {=0A=
					prop[ name ] =3D prop[ p ];=0A=
					delete prop[ p ];=0A=
				}=0A=
=0A=
				val =3D prop[ name ];=0A=
=0A=
				// easing resolution: per property > opt.specialEasing > opt.easing =
> 'swing' (default)=0A=
				if ( jQuery.isArray( val ) ) {=0A=
					opt.animatedProperties[ name ] =3D val[ 1 ];=0A=
					val =3D prop[ name ] =3D val[ 0 ];=0A=
				} else {=0A=
					opt.animatedProperties[ name ] =3D opt.specialEasing && =
opt.specialEasing[ name ] || opt.easing || 'swing';=0A=
				}=0A=
=0A=
				if ( val =3D=3D=3D "hide" && hidden || val =3D=3D=3D "show" && =
!hidden ) {=0A=
					return opt.complete.call( this );=0A=
				}=0A=
=0A=
				if ( isElement && ( name =3D=3D=3D "height" || name =3D=3D=3D =
"width" ) ) {=0A=
					// Make sure that nothing sneaks out=0A=
					// Record all 3 overflow attributes because IE does not=0A=
					// change the overflow attribute when overflowX and=0A=
					// overflowY are set to the same value=0A=
					opt.overflow =3D [ this.style.overflow, this.style.overflowX, =
this.style.overflowY ];=0A=
=0A=
					// Set display property to inline-block for height/width=0A=
					// animations on inline elements that are having width/height=0A=
					// animated=0A=
					if ( jQuery.css( this, "display" ) =3D=3D=3D "inline" &&=0A=
							jQuery.css( this, "float" ) =3D=3D=3D "none" ) {=0A=
						if ( !jQuery.support.inlineBlockNeedsLayout ) {=0A=
							this.style.display =3D "inline-block";=0A=
=0A=
						} else {=0A=
							display =3D defaultDisplay( this.nodeName );=0A=
=0A=
							// inline-level elements accept inline-block;=0A=
							// block-level elements need to be inline with layout=0A=
							if ( display =3D=3D=3D "inline" ) {=0A=
								this.style.display =3D "inline-block";=0A=
=0A=
							} else {=0A=
								this.style.display =3D "inline";=0A=
								this.style.zoom =3D 1;=0A=
							}=0A=
						}=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			if ( opt.overflow !=3D null ) {=0A=
				this.style.overflow =3D "hidden";=0A=
			}=0A=
=0A=
			for ( p in prop ) {=0A=
				e =3D new jQuery.fx( this, opt, p );=0A=
				val =3D prop[ p ];=0A=
=0A=
				if ( rfxtypes.test(val) ) {=0A=
					e[ val =3D=3D=3D "toggle" ? hidden ? "show" : "hide" : val ]();=0A=
=0A=
				} else {=0A=
					parts =3D rfxnum.exec( val );=0A=
					start =3D e.cur();=0A=
=0A=
					if ( parts ) {=0A=
						end =3D parseFloat( parts[2] );=0A=
						unit =3D parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );=0A=
=0A=
						// We need to compute starting value=0A=
						if ( unit !=3D=3D "px" ) {=0A=
							jQuery.style( this, p, (end || 1) + unit);=0A=
							start =3D ((end || 1) / e.cur()) * start;=0A=
							jQuery.style( this, p, start + unit);=0A=
						}=0A=
=0A=
						// If a +=3D/-=3D token was provided, we're doing a relative =
animation=0A=
						if ( parts[1] ) {=0A=
							end =3D ( (parts[ 1 ] =3D=3D=3D "-=3D" ? -1 : 1) * end ) + start;=0A=
						}=0A=
=0A=
						e.custom( start, end, unit );=0A=
=0A=
					} else {=0A=
						e.custom( start, val, "" );=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			// For JS strict compliance=0A=
			return true;=0A=
		});=0A=
	},=0A=
=0A=
	stop: function( clearQueue, gotoEnd ) {=0A=
		if ( clearQueue ) {=0A=
			this.queue([]);=0A=
		}=0A=
=0A=
		this.each(function() {=0A=
			var timers =3D jQuery.timers,=0A=
				i =3D timers.length;=0A=
			// clear marker counters if we know they won't be=0A=
			if ( !gotoEnd ) {=0A=
				jQuery._unmark( true, this );=0A=
			}=0A=
			while ( i-- ) {=0A=
				if ( timers[i].elem =3D=3D=3D this ) {=0A=
					if (gotoEnd) {=0A=
						// force the next step to be the last=0A=
						timers[i](true);=0A=
					}=0A=
=0A=
					timers.splice(i, 1);=0A=
				}=0A=
			}=0A=
		});=0A=
=0A=
		// start the next in the queue if the last step wasn't forced=0A=
		if ( !gotoEnd ) {=0A=
			this.dequeue();=0A=
		}=0A=
=0A=
		return this;=0A=
	}=0A=
=0A=
});=0A=
=0A=
// Animations created synchronously will run synchronously=0A=
function createFxNow() {=0A=
	setTimeout( clearFxNow, 0 );=0A=
	return ( fxNow =3D jQuery.now() );=0A=
}=0A=
=0A=
function clearFxNow() {=0A=
	fxNow =3D undefined;=0A=
}=0A=
=0A=
// Generate parameters to create a standard animation=0A=
function genFx( type, num ) {=0A=
	var obj =3D {};=0A=
=0A=
	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() =
{=0A=
		obj[ this ] =3D type;=0A=
	});=0A=
=0A=
	return obj;=0A=
}=0A=
=0A=
// Generate shortcuts for custom animations=0A=
jQuery.each({=0A=
	slideDown: genFx("show", 1),=0A=
	slideUp: genFx("hide", 1),=0A=
	slideToggle: genFx("toggle", 1),=0A=
	fadeIn: { opacity: "show" },=0A=
	fadeOut: { opacity: "hide" },=0A=
	fadeToggle: { opacity: "toggle" }=0A=
}, function( name, props ) {=0A=
	jQuery.fn[ name ] =3D function( speed, easing, callback ) {=0A=
		return this.animate( props, speed, easing, callback );=0A=
	};=0A=
});=0A=
=0A=
jQuery.extend({=0A=
	speed: function( speed, easing, fn ) {=0A=
		var opt =3D speed && typeof speed =3D=3D=3D "object" ? =
jQuery.extend({}, speed) : {=0A=
			complete: fn || !fn && easing ||=0A=
				jQuery.isFunction( speed ) && speed,=0A=
			duration: speed,=0A=
			easing: fn && easing || easing && !jQuery.isFunction(easing) && easing=0A=
		};=0A=
=0A=
		opt.duration =3D jQuery.fx.off ? 0 : typeof opt.duration =3D=3D=3D =
"number" ? opt.duration :=0A=
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : =
jQuery.fx.speeds._default;=0A=
=0A=
		// Queueing=0A=
		opt.old =3D opt.complete;=0A=
		opt.complete =3D function( noUnmark ) {=0A=
			if ( jQuery.isFunction( opt.old ) ) {=0A=
				opt.old.call( this );=0A=
			}=0A=
=0A=
			if ( opt.queue !=3D=3D false ) {=0A=
				jQuery.dequeue( this );=0A=
			} else if ( noUnmark !=3D=3D false ) {=0A=
				jQuery._unmark( this );=0A=
			}=0A=
		};=0A=
=0A=
		return opt;=0A=
	},=0A=
=0A=
	easing: {=0A=
		linear: function( p, n, firstNum, diff ) {=0A=
			return firstNum + diff * p;=0A=
		},=0A=
		swing: function( p, n, firstNum, diff ) {=0A=
			return ((-Math.cos(p*Math.PI)/2) + 0.5) * diff + firstNum;=0A=
		}=0A=
	},=0A=
=0A=
	timers: [],=0A=
=0A=
	fx: function( elem, options, prop ) {=0A=
		this.options =3D options;=0A=
		this.elem =3D elem;=0A=
		this.prop =3D prop;=0A=
=0A=
		options.orig =3D options.orig || {};=0A=
	}=0A=
=0A=
});=0A=
=0A=
jQuery.fx.prototype =3D {=0A=
	// Simple function for setting a style value=0A=
	update: function() {=0A=
		if ( this.options.step ) {=0A=
			this.options.step.call( this.elem, this.now, this );=0A=
		}=0A=
=0A=
		(jQuery.fx.step[this.prop] || jQuery.fx.step._default)( this );=0A=
	},=0A=
=0A=
	// Get the current size=0A=
	cur: function() {=0A=
		if ( this.elem[this.prop] !=3D null && (!this.elem.style || =
this.elem.style[this.prop] =3D=3D null) ) {=0A=
			return this.elem[ this.prop ];=0A=
		}=0A=
=0A=
		var parsed,=0A=
			r =3D jQuery.css( this.elem, this.prop );=0A=
		// Empty strings, null, undefined and "auto" are converted to 0,=0A=
		// complex values such as "rotate(1rad)" are returned as is,=0A=
		// simple values such as "10px" are parsed to Float.=0A=
		return isNaN( parsed =3D parseFloat( r ) ) ? !r || r =3D=3D=3D "auto" =
? 0 : r : parsed;=0A=
	},=0A=
=0A=
	// Start an animation from one number to another=0A=
	custom: function( from, to, unit ) {=0A=
		var self =3D this,=0A=
			fx =3D jQuery.fx,=0A=
			raf;=0A=
=0A=
		this.startTime =3D fxNow || createFxNow();=0A=
		this.start =3D from;=0A=
		this.end =3D to;=0A=
		this.unit =3D unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? =
"" : "px" );=0A=
		this.now =3D this.start;=0A=
		this.pos =3D this.state =3D 0;=0A=
=0A=
		function t( gotoEnd ) {=0A=
			return self.step(gotoEnd);=0A=
		}=0A=
=0A=
		t.elem =3D this.elem;=0A=
=0A=
		if ( t() && jQuery.timers.push(t) && !timerId ) {=0A=
			// Use requestAnimationFrame instead of setInterval if available=0A=
			if ( requestAnimationFrame ) {=0A=
				timerId =3D true;=0A=
				raf =3D function() {=0A=
					// When timerId gets set to null at any point, this stops=0A=
					if ( timerId ) {=0A=
						requestAnimationFrame( raf );=0A=
						fx.tick();=0A=
					}=0A=
				};=0A=
				requestAnimationFrame( raf );=0A=
			} else {=0A=
				timerId =3D setInterval( fx.tick, fx.interval );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	// Simple 'show' function=0A=
	show: function() {=0A=
		// Remember where we started, so that we can go back to it later=0A=
		this.options.orig[this.prop] =3D jQuery.style( this.elem, this.prop );=0A=
		this.options.show =3D true;=0A=
=0A=
		// Begin the animation=0A=
		// Make sure that we start at a small width/height to avoid any=0A=
		// flash of content=0A=
		this.custom(this.prop =3D=3D=3D "width" || this.prop =3D=3D=3D =
"height" ? 1 : 0, this.cur());=0A=
=0A=
		// Start by showing the element=0A=
		jQuery( this.elem ).show();=0A=
	},=0A=
=0A=
	// Simple 'hide' function=0A=
	hide: function() {=0A=
		// Remember where we started, so that we can go back to it later=0A=
		this.options.orig[this.prop] =3D jQuery.style( this.elem, this.prop );=0A=
		this.options.hide =3D true;=0A=
=0A=
		// Begin the animation=0A=
		this.custom(this.cur(), 0);=0A=
	},=0A=
=0A=
	// Each step of an animation=0A=
	step: function( gotoEnd ) {=0A=
		var t =3D fxNow || createFxNow(),=0A=
			done =3D true,=0A=
			elem =3D this.elem,=0A=
			options =3D this.options,=0A=
			i, n;=0A=
=0A=
		if ( gotoEnd || t >=3D options.duration + this.startTime ) {=0A=
			this.now =3D this.end;=0A=
			this.pos =3D this.state =3D 1;=0A=
			this.update();=0A=
=0A=
			options.animatedProperties[ this.prop ] =3D true;=0A=
=0A=
			for ( i in options.animatedProperties ) {=0A=
				if ( options.animatedProperties[i] !=3D=3D true ) {=0A=
					done =3D false;=0A=
				}=0A=
			}=0A=
=0A=
			if ( done ) {=0A=
				// Reset the overflow=0A=
				if ( options.overflow !=3D null && !jQuery.support.shrinkWrapBlocks =
) {=0A=
=0A=
					jQuery.each( [ "", "X", "Y" ], function (index, value) {=0A=
						elem.style[ "overflow" + value ] =3D options.overflow[index];=0A=
					});=0A=
				}=0A=
=0A=
				// Hide the element if the "hide" operation was done=0A=
				if ( options.hide ) {=0A=
					jQuery(elem).hide();=0A=
				}=0A=
=0A=
				// Reset the properties, if the item has been hidden or shown=0A=
				if ( options.hide || options.show ) {=0A=
					for ( var p in options.animatedProperties ) {=0A=
						jQuery.style( elem, p, options.orig[p] );=0A=
					}=0A=
				}=0A=
=0A=
				// Execute the complete function=0A=
				options.complete.call( elem );=0A=
			}=0A=
=0A=
			return false;=0A=
=0A=
		} else {=0A=
			// classical easing cannot be used with an Infinity duration=0A=
			if ( options.duration =3D=3D Infinity ) {=0A=
				this.now =3D t;=0A=
			} else {=0A=
				n =3D t - this.startTime;=0A=
				this.state =3D n / options.duration;=0A=
=0A=
				// Perform the easing function, defaults to swing=0A=
				this.pos =3D jQuery.easing[ options.animatedProperties[ this.prop ] =
]( this.state, n, 0, 1, options.duration );=0A=
				this.now =3D this.start + ((this.end - this.start) * this.pos);=0A=
			}=0A=
			// Perform the next step of the animation=0A=
			this.update();=0A=
		}=0A=
=0A=
		return true;=0A=
	}=0A=
};=0A=
=0A=
jQuery.extend( jQuery.fx, {=0A=
	tick: function() {=0A=
		for ( var timers =3D jQuery.timers, i =3D 0 ; i < timers.length ; ++i =
) {=0A=
			if ( !timers[i]() ) {=0A=
				timers.splice(i--, 1);=0A=
			}=0A=
		}=0A=
=0A=
		if ( !timers.length ) {=0A=
			jQuery.fx.stop();=0A=
		}=0A=
	},=0A=
=0A=
	interval: 13,=0A=
=0A=
	stop: function() {=0A=
		clearInterval( timerId );=0A=
		timerId =3D null;=0A=
	},=0A=
=0A=
	speeds: {=0A=
		slow: 600,=0A=
		fast: 200,=0A=
		// Default speed=0A=
		_default: 400=0A=
	},=0A=
=0A=
	step: {=0A=
		opacity: function( fx ) {=0A=
			jQuery.style( fx.elem, "opacity", fx.now );=0A=
		},=0A=
=0A=
		_default: function( fx ) {=0A=
			if ( fx.elem.style && fx.elem.style[ fx.prop ] !=3D null ) {=0A=
				fx.elem.style[ fx.prop ] =3D (fx.prop =3D=3D=3D "width" || fx.prop =
=3D=3D=3D "height" ? Math.max(0, fx.now) : fx.now) + fx.unit;=0A=
			} else {=0A=
				fx.elem[ fx.prop ] =3D fx.now;=0A=
			}=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
if ( jQuery.expr && jQuery.expr.filters ) {=0A=
	jQuery.expr.filters.animated =3D function( elem ) {=0A=
		return jQuery.grep(jQuery.timers, function( fn ) {=0A=
			return elem =3D=3D=3D fn.elem;=0A=
		}).length;=0A=
	};=0A=
}=0A=
=0A=
// Try to restore the default display value of an element=0A=
function defaultDisplay( nodeName ) {=0A=
=0A=
	if ( !elemdisplay[ nodeName ] ) {=0A=
=0A=
		var body =3D document.body,=0A=
			elem =3D jQuery( "<" + nodeName + ">" ).appendTo( body ),=0A=
			display =3D elem.css( "display" );=0A=
=0A=
		elem.remove();=0A=
=0A=
		// If the simple way fails,=0A=
		// get element's real default display by attaching it to a temp iframe=0A=
		if ( display =3D=3D=3D "none" || display =3D=3D=3D "" ) {=0A=
			// No iframe to use yet, so create it=0A=
			if ( !iframe ) {=0A=
				iframe =3D document.createElement( "iframe" );=0A=
				iframe.frameBorder =3D iframe.width =3D iframe.height =3D 0;=0A=
			}=0A=
=0A=
			body.appendChild( iframe );=0A=
=0A=
			// Create a cacheable copy of the iframe document on first call.=0A=
			// IE and Opera will allow us to reuse the iframeDoc without =
re-writing the fake HTML=0A=
			// document to it; WebKit & Firefox won't allow reusing the iframe =
document.=0A=
			if ( !iframeDoc || !iframe.createElement ) {=0A=
				iframeDoc =3D ( iframe.contentWindow || iframe.contentDocument =
).document;=0A=
				iframeDoc.write( ( document.compatMode =3D=3D=3D "CSS1Compat" ? =
"<!doctype html>" : "" ) + "<html><body>" );=0A=
				iframeDoc.close();=0A=
			}=0A=
=0A=
			elem =3D iframeDoc.createElement( nodeName );=0A=
=0A=
			iframeDoc.body.appendChild( elem );=0A=
=0A=
			display =3D jQuery.css( elem, "display" );=0A=
=0A=
			body.removeChild( iframe );=0A=
		}=0A=
=0A=
		// Store the correct default display=0A=
		elemdisplay[ nodeName ] =3D display;=0A=
	}=0A=
=0A=
	return elemdisplay[ nodeName ];=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
var rtable =3D /^t(?:able|d|h)$/i,=0A=
	rroot =3D /^(?:body|html)$/i;=0A=
=0A=
if ( "getBoundingClientRect" in document.documentElement ) {=0A=
	jQuery.fn.offset =3D function( options ) {=0A=
		var elem =3D this[0], box;=0A=
=0A=
		if ( options ) {=0A=
			return this.each(function( i ) {=0A=
				jQuery.offset.setOffset( this, options, i );=0A=
			});=0A=
		}=0A=
=0A=
		if ( !elem || !elem.ownerDocument ) {=0A=
			return null;=0A=
		}=0A=
=0A=
		if ( elem =3D=3D=3D elem.ownerDocument.body ) {=0A=
			return jQuery.offset.bodyOffset( elem );=0A=
		}=0A=
=0A=
		try {=0A=
			box =3D elem.getBoundingClientRect();=0A=
		} catch(e) {}=0A=
=0A=
		var doc =3D elem.ownerDocument,=0A=
			docElem =3D doc.documentElement;=0A=
=0A=
		// Make sure we're not dealing with a disconnected DOM node=0A=
		if ( !box || !jQuery.contains( docElem, elem ) ) {=0A=
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };=0A=
		}=0A=
=0A=
		var body =3D doc.body,=0A=
			win =3D getWindow(doc),=0A=
			clientTop  =3D docElem.clientTop  || body.clientTop  || 0,=0A=
			clientLeft =3D docElem.clientLeft || body.clientLeft || 0,=0A=
			scrollTop  =3D win.pageYOffset || jQuery.support.boxModel && =
docElem.scrollTop  || body.scrollTop,=0A=
			scrollLeft =3D win.pageXOffset || jQuery.support.boxModel && =
docElem.scrollLeft || body.scrollLeft,=0A=
			top  =3D box.top  + scrollTop  - clientTop,=0A=
			left =3D box.left + scrollLeft - clientLeft;=0A=
=0A=
		return { top: top, left: left };=0A=
	};=0A=
=0A=
} else {=0A=
	jQuery.fn.offset =3D function( options ) {=0A=
		var elem =3D this[0];=0A=
=0A=
		if ( options ) {=0A=
			return this.each(function( i ) {=0A=
				jQuery.offset.setOffset( this, options, i );=0A=
			});=0A=
		}=0A=
=0A=
		if ( !elem || !elem.ownerDocument ) {=0A=
			return null;=0A=
		}=0A=
=0A=
		if ( elem =3D=3D=3D elem.ownerDocument.body ) {=0A=
			return jQuery.offset.bodyOffset( elem );=0A=
		}=0A=
=0A=
		jQuery.offset.initialize();=0A=
=0A=
		var computedStyle,=0A=
			offsetParent =3D elem.offsetParent,=0A=
			prevOffsetParent =3D elem,=0A=
			doc =3D elem.ownerDocument,=0A=
			docElem =3D doc.documentElement,=0A=
			body =3D doc.body,=0A=
			defaultView =3D doc.defaultView,=0A=
			prevComputedStyle =3D defaultView ? defaultView.getComputedStyle( =
elem, null ) : elem.currentStyle,=0A=
			top =3D elem.offsetTop,=0A=
			left =3D elem.offsetLeft;=0A=
=0A=
		while ( (elem =3D elem.parentNode) && elem !=3D=3D body && elem =
!=3D=3D docElem ) {=0A=
			if ( jQuery.offset.supportsFixedPosition && =
prevComputedStyle.position =3D=3D=3D "fixed" ) {=0A=
				break;=0A=
			}=0A=
=0A=
			computedStyle =3D defaultView ? defaultView.getComputedStyle(elem, =
null) : elem.currentStyle;=0A=
			top  -=3D elem.scrollTop;=0A=
			left -=3D elem.scrollLeft;=0A=
=0A=
			if ( elem =3D=3D=3D offsetParent ) {=0A=
				top  +=3D elem.offsetTop;=0A=
				left +=3D elem.offsetLeft;=0A=
=0A=
				if ( jQuery.offset.doesNotAddBorder && =
!(jQuery.offset.doesAddBorderForTableAndCells && =
rtable.test(elem.nodeName)) ) {=0A=
					top  +=3D parseFloat( computedStyle.borderTopWidth  ) || 0;=0A=
					left +=3D parseFloat( computedStyle.borderLeftWidth ) || 0;=0A=
				}=0A=
=0A=
				prevOffsetParent =3D offsetParent;=0A=
				offsetParent =3D elem.offsetParent;=0A=
			}=0A=
=0A=
			if ( jQuery.offset.subtractsBorderForOverflowNotVisible && =
computedStyle.overflow !=3D=3D "visible" ) {=0A=
				top  +=3D parseFloat( computedStyle.borderTopWidth  ) || 0;=0A=
				left +=3D parseFloat( computedStyle.borderLeftWidth ) || 0;=0A=
			}=0A=
=0A=
			prevComputedStyle =3D computedStyle;=0A=
		}=0A=
=0A=
		if ( prevComputedStyle.position =3D=3D=3D "relative" || =
prevComputedStyle.position =3D=3D=3D "static" ) {=0A=
			top  +=3D body.offsetTop;=0A=
			left +=3D body.offsetLeft;=0A=
		}=0A=
=0A=
		if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position =
=3D=3D=3D "fixed" ) {=0A=
			top  +=3D Math.max( docElem.scrollTop, body.scrollTop );=0A=
			left +=3D Math.max( docElem.scrollLeft, body.scrollLeft );=0A=
		}=0A=
=0A=
		return { top: top, left: left };=0A=
	};=0A=
}=0A=
=0A=
jQuery.offset =3D {=0A=
	initialize: function() {=0A=
		var body =3D document.body, container =3D =
document.createElement("div"), innerDiv, checkDiv, table, td, =
bodyMarginTop =3D parseFloat( jQuery.css(body, "marginTop") ) || 0,=0A=
			html =3D "<div =
style=3D'position:absolute;top:0;left:0;margin:0;border:5px solid =
#000;padding:0;width:1px;height:1px;'><div></div></div><table =
style=3D'position:absolute;top:0;left:0;margin:0;border:5px solid =
#000;padding:0;width:1px;height:1px;' cellpadding=3D'0' =
cellspacing=3D'0'><tr><td></td></tr></table>";=0A=
=0A=
		jQuery.extend( container.style, { position: "absolute", top: 0, left: =
0, margin: 0, border: 0, width: "1px", height: "1px", visibility: =
"hidden" } );=0A=
=0A=
		container.innerHTML =3D html;=0A=
		body.insertBefore( container, body.firstChild );=0A=
		innerDiv =3D container.firstChild;=0A=
		checkDiv =3D innerDiv.firstChild;=0A=
		td =3D innerDiv.nextSibling.firstChild.firstChild;=0A=
=0A=
		this.doesNotAddBorder =3D (checkDiv.offsetTop !=3D=3D 5);=0A=
		this.doesAddBorderForTableAndCells =3D (td.offsetTop =3D=3D=3D 5);=0A=
=0A=
		checkDiv.style.position =3D "fixed";=0A=
		checkDiv.style.top =3D "20px";=0A=
=0A=
		// safari subtracts parent border width here which is 5px=0A=
		this.supportsFixedPosition =3D (checkDiv.offsetTop =3D=3D=3D 20 || =
checkDiv.offsetTop =3D=3D=3D 15);=0A=
		checkDiv.style.position =3D checkDiv.style.top =3D "";=0A=
=0A=
		innerDiv.style.overflow =3D "hidden";=0A=
		innerDiv.style.position =3D "relative";=0A=
=0A=
		this.subtractsBorderForOverflowNotVisible =3D (checkDiv.offsetTop =
=3D=3D=3D -5);=0A=
=0A=
		this.doesNotIncludeMarginInBodyOffset =3D (body.offsetTop !=3D=3D =
bodyMarginTop);=0A=
=0A=
		body.removeChild( container );=0A=
		jQuery.offset.initialize =3D jQuery.noop;=0A=
	},=0A=
=0A=
	bodyOffset: function( body ) {=0A=
		var top =3D body.offsetTop,=0A=
			left =3D body.offsetLeft;=0A=
=0A=
		jQuery.offset.initialize();=0A=
=0A=
		if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) {=0A=
			top  +=3D parseFloat( jQuery.css(body, "marginTop") ) || 0;=0A=
			left +=3D parseFloat( jQuery.css(body, "marginLeft") ) || 0;=0A=
		}=0A=
=0A=
		return { top: top, left: left };=0A=
	},=0A=
=0A=
	setOffset: function( elem, options, i ) {=0A=
		var position =3D jQuery.css( elem, "position" );=0A=
=0A=
		// set position first, in-case top/left are set even on static elem=0A=
		if ( position =3D=3D=3D "static" ) {=0A=
			elem.style.position =3D "relative";=0A=
		}=0A=
=0A=
		var curElem =3D jQuery( elem ),=0A=
			curOffset =3D curElem.offset(),=0A=
			curCSSTop =3D jQuery.css( elem, "top" ),=0A=
			curCSSLeft =3D jQuery.css( elem, "left" ),=0A=
			calculatePosition =3D (position =3D=3D=3D "absolute" || position =
=3D=3D=3D "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > =
-1,=0A=
			props =3D {}, curPosition =3D {}, curTop, curLeft;=0A=
=0A=
		// need to be able to calculate position if either top or left is auto =
and position is either absolute or fixed=0A=
		if ( calculatePosition ) {=0A=
			curPosition =3D curElem.position();=0A=
			curTop =3D curPosition.top;=0A=
			curLeft =3D curPosition.left;=0A=
		} else {=0A=
			curTop =3D parseFloat( curCSSTop ) || 0;=0A=
			curLeft =3D parseFloat( curCSSLeft ) || 0;=0A=
		}=0A=
=0A=
		if ( jQuery.isFunction( options ) ) {=0A=
			options =3D options.call( elem, i, curOffset );=0A=
		}=0A=
=0A=
		if (options.top !=3D null) {=0A=
			props.top =3D (options.top - curOffset.top) + curTop;=0A=
		}=0A=
		if (options.left !=3D null) {=0A=
			props.left =3D (options.left - curOffset.left) + curLeft;=0A=
		}=0A=
=0A=
		if ( "using" in options ) {=0A=
			options.using.call( elem, props );=0A=
		} else {=0A=
			curElem.css( props );=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
=0A=
jQuery.fn.extend({=0A=
	position: function() {=0A=
		if ( !this[0] ) {=0A=
			return null;=0A=
		}=0A=
=0A=
		var elem =3D this[0],=0A=
=0A=
		// Get *real* offsetParent=0A=
		offsetParent =3D this.offsetParent(),=0A=
=0A=
		// Get correct offsets=0A=
		offset       =3D this.offset(),=0A=
		parentOffset =3D rroot.test(offsetParent[0].nodeName) ? { top: 0, =
left: 0 } : offsetParent.offset();=0A=
=0A=
		// Subtract element margins=0A=
		// note: when an element has margin: auto the offsetLeft and marginLeft=0A=
		// are the same in Safari causing offset.left to incorrectly be 0=0A=
		offset.top  -=3D parseFloat( jQuery.css(elem, "marginTop") ) || 0;=0A=
		offset.left -=3D parseFloat( jQuery.css(elem, "marginLeft") ) || 0;=0A=
=0A=
		// Add offsetParent borders=0A=
		parentOffset.top  +=3D parseFloat( jQuery.css(offsetParent[0], =
"borderTopWidth") ) || 0;=0A=
		parentOffset.left +=3D parseFloat( jQuery.css(offsetParent[0], =
"borderLeftWidth") ) || 0;=0A=
=0A=
		// Subtract the two offsets=0A=
		return {=0A=
			top:  offset.top  - parentOffset.top,=0A=
			left: offset.left - parentOffset.left=0A=
		};=0A=
	},=0A=
=0A=
	offsetParent: function() {=0A=
		return this.map(function() {=0A=
			var offsetParent =3D this.offsetParent || document.body;=0A=
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && =
jQuery.css(offsetParent, "position") =3D=3D=3D "static") ) {=0A=
				offsetParent =3D offsetParent.offsetParent;=0A=
			}=0A=
			return offsetParent;=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
=0A=
// Create scrollLeft and scrollTop methods=0A=
jQuery.each( ["Left", "Top"], function( i, name ) {=0A=
	var method =3D "scroll" + name;=0A=
=0A=
	jQuery.fn[ method ] =3D function( val ) {=0A=
		var elem, win;=0A=
=0A=
		if ( val =3D=3D=3D undefined ) {=0A=
			elem =3D this[ 0 ];=0A=
=0A=
			if ( !elem ) {=0A=
				return null;=0A=
			}=0A=
=0A=
			win =3D getWindow( elem );=0A=
=0A=
			// Return the scroll offset=0A=
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : =
"pageXOffset" ] :=0A=
				jQuery.support.boxModel && win.document.documentElement[ method ] ||=0A=
					win.document.body[ method ] :=0A=
				elem[ method ];=0A=
		}=0A=
=0A=
		// Set the scroll offset=0A=
		return this.each(function() {=0A=
			win =3D getWindow( this );=0A=
=0A=
			if ( win ) {=0A=
				win.scrollTo(=0A=
					!i ? val : jQuery( win ).scrollLeft(),=0A=
					 i ? val : jQuery( win ).scrollTop()=0A=
				);=0A=
=0A=
			} else {=0A=
				this[ method ] =3D val;=0A=
			}=0A=
		});=0A=
	};=0A=
});=0A=
=0A=
function getWindow( elem ) {=0A=
	return jQuery.isWindow( elem ) ?=0A=
		elem :=0A=
		elem.nodeType =3D=3D=3D 9 ?=0A=
			elem.defaultView || elem.parentWindow :=0A=
			false;=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
// Create width, height, innerHeight, innerWidth, outerHeight and =
outerWidth methods=0A=
jQuery.each([ "Height", "Width" ], function( i, name ) {=0A=
=0A=
	var type =3D name.toLowerCase();=0A=
=0A=
	// innerHeight and innerWidth=0A=
	jQuery.fn[ "inner" + name ] =3D function() {=0A=
		var elem =3D this[0];=0A=
		return elem && elem.style ?=0A=
			parseFloat( jQuery.css( elem, type, "padding" ) ) :=0A=
			null;=0A=
	};=0A=
=0A=
	// outerHeight and outerWidth=0A=
	jQuery.fn[ "outer" + name ] =3D function( margin ) {=0A=
		var elem =3D this[0];=0A=
		return elem && elem.style ?=0A=
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :=0A=
			null;=0A=
	};=0A=
=0A=
	jQuery.fn[ type ] =3D function( size ) {=0A=
		// Get window width or height=0A=
		var elem =3D this[0];=0A=
		if ( !elem ) {=0A=
			return size =3D=3D null ? null : this;=0A=
		}=0A=
=0A=
		if ( jQuery.isFunction( size ) ) {=0A=
			return this.each(function( i ) {=0A=
				var self =3D jQuery( this );=0A=
				self[ type ]( size.call( this, i, self[ type ]() ) );=0A=
			});=0A=
		}=0A=
=0A=
		if ( jQuery.isWindow( elem ) ) {=0A=
			// Everyone else use document.documentElement or document.body =
depending on Quirks vs Standards mode=0A=
			// 3rd condition allows Nokia support, as it supports the docElem =
prop but not CSS1Compat=0A=
			var docElemProp =3D elem.document.documentElement[ "client" + name ];=0A=
			return elem.document.compatMode =3D=3D=3D "CSS1Compat" && docElemProp =
||=0A=
				elem.document.body[ "client" + name ] || docElemProp;=0A=
=0A=
		// Get document width or height=0A=
		} else if ( elem.nodeType =3D=3D=3D 9 ) {=0A=
			// Either scroll[Width/Height] or offset[Width/Height], whichever is =
greater=0A=
			return Math.max(=0A=
				elem.documentElement["client" + name],=0A=
				elem.body["scroll" + name], elem.documentElement["scroll" + name],=0A=
				elem.body["offset" + name], elem.documentElement["offset" + name]=0A=
			);=0A=
=0A=
		// Get or set width or height on the element=0A=
		} else if ( size =3D=3D=3D undefined ) {=0A=
			var orig =3D jQuery.css( elem, type ),=0A=
				ret =3D parseFloat( orig );=0A=
=0A=
			return jQuery.isNaN( ret ) ? orig : ret;=0A=
=0A=
		// Set the width or height on the element (default to pixels if value =
is unitless)=0A=
		} else {=0A=
			return this.css( type, typeof size =3D=3D=3D "string" ? size : size + =
"px" );=0A=
		}=0A=
	};=0A=
=0A=
});=0A=
=0A=
=0A=
// Expose jQuery to the global object=0A=
window.jQuery =3D window.$ =3D jQuery;=0A=
})(window);=0A=

------=_NextPart_000_0000_01CD8C89.6E361A20
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://docs.opencv.org/_static/underscore.js

//     Underscore.js 1.1.6=0A=
//     (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.=0A=
//     Underscore is freely distributable under the MIT license.=0A=
//     Portions of Underscore are inspired or borrowed from Prototype,=0A=
//     Oliver Steele's Functional, and John Resig's Micro-Templating.=0A=
//     For all details and documentation:=0A=
//     http://documentcloud.github.com/underscore=0A=
=0A=
(function() {=0A=
=0A=
  // Baseline setup=0A=
  // --------------=0A=
=0A=
  // Establish the root object, `window` in the browser, or `global` on =
the server.=0A=
  var root =3D this;=0A=
=0A=
  // Save the previous value of the `_` variable.=0A=
  var previousUnderscore =3D root._;=0A=
=0A=
  // Establish the object that gets returned to break out of a loop =
iteration.=0A=
  var breaker =3D {};=0A=
=0A=
  // Save bytes in the minified (but not gzipped) version:=0A=
  var ArrayProto =3D Array.prototype, ObjProto =3D Object.prototype, =
FuncProto =3D Function.prototype;=0A=
=0A=
  // Create quick reference variables for speed access to core =
prototypes.=0A=
  var slice            =3D ArrayProto.slice,=0A=
      unshift          =3D ArrayProto.unshift,=0A=
      toString         =3D ObjProto.toString,=0A=
      hasOwnProperty   =3D ObjProto.hasOwnProperty;=0A=
=0A=
  // All **ECMAScript 5** native function implementations that we hope =
to use=0A=
  // are declared here.=0A=
  var=0A=
    nativeForEach      =3D ArrayProto.forEach,=0A=
    nativeMap          =3D ArrayProto.map,=0A=
    nativeReduce       =3D ArrayProto.reduce,=0A=
    nativeReduceRight  =3D ArrayProto.reduceRight,=0A=
    nativeFilter       =3D ArrayProto.filter,=0A=
    nativeEvery        =3D ArrayProto.every,=0A=
    nativeSome         =3D ArrayProto.some,=0A=
    nativeIndexOf      =3D ArrayProto.indexOf,=0A=
    nativeLastIndexOf  =3D ArrayProto.lastIndexOf,=0A=
    nativeIsArray      =3D Array.isArray,=0A=
    nativeKeys         =3D Object.keys,=0A=
    nativeBind         =3D FuncProto.bind;=0A=
=0A=
  // Create a safe reference to the Underscore object for use below.=0A=
  var _ =3D function(obj) { return new wrapper(obj); };=0A=
=0A=
  // Export the Underscore object for **CommonJS**, with =
backwards-compatibility=0A=
  // for the old `require()` API. If we're not in CommonJS, add `_` to =
the=0A=
  // global object.=0A=
  if (typeof module !=3D=3D 'undefined' && module.exports) {=0A=
    module.exports =3D _;=0A=
    _._ =3D _;=0A=
  } else {=0A=
    root._ =3D _;=0A=
  }=0A=
=0A=
  // Current version.=0A=
  _.VERSION =3D '1.1.6';=0A=
=0A=
  // Collection Functions=0A=
  // --------------------=0A=
=0A=
  // The cornerstone, an `each` implementation, aka `forEach`.=0A=
  // Handles objects implementing `forEach`, arrays, and raw objects.=0A=
  // Delegates to **ECMAScript 5**'s native `forEach` if available.=0A=
  var each =3D _.each =3D _.forEach =3D function(obj, iterator, context) =
{=0A=
    if (obj =3D=3D null) return;=0A=
    if (nativeForEach && obj.forEach =3D=3D=3D nativeForEach) {=0A=
      obj.forEach(iterator, context);=0A=
    } else if (_.isNumber(obj.length)) {=0A=
      for (var i =3D 0, l =3D obj.length; i < l; i++) {=0A=
        if (iterator.call(context, obj[i], i, obj) =3D=3D=3D breaker) =
return;=0A=
      }=0A=
    } else {=0A=
      for (var key in obj) {=0A=
        if (hasOwnProperty.call(obj, key)) {=0A=
          if (iterator.call(context, obj[key], key, obj) =3D=3D=3D =
breaker) return;=0A=
        }=0A=
      }=0A=
    }=0A=
  };=0A=
=0A=
  // Return the results of applying the iterator to each element.=0A=
  // Delegates to **ECMAScript 5**'s native `map` if available.=0A=
  _.map =3D function(obj, iterator, context) {=0A=
    var results =3D [];=0A=
    if (obj =3D=3D null) return results;=0A=
    if (nativeMap && obj.map =3D=3D=3D nativeMap) return =
obj.map(iterator, context);=0A=
    each(obj, function(value, index, list) {=0A=
      results[results.length] =3D iterator.call(context, value, index, =
list);=0A=
    });=0A=
    return results;=0A=
  };=0A=
=0A=
  // **Reduce** builds up a single result from a list of values, aka =
`inject`,=0A=
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if =
available.=0A=
  _.reduce =3D _.foldl =3D _.inject =3D function(obj, iterator, memo, =
context) {=0A=
    var initial =3D memo !=3D=3D void 0;=0A=
    if (obj =3D=3D null) obj =3D [];=0A=
    if (nativeReduce && obj.reduce =3D=3D=3D nativeReduce) {=0A=
      if (context) iterator =3D _.bind(iterator, context);=0A=
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);=0A=
    }=0A=
    each(obj, function(value, index, list) {=0A=
      if (!initial && index =3D=3D=3D 0) {=0A=
        memo =3D value;=0A=
        initial =3D true;=0A=
      } else {=0A=
        memo =3D iterator.call(context, memo, value, index, list);=0A=
      }=0A=
    });=0A=
    if (!initial) throw new TypeError("Reduce of empty array with no =
initial value");=0A=
    return memo;=0A=
  };=0A=
=0A=
  // The right-associative version of reduce, also known as `foldr`.=0A=
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.=0A=
  _.reduceRight =3D _.foldr =3D function(obj, iterator, memo, context) {=0A=
    if (obj =3D=3D null) obj =3D [];=0A=
    if (nativeReduceRight && obj.reduceRight =3D=3D=3D =
nativeReduceRight) {=0A=
      if (context) iterator =3D _.bind(iterator, context);=0A=
      return memo !=3D=3D void 0 ? obj.reduceRight(iterator, memo) : =
obj.reduceRight(iterator);=0A=
    }=0A=
    var reversed =3D (_.isArray(obj) ? obj.slice() : =
_.toArray(obj)).reverse();=0A=
    return _.reduce(reversed, iterator, memo, context);=0A=
  };=0A=
=0A=
  // Return the first value which passes a truth test. Aliased as =
`detect`.=0A=
  _.find =3D _.detect =3D function(obj, iterator, context) {=0A=
    var result;=0A=
    any(obj, function(value, index, list) {=0A=
      if (iterator.call(context, value, index, list)) {=0A=
        result =3D value;=0A=
        return true;=0A=
      }=0A=
    });=0A=
    return result;=0A=
  };=0A=
=0A=
  // Return all the elements that pass a truth test.=0A=
  // Delegates to **ECMAScript 5**'s native `filter` if available.=0A=
  // Aliased as `select`.=0A=
  _.filter =3D _.select =3D function(obj, iterator, context) {=0A=
    var results =3D [];=0A=
    if (obj =3D=3D null) return results;=0A=
    if (nativeFilter && obj.filter =3D=3D=3D nativeFilter) return =
obj.filter(iterator, context);=0A=
    each(obj, function(value, index, list) {=0A=
      if (iterator.call(context, value, index, list)) =
results[results.length] =3D value;=0A=
    });=0A=
    return results;=0A=
  };=0A=
=0A=
  // Return all the elements for which a truth test fails.=0A=
  _.reject =3D function(obj, iterator, context) {=0A=
    var results =3D [];=0A=
    if (obj =3D=3D null) return results;=0A=
    each(obj, function(value, index, list) {=0A=
      if (!iterator.call(context, value, index, list)) =
results[results.length] =3D value;=0A=
    });=0A=
    return results;=0A=
  };=0A=
=0A=
  // Determine whether all of the elements match a truth test.=0A=
  // Delegates to **ECMAScript 5**'s native `every` if available.=0A=
  // Aliased as `all`.=0A=
  _.every =3D _.all =3D function(obj, iterator, context) {=0A=
    var result =3D true;=0A=
    if (obj =3D=3D null) return result;=0A=
    if (nativeEvery && obj.every =3D=3D=3D nativeEvery) return =
obj.every(iterator, context);=0A=
    each(obj, function(value, index, list) {=0A=
      if (!(result =3D result && iterator.call(context, value, index, =
list))) return breaker;=0A=
    });=0A=
    return result;=0A=
  };=0A=
=0A=
  // Determine if at least one element in the object matches a truth =
test.=0A=
  // Delegates to **ECMAScript 5**'s native `some` if available.=0A=
  // Aliased as `any`.=0A=
  var any =3D _.some =3D _.any =3D function(obj, iterator, context) {=0A=
    iterator || (iterator =3D _.identity);=0A=
    var result =3D false;=0A=
    if (obj =3D=3D null) return result;=0A=
    if (nativeSome && obj.some =3D=3D=3D nativeSome) return =
obj.some(iterator, context);=0A=
    each(obj, function(value, index, list) {=0A=
      if (result =3D iterator.call(context, value, index, list)) return =
breaker;=0A=
    });=0A=
    return result;=0A=
  };=0A=
=0A=
  // Determine if a given value is included in the array or object using =
`=3D=3D=3D`.=0A=
  // Aliased as `contains`.=0A=
  _.include =3D _.contains =3D function(obj, target) {=0A=
    var found =3D false;=0A=
    if (obj =3D=3D null) return found;=0A=
    if (nativeIndexOf && obj.indexOf =3D=3D=3D nativeIndexOf) return =
obj.indexOf(target) !=3D -1;=0A=
    any(obj, function(value) {=0A=
      if (found =3D value =3D=3D=3D target) return true;=0A=
    });=0A=
    return found;=0A=
  };=0A=
=0A=
  // Invoke a method (with arguments) on every item in a collection.=0A=
  _.invoke =3D function(obj, method) {=0A=
    var args =3D slice.call(arguments, 2);=0A=
    return _.map(obj, function(value) {=0A=
      return (method.call ? method || value : =
value[method]).apply(value, args);=0A=
    });=0A=
  };=0A=
=0A=
  // Convenience version of a common use case of `map`: fetching a =
property.=0A=
  _.pluck =3D function(obj, key) {=0A=
    return _.map(obj, function(value){ return value[key]; });=0A=
  };=0A=
=0A=
  // Return the maximum element or (element-based computation).=0A=
  _.max =3D function(obj, iterator, context) {=0A=
    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);=0A=
    var result =3D {computed : -Infinity};=0A=
    each(obj, function(value, index, list) {=0A=
      var computed =3D iterator ? iterator.call(context, value, index, =
list) : value;=0A=
      computed >=3D result.computed && (result =3D {value : value, =
computed : computed});=0A=
    });=0A=
    return result.value;=0A=
  };=0A=
=0A=
  // Return the minimum element (or element-based computation).=0A=
  _.min =3D function(obj, iterator, context) {=0A=
    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);=0A=
    var result =3D {computed : Infinity};=0A=
    each(obj, function(value, index, list) {=0A=
      var computed =3D iterator ? iterator.call(context, value, index, =
list) : value;=0A=
      computed < result.computed && (result =3D {value : value, computed =
: computed});=0A=
    });=0A=
    return result.value;=0A=
  };=0A=
=0A=
  // Sort the object's values by a criterion produced by an iterator.=0A=
  _.sortBy =3D function(obj, iterator, context) {=0A=
    return _.pluck(_.map(obj, function(value, index, list) {=0A=
      return {=0A=
        value : value,=0A=
        criteria : iterator.call(context, value, index, list)=0A=
      };=0A=
    }).sort(function(left, right) {=0A=
      var a =3D left.criteria, b =3D right.criteria;=0A=
      return a < b ? -1 : a > b ? 1 : 0;=0A=
    }), 'value');=0A=
  };=0A=
=0A=
  // Use a comparator function to figure out at what index an object =
should=0A=
  // be inserted so as to maintain order. Uses binary search.=0A=
  _.sortedIndex =3D function(array, obj, iterator) {=0A=
    iterator || (iterator =3D _.identity);=0A=
    var low =3D 0, high =3D array.length;=0A=
    while (low < high) {=0A=
      var mid =3D (low + high) >> 1;=0A=
      iterator(array[mid]) < iterator(obj) ? low =3D mid + 1 : high =3D =
mid;=0A=
    }=0A=
    return low;=0A=
  };=0A=
=0A=
  // Safely convert anything iterable into a real, live array.=0A=
  _.toArray =3D function(iterable) {=0A=
    if (!iterable)                return [];=0A=
    if (iterable.toArray)         return iterable.toArray();=0A=
    if (_.isArray(iterable))      return iterable;=0A=
    if (_.isArguments(iterable))  return slice.call(iterable);=0A=
    return _.values(iterable);=0A=
  };=0A=
=0A=
  // Return the number of elements in an object.=0A=
  _.size =3D function(obj) {=0A=
    return _.toArray(obj).length;=0A=
  };=0A=
=0A=
  // Array Functions=0A=
  // ---------------=0A=
=0A=
  // Get the first element of an array. Passing **n** will return the =
first N=0A=
  // values in the array. Aliased as `head`. The **guard** check allows =
it to work=0A=
  // with `_.map`.=0A=
  _.first =3D _.head =3D function(array, n, guard) {=0A=
    return (n !=3D null) && !guard ? slice.call(array, 0, n) : array[0];=0A=
  };=0A=
=0A=
  // Returns everything but the first entry of the array. Aliased as =
`tail`.=0A=
  // Especially useful on the arguments object. Passing an **index** =
will return=0A=
  // the rest of the values in the array from that index onward. The =
**guard**=0A=
  // check allows it to work with `_.map`.=0A=
  _.rest =3D _.tail =3D function(array, index, guard) {=0A=
    return slice.call(array, (index =3D=3D null) || guard ? 1 : index);=0A=
  };=0A=
=0A=
  // Get the last element of an array.=0A=
  _.last =3D function(array) {=0A=
    return array[array.length - 1];=0A=
  };=0A=
=0A=
  // Trim out all falsy values from an array.=0A=
  _.compact =3D function(array) {=0A=
    return _.filter(array, function(value){ return !!value; });=0A=
  };=0A=
=0A=
  // Return a completely flattened version of an array.=0A=
  _.flatten =3D function(array) {=0A=
    return _.reduce(array, function(memo, value) {=0A=
      if (_.isArray(value)) return memo.concat(_.flatten(value));=0A=
      memo[memo.length] =3D value;=0A=
      return memo;=0A=
    }, []);=0A=
  };=0A=
=0A=
  // Return a version of the array that does not contain the specified =
value(s).=0A=
  _.without =3D function(array) {=0A=
    var values =3D slice.call(arguments, 1);=0A=
    return _.filter(array, function(value){ return !_.include(values, =
value); });=0A=
  };=0A=
=0A=
  // Produce a duplicate-free version of the array. If the array has =
already=0A=
  // been sorted, you have the option of using a faster algorithm.=0A=
  // Aliased as `unique`.=0A=
  _.uniq =3D _.unique =3D function(array, isSorted) {=0A=
    return _.reduce(array, function(memo, el, i) {=0A=
      if (0 =3D=3D i || (isSorted =3D=3D=3D true ? _.last(memo) !=3D el =
: !_.include(memo, el))) memo[memo.length] =3D el;=0A=
      return memo;=0A=
    }, []);=0A=
  };=0A=
=0A=
  // Produce an array that contains every item shared between all the=0A=
  // passed-in arrays.=0A=
  _.intersect =3D function(array) {=0A=
    var rest =3D slice.call(arguments, 1);=0A=
    return _.filter(_.uniq(array), function(item) {=0A=
      return _.every(rest, function(other) {=0A=
        return _.indexOf(other, item) >=3D 0;=0A=
      });=0A=
    });=0A=
  };=0A=
=0A=
  // Zip together multiple lists into a single array -- elements that =
share=0A=
  // an index go together.=0A=
  _.zip =3D function() {=0A=
    var args =3D slice.call(arguments);=0A=
    var length =3D _.max(_.pluck(args, 'length'));=0A=
    var results =3D new Array(length);=0A=
    for (var i =3D 0; i < length; i++) results[i] =3D _.pluck(args, "" + =
i);=0A=
    return results;=0A=
  };=0A=
=0A=
  // If the browser doesn't supply us with indexOf (I'm looking at you, =
**MSIE**),=0A=
  // we need this function. Return the position of the first occurrence =
of an=0A=
  // item in an array, or -1 if the item is not included in the array.=0A=
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.=0A=
  // If the array is large and already in sort order, pass `true`=0A=
  // for **isSorted** to use binary search.=0A=
  _.indexOf =3D function(array, item, isSorted) {=0A=
    if (array =3D=3D null) return -1;=0A=
    var i, l;=0A=
    if (isSorted) {=0A=
      i =3D _.sortedIndex(array, item);=0A=
      return array[i] =3D=3D=3D item ? i : -1;=0A=
    }=0A=
    if (nativeIndexOf && array.indexOf =3D=3D=3D nativeIndexOf) return =
array.indexOf(item);=0A=
    for (i =3D 0, l =3D array.length; i < l; i++) if (array[i] =3D=3D=3D =
item) return i;=0A=
    return -1;=0A=
  };=0A=
=0A=
=0A=
  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.=0A=
  _.lastIndexOf =3D function(array, item) {=0A=
    if (array =3D=3D null) return -1;=0A=
    if (nativeLastIndexOf && array.lastIndexOf =3D=3D=3D =
nativeLastIndexOf) return array.lastIndexOf(item);=0A=
    var i =3D array.length;=0A=
    while (i--) if (array[i] =3D=3D=3D item) return i;=0A=
    return -1;=0A=
  };=0A=
=0A=
  // Generate an integer Array containing an arithmetic progression. A =
port of=0A=
  // the native Python `range()` function. See=0A=
  // [the Python =
documentation](http://docs.python.org/library/functions.html#range).=0A=
  _.range =3D function(start, stop, step) {=0A=
    if (arguments.length <=3D 1) {=0A=
      stop =3D start || 0;=0A=
      start =3D 0;=0A=
    }=0A=
    step =3D arguments[2] || 1;=0A=
=0A=
    var len =3D Math.max(Math.ceil((stop - start) / step), 0);=0A=
    var idx =3D 0;=0A=
    var range =3D new Array(len);=0A=
=0A=
    while(idx < len) {=0A=
      range[idx++] =3D start;=0A=
      start +=3D step;=0A=
    }=0A=
=0A=
    return range;=0A=
  };=0A=
=0A=
  // Function (ahem) Functions=0A=
  // ------------------=0A=
=0A=
  // Create a function bound to a given object (assigning `this`, and =
arguments,=0A=
  // optionally). Binding with arguments is also known as `curry`.=0A=
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.=0A=
  // We check for `func.bind` first, to fail fast when `func` is =
undefined.=0A=
  _.bind =3D function(func, obj) {=0A=
    if (func.bind =3D=3D=3D nativeBind && nativeBind) return =
nativeBind.apply(func, slice.call(arguments, 1));=0A=
    var args =3D slice.call(arguments, 2);=0A=
    return function() {=0A=
      return func.apply(obj, args.concat(slice.call(arguments)));=0A=
    };=0A=
  };=0A=
=0A=
  // Bind all of an object's methods to that object. Useful for ensuring =
that=0A=
  // all callbacks defined on an object belong to it.=0A=
  _.bindAll =3D function(obj) {=0A=
    var funcs =3D slice.call(arguments, 1);=0A=
    if (funcs.length =3D=3D 0) funcs =3D _.functions(obj);=0A=
    each(funcs, function(f) { obj[f] =3D _.bind(obj[f], obj); });=0A=
    return obj;=0A=
  };=0A=
=0A=
  // Memoize an expensive function by storing its results.=0A=
  _.memoize =3D function(func, hasher) {=0A=
    var memo =3D {};=0A=
    hasher || (hasher =3D _.identity);=0A=
    return function() {=0A=
      var key =3D hasher.apply(this, arguments);=0A=
      return hasOwnProperty.call(memo, key) ? memo[key] : (memo[key] =3D =
func.apply(this, arguments));=0A=
    };=0A=
  };=0A=
=0A=
  // Delays a function for the given number of milliseconds, and then =
calls=0A=
  // it with the arguments supplied.=0A=
  _.delay =3D function(func, wait) {=0A=
    var args =3D slice.call(arguments, 2);=0A=
    return setTimeout(function(){ return func.apply(func, args); }, =
wait);=0A=
  };=0A=
=0A=
  // Defers a function, scheduling it to run after the current call =
stack has=0A=
  // cleared.=0A=
  _.defer =3D function(func) {=0A=
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));=0A=
  };=0A=
=0A=
  // Internal function used to implement `_.throttle` and `_.debounce`.=0A=
  var limit =3D function(func, wait, debounce) {=0A=
    var timeout;=0A=
    return function() {=0A=
      var context =3D this, args =3D arguments;=0A=
      var throttler =3D function() {=0A=
        timeout =3D null;=0A=
        func.apply(context, args);=0A=
      };=0A=
      if (debounce) clearTimeout(timeout);=0A=
      if (debounce || !timeout) timeout =3D setTimeout(throttler, wait);=0A=
    };=0A=
  };=0A=
=0A=
  // Returns a function, that, when invoked, will only be triggered at =
most once=0A=
  // during a given window of time.=0A=
  _.throttle =3D function(func, wait) {=0A=
    return limit(func, wait, false);=0A=
  };=0A=
=0A=
  // Returns a function, that, as long as it continues to be invoked, =
will not=0A=
  // be triggered. The function will be called after it stops being =
called for=0A=
  // N milliseconds.=0A=
  _.debounce =3D function(func, wait) {=0A=
    return limit(func, wait, true);=0A=
  };=0A=
=0A=
  // Returns a function that will be executed at most one time, no =
matter how=0A=
  // often you call it. Useful for lazy initialization.=0A=
  _.once =3D function(func) {=0A=
    var ran =3D false, memo;=0A=
    return function() {=0A=
      if (ran) return memo;=0A=
      ran =3D true;=0A=
      return memo =3D func.apply(this, arguments);=0A=
    };=0A=
  };=0A=
=0A=
  // Returns the first function passed as an argument to the second,=0A=
  // allowing you to adjust arguments, run code before and after, and=0A=
  // conditionally execute the original function.=0A=
  _.wrap =3D function(func, wrapper) {=0A=
    return function() {=0A=
      var args =3D [func].concat(slice.call(arguments));=0A=
      return wrapper.apply(this, args);=0A=
    };=0A=
  };=0A=
=0A=
  // Returns a function that is the composition of a list of functions, =
each=0A=
  // consuming the return value of the function that follows.=0A=
  _.compose =3D function() {=0A=
    var funcs =3D slice.call(arguments);=0A=
    return function() {=0A=
      var args =3D slice.call(arguments);=0A=
      for (var i=3Dfuncs.length-1; i >=3D 0; i--) {=0A=
        args =3D [funcs[i].apply(this, args)];=0A=
      }=0A=
      return args[0];=0A=
    };=0A=
  };=0A=
=0A=
  // Returns a function that will only be executed after being called N =
times.=0A=
  _.after =3D function(times, func) {=0A=
    return function() {=0A=
      if (--times < 1) { return func.apply(this, arguments); }=0A=
    };=0A=
  };=0A=
=0A=
=0A=
  // Object Functions=0A=
  // ----------------=0A=
=0A=
  // Retrieve the names of an object's properties.=0A=
  // Delegates to **ECMAScript 5**'s native `Object.keys`=0A=
  _.keys =3D nativeKeys || function(obj) {=0A=
    if (obj !=3D=3D Object(obj)) throw new TypeError('Invalid object');=0A=
    var keys =3D [];=0A=
    for (var key in obj) if (hasOwnProperty.call(obj, key)) =
keys[keys.length] =3D key;=0A=
    return keys;=0A=
  };=0A=
=0A=
  // Retrieve the values of an object's properties.=0A=
  _.values =3D function(obj) {=0A=
    return _.map(obj, _.identity);=0A=
  };=0A=
=0A=
  // Return a sorted list of the function names available on the object.=0A=
  // Aliased as `methods`=0A=
  _.functions =3D _.methods =3D function(obj) {=0A=
    return _.filter(_.keys(obj), function(key){ return =
_.isFunction(obj[key]); }).sort();=0A=
  };=0A=
=0A=
  // Extend a given object with all the properties in passed-in =
object(s).=0A=
  _.extend =3D function(obj) {=0A=
    each(slice.call(arguments, 1), function(source) {=0A=
      for (var prop in source) {=0A=
        if (source[prop] !=3D=3D void 0) obj[prop] =3D source[prop];=0A=
      }=0A=
    });=0A=
    return obj;=0A=
  };=0A=
=0A=
  // Fill in a given object with default properties.=0A=
  _.defaults =3D function(obj) {=0A=
    each(slice.call(arguments, 1), function(source) {=0A=
      for (var prop in source) {=0A=
        if (obj[prop] =3D=3D null) obj[prop] =3D source[prop];=0A=
      }=0A=
    });=0A=
    return obj;=0A=
  };=0A=
=0A=
  // Create a (shallow-cloned) duplicate of an object.=0A=
  _.clone =3D function(obj) {=0A=
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);=0A=
  };=0A=
=0A=
  // Invokes interceptor with the obj, and then returns obj.=0A=
  // The primary purpose of this method is to "tap into" a method chain, =
in=0A=
  // order to perform operations on intermediate results within the =
chain.=0A=
  _.tap =3D function(obj, interceptor) {=0A=
    interceptor(obj);=0A=
    return obj;=0A=
  };=0A=
=0A=
  // Perform a deep comparison to check if two objects are equal.=0A=
  _.isEqual =3D function(a, b) {=0A=
    // Check object identity.=0A=
    if (a =3D=3D=3D b) return true;=0A=
    // Different types?=0A=
    var atype =3D typeof(a), btype =3D typeof(b);=0A=
    if (atype !=3D btype) return false;=0A=
    // Basic equality test (watch out for coercions).=0A=
    if (a =3D=3D b) return true;=0A=
    // One is falsy and the other truthy.=0A=
    if ((!a && b) || (a && !b)) return false;=0A=
    // Unwrap any wrapped objects.=0A=
    if (a._chain) a =3D a._wrapped;=0A=
    if (b._chain) b =3D b._wrapped;=0A=
    // One of them implements an isEqual()?=0A=
    if (a.isEqual) return a.isEqual(b);=0A=
    // Check dates' integer values.=0A=
    if (_.isDate(a) && _.isDate(b)) return a.getTime() =3D=3D=3D =
b.getTime();=0A=
    // Both are NaN?=0A=
    if (_.isNaN(a) && _.isNaN(b)) return false;=0A=
    // Compare regular expressions.=0A=
    if (_.isRegExp(a) && _.isRegExp(b))=0A=
      return a.source     =3D=3D=3D b.source &&=0A=
             a.global     =3D=3D=3D b.global &&=0A=
             a.ignoreCase =3D=3D=3D b.ignoreCase &&=0A=
             a.multiline  =3D=3D=3D b.multiline;=0A=
    // If a is not an object by this point, we can't handle it.=0A=
    if (atype !=3D=3D 'object') return false;=0A=
    // Check for different array lengths before comparing contents.=0A=
    if (a.length && (a.length !=3D=3D b.length)) return false;=0A=
    // Nothing else worked, deep compare the contents.=0A=
    var aKeys =3D _.keys(a), bKeys =3D _.keys(b);=0A=
    // Different object sizes?=0A=
    if (aKeys.length !=3D bKeys.length) return false;=0A=
    // Recursive comparison of contents.=0A=
    for (var key in a) if (!(key in b) || !_.isEqual(a[key], b[key])) =
return false;=0A=
    return true;=0A=
  };=0A=
=0A=
  // Is a given array or object empty?=0A=
  _.isEmpty =3D function(obj) {=0A=
    if (_.isArray(obj) || _.isString(obj)) return obj.length =3D=3D=3D 0;=0A=
    for (var key in obj) if (hasOwnProperty.call(obj, key)) return false;=0A=
    return true;=0A=
  };=0A=
=0A=
  // Is a given value a DOM element?=0A=
  _.isElement =3D function(obj) {=0A=
    return !!(obj && obj.nodeType =3D=3D 1);=0A=
  };=0A=
=0A=
  // Is a given value an array?=0A=
  // Delegates to ECMA5's native Array.isArray=0A=
  _.isArray =3D nativeIsArray || function(obj) {=0A=
    return toString.call(obj) =3D=3D=3D '[object Array]';=0A=
  };=0A=
=0A=
  // Is a given variable an arguments object?=0A=
  _.isArguments =3D function(obj) {=0A=
    return !!(obj && hasOwnProperty.call(obj, 'callee'));=0A=
  };=0A=
=0A=
  // Is a given value a function?=0A=
  _.isFunction =3D function(obj) {=0A=
    return !!(obj && obj.constructor && obj.call && obj.apply);=0A=
  };=0A=
=0A=
  // Is a given value a string?=0A=
  _.isString =3D function(obj) {=0A=
    return !!(obj =3D=3D=3D '' || (obj && obj.charCodeAt && obj.substr));=0A=
  };=0A=
=0A=
  // Is a given value a number?=0A=
  _.isNumber =3D function(obj) {=0A=
    return !!(obj =3D=3D=3D 0 || (obj && obj.toExponential && =
obj.toFixed));=0A=
  };=0A=
=0A=
  // Is the given value `NaN`? `NaN` happens to be the only value in =
JavaScript=0A=
  // that does not equal itself.=0A=
  _.isNaN =3D function(obj) {=0A=
    return obj !=3D=3D obj;=0A=
  };=0A=
=0A=
  // Is a given value a boolean?=0A=
  _.isBoolean =3D function(obj) {=0A=
    return obj =3D=3D=3D true || obj =3D=3D=3D false;=0A=
  };=0A=
=0A=
  // Is a given value a date?=0A=
  _.isDate =3D function(obj) {=0A=
    return !!(obj && obj.getTimezoneOffset && obj.setUTCFullYear);=0A=
  };=0A=
=0A=
  // Is the given value a regular expression?=0A=
  _.isRegExp =3D function(obj) {=0A=
    return !!(obj && obj.test && obj.exec && (obj.ignoreCase || =
obj.ignoreCase =3D=3D=3D false));=0A=
  };=0A=
=0A=
  // Is a given value equal to null?=0A=
  _.isNull =3D function(obj) {=0A=
    return obj =3D=3D=3D null;=0A=
  };=0A=
=0A=
  // Is a given variable undefined?=0A=
  _.isUndefined =3D function(obj) {=0A=
    return obj =3D=3D=3D void 0;=0A=
  };=0A=
=0A=
  // Utility Functions=0A=
  // -----------------=0A=
=0A=
  // Run Underscore.js in *noConflict* mode, returning the `_` variable =
to its=0A=
  // previous owner. Returns a reference to the Underscore object.=0A=
  _.noConflict =3D function() {=0A=
    root._ =3D previousUnderscore;=0A=
    return this;=0A=
  };=0A=
=0A=
  // Keep the identity function around for default iterators.=0A=
  _.identity =3D function(value) {=0A=
    return value;=0A=
  };=0A=
=0A=
  // Run a function **n** times.=0A=
  _.times =3D function (n, iterator, context) {=0A=
    for (var i =3D 0; i < n; i++) iterator.call(context, i);=0A=
  };=0A=
=0A=
  // Add your own custom functions to the Underscore object, ensuring =
that=0A=
  // they're correctly added to the OOP wrapper as well.=0A=
  _.mixin =3D function(obj) {=0A=
    each(_.functions(obj), function(name){=0A=
      addToWrapper(name, _[name] =3D obj[name]);=0A=
    });=0A=
  };=0A=
=0A=
  // Generate a unique integer id (unique within the entire client =
session).=0A=
  // Useful for temporary DOM ids.=0A=
  var idCounter =3D 0;=0A=
  _.uniqueId =3D function(prefix) {=0A=
    var id =3D idCounter++;=0A=
    return prefix ? prefix + id : id;=0A=
  };=0A=
=0A=
  // By default, Underscore uses ERB-style template delimiters, change =
the=0A=
  // following template settings to use alternative delimiters.=0A=
  _.templateSettings =3D {=0A=
    evaluate    : /<%([\s\S]+?)%>/g,=0A=
    interpolate : /<%=3D([\s\S]+?)%>/g=0A=
  };=0A=
=0A=
  // JavaScript micro-templating, similar to John Resig's implementation.=0A=
  // Underscore templating handles arbitrary delimiters, preserves =
whitespace,=0A=
  // and correctly escapes quotes within interpolated code.=0A=
  _.template =3D function(str, data) {=0A=
    var c  =3D _.templateSettings;=0A=
    var tmpl =3D 'var =
__p=3D[],print=3Dfunction(){__p.push.apply(__p,arguments);};' +=0A=
      'with(obj||{}){__p.push(\'' +=0A=
      str.replace(/\\/g, '\\\\')=0A=
         .replace(/'/g, "\\'")=0A=
         .replace(c.interpolate, function(match, code) {=0A=
           return "'," + code.replace(/\\'/g, "'") + ",'";=0A=
         })=0A=
         .replace(c.evaluate || null, function(match, code) {=0A=
           return "');" + code.replace(/\\'/g, "'")=0A=
                              .replace(/[\r\n\t]/g, ' ') + "__p.push('";=0A=
         })=0A=
         .replace(/\r/g, '\\r')=0A=
         .replace(/\n/g, '\\n')=0A=
         .replace(/\t/g, '\\t')=0A=
         + "');}return __p.join('');";=0A=
    var func =3D new Function('obj', tmpl);=0A=
    return data ? func(data) : func;=0A=
  };=0A=
=0A=
  // The OOP Wrapper=0A=
  // ---------------=0A=
=0A=
  // If Underscore is called as a function, it returns a wrapped object =
that=0A=
  // can be used OO-style. This wrapper holds altered versions of all the=0A=
  // underscore functions. Wrapped objects may be chained.=0A=
  var wrapper =3D function(obj) { this._wrapped =3D obj; };=0A=
=0A=
  // Expose `wrapper.prototype` as `_.prototype`=0A=
  _.prototype =3D wrapper.prototype;=0A=
=0A=
  // Helper function to continue chaining intermediate results.=0A=
  var result =3D function(obj, chain) {=0A=
    return chain ? _(obj).chain() : obj;=0A=
  };=0A=
=0A=
  // A method to easily add functions to the OOP wrapper.=0A=
  var addToWrapper =3D function(name, func) {=0A=
    wrapper.prototype[name] =3D function() {=0A=
      var args =3D slice.call(arguments);=0A=
      unshift.call(args, this._wrapped);=0A=
      return result(func.apply(_, args), this._chain);=0A=
    };=0A=
  };=0A=
=0A=
  // Add all of the Underscore functions to the wrapper object.=0A=
  _.mixin(_);=0A=
=0A=
  // Add all mutator Array functions to the wrapper.=0A=
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], =
function(name) {=0A=
    var method =3D ArrayProto[name];=0A=
    wrapper.prototype[name] =3D function() {=0A=
      method.apply(this._wrapped, arguments);=0A=
      return result(this._wrapped, this._chain);=0A=
    };=0A=
  });=0A=
=0A=
  // Add all accessor Array functions to the wrapper.=0A=
  each(['concat', 'join', 'slice'], function(name) {=0A=
    var method =3D ArrayProto[name];=0A=
    wrapper.prototype[name] =3D function() {=0A=
      return result(method.apply(this._wrapped, arguments), this._chain);=0A=
    };=0A=
  });=0A=
=0A=
  // Start chaining a wrapped Underscore object.=0A=
  wrapper.prototype.chain =3D function() {=0A=
    this._chain =3D true;=0A=
    return this;=0A=
  };=0A=
=0A=
  // Extracts the result from a wrapped and chained object.=0A=
  wrapper.prototype.value =3D function() {=0A=
    return this._wrapped;=0A=
  };=0A=
=0A=
})();=0A=

------=_NextPart_000_0000_01CD8C89.6E361A20
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://docs.opencv.org/_static/doctools.js

/*=0A=
 * doctools.js=0A=
 * ~~~~~~~~~~~=0A=
 *=0A=
 * Sphinx JavaScript utilties for all documentation.=0A=
 *=0A=
 * :copyright: Copyright 2007-2011 by the Sphinx team, see AUTHORS.=0A=
 * :license: BSD, see LICENSE for details.=0A=
 *=0A=
 */=0A=
=0A=
/**=0A=
 * select a different prefix for underscore=0A=
 */=0A=
$u =3D _.noConflict();=0A=
=0A=
/**=0A=
 * make the code below compatible with browsers without=0A=
 * an installed firebug like debugger=0A=
if (!window.console || !console.firebug) {=0A=
  var names =3D ["log", "debug", "info", "warn", "error", "assert", =
"dir",=0A=
    "dirxml", "group", "groupEnd", "time", "timeEnd", "count", "trace",=0A=
    "profile", "profileEnd"];=0A=
  window.console =3D {};=0A=
  for (var i =3D 0; i < names.length; ++i)=0A=
    window.console[names[i]] =3D function() {};=0A=
}=0A=
 */=0A=
=0A=
/**=0A=
 * small helper function to urldecode strings=0A=
 */=0A=
jQuery.urldecode =3D function(x) {=0A=
  return decodeURIComponent(x).replace(/\+/g, ' ');=0A=
}=0A=
=0A=
/**=0A=
 * small helper function to urlencode strings=0A=
 */=0A=
jQuery.urlencode =3D encodeURIComponent;=0A=
=0A=
/**=0A=
 * This function returns the parsed url parameters of the=0A=
 * current request. Multiple values per key are supported,=0A=
 * it will always return arrays of strings for the value parts.=0A=
 */=0A=
jQuery.getQueryParameters =3D function(s) {=0A=
  if (typeof s =3D=3D 'undefined')=0A=
    s =3D document.location.search;=0A=
  var parts =3D s.substr(s.indexOf('?') + 1).split('&');=0A=
  var result =3D {};=0A=
  for (var i =3D 0; i < parts.length; i++) {=0A=
    var tmp =3D parts[i].split('=3D', 2);=0A=
    var key =3D jQuery.urldecode(tmp[0]);=0A=
    var value =3D jQuery.urldecode(tmp[1]);=0A=
    if (key in result)=0A=
      result[key].push(value);=0A=
    else=0A=
      result[key] =3D [value];=0A=
  }=0A=
  return result;=0A=
};=0A=
=0A=
/**=0A=
 * small function to check if an array contains=0A=
 * a given item.=0A=
 */=0A=
jQuery.contains =3D function(arr, item) {=0A=
  for (var i =3D 0; i < arr.length; i++) {=0A=
    if (arr[i] =3D=3D item)=0A=
      return true;=0A=
  }=0A=
  return false;=0A=
};=0A=
=0A=
/**=0A=
 * highlight a given string on a jquery object by wrapping it in=0A=
 * span elements with the given class name.=0A=
 */=0A=
jQuery.fn.highlightText =3D function(text, className) {=0A=
  function highlight(node) {=0A=
    if (node.nodeType =3D=3D 3) {=0A=
      var val =3D node.nodeValue;=0A=
      var pos =3D val.toLowerCase().indexOf(text);=0A=
      if (pos >=3D 0 && !jQuery(node.parentNode).hasClass(className)) {=0A=
        var span =3D document.createElement("span");=0A=
        span.className =3D className;=0A=
        span.appendChild(document.createTextNode(val.substr(pos, =
text.length)));=0A=
        node.parentNode.insertBefore(span, node.parentNode.insertBefore(=0A=
          document.createTextNode(val.substr(pos + text.length)),=0A=
          node.nextSibling));=0A=
        node.nodeValue =3D val.substr(0, pos);=0A=
      }=0A=
    }=0A=
    else if (!jQuery(node).is("button, select, textarea")) {=0A=
      jQuery.each(node.childNodes, function() {=0A=
        highlight(this);=0A=
      });=0A=
    }=0A=
  }=0A=
  return this.each(function() {=0A=
    highlight(this);=0A=
  });=0A=
};=0A=
=0A=
/**=0A=
 * Small JavaScript module for the documentation.=0A=
 */=0A=
var Documentation =3D {=0A=
=0A=
  init : function() {=0A=
    this.fixFirefoxAnchorBug();=0A=
    this.highlightSearchWords();=0A=
    this.initIndexTable();=0A=
  },=0A=
=0A=
  /**=0A=
   * i18n support=0A=
   */=0A=
  TRANSLATIONS : {},=0A=
  PLURAL_EXPR : function(n) { return n =3D=3D 1 ? 0 : 1; },=0A=
  LOCALE : 'unknown',=0A=
=0A=
  // gettext and ngettext don't access this so that the functions=0A=
  // can safely bound to a different name (_ =3D Documentation.gettext)=0A=
  gettext : function(string) {=0A=
    var translated =3D Documentation.TRANSLATIONS[string];=0A=
    if (typeof translated =3D=3D 'undefined')=0A=
      return string;=0A=
    return (typeof translated =3D=3D 'string') ? translated : =
translated[0];=0A=
  },=0A=
=0A=
  ngettext : function(singular, plural, n) {=0A=
    var translated =3D Documentation.TRANSLATIONS[singular];=0A=
    if (typeof translated =3D=3D 'undefined')=0A=
      return (n =3D=3D 1) ? singular : plural;=0A=
    return translated[Documentation.PLURALEXPR(n)];=0A=
  },=0A=
=0A=
  addTranslations : function(catalog) {=0A=
    for (var key in catalog.messages)=0A=
      this.TRANSLATIONS[key] =3D catalog.messages[key];=0A=
    this.PLURAL_EXPR =3D new Function('n', 'return +(' + =
catalog.plural_expr + ')');=0A=
    this.LOCALE =3D catalog.locale;=0A=
  },=0A=
=0A=
  /**=0A=
   * add context elements like header anchor links=0A=
   */=0A=
  addContextElements : function() {=0A=
    $('div[id] > :header:first').each(function() {=0A=
      $('<a class=3D"headerlink">\u00B6</a>').=0A=
      attr('href', '#' + this.id).=0A=
      attr('title', _('Permalink to this headline')).=0A=
      appendTo(this);=0A=
    });=0A=
    $('dt[id]').each(function() {=0A=
      $('<a class=3D"headerlink">\u00B6</a>').=0A=
      attr('href', '#' + this.id).=0A=
      attr('title', _('Permalink to this definition')).=0A=
      appendTo(this);=0A=
    });=0A=
  },=0A=
=0A=
  /**=0A=
   * workaround a firefox stupidity=0A=
   */=0A=
  fixFirefoxAnchorBug : function() {=0A=
    if (document.location.hash && $.browser.mozilla)=0A=
      window.setTimeout(function() {=0A=
        document.location.href +=3D '';=0A=
      }, 10);=0A=
  },=0A=
=0A=
  /**=0A=
   * highlight the search words provided in the url in the text=0A=
   */=0A=
  highlightSearchWords : function() {=0A=
    var params =3D $.getQueryParameters();=0A=
    var terms =3D (params.highlight) ? params.highlight[0].split(/\s+/) =
: [];=0A=
    if (terms.length) {=0A=
      var body =3D $('div.body');=0A=
      window.setTimeout(function() {=0A=
        $.each(terms, function() {=0A=
          body.highlightText(this.toLowerCase(), 'highlighted');=0A=
        });=0A=
      }, 10);=0A=
      $('<li class=3D"highlight-link"><a =
href=3D"javascript:Documentation.' +=0A=
        'hideSearchWords()">' + _('Hide Search Matches') + '</a></li>')=0A=
          .appendTo($('.sidebar .this-page-menu'));=0A=
    }=0A=
  },=0A=
=0A=
  /**=0A=
   * init the domain index toggle buttons=0A=
   */=0A=
  initIndexTable : function() {=0A=
    var togglers =3D $('img.toggler').click(function() {=0A=
      var src =3D $(this).attr('src');=0A=
      var idnum =3D $(this).attr('id').substr(7);=0A=
      $('tr.cg-' + idnum).toggle();=0A=
      if (src.substr(-9) =3D=3D 'minus.png')=0A=
        $(this).attr('src', src.substr(0, src.length-9) + 'plus.png');=0A=
      else=0A=
        $(this).attr('src', src.substr(0, src.length-8) + 'minus.png');=0A=
    }).css('display', '');=0A=
    if (DOCUMENTATION_OPTIONS.COLLAPSE_INDEX) {=0A=
        togglers.click();=0A=
    }=0A=
  },=0A=
=0A=
  /**=0A=
   * helper function to hide the search marks again=0A=
   */=0A=
  hideSearchWords : function() {=0A=
    $('.sidebar .this-page-menu li.highlight-link').fadeOut(300);=0A=
    $('span.highlighted').removeClass('highlighted');=0A=
  },=0A=
=0A=
  /**=0A=
   * make the url absolute=0A=
   */=0A=
  makeURL : function(relativeURL) {=0A=
    return DOCUMENTATION_OPTIONS.URL_ROOT + '/' + relativeURL;=0A=
  },=0A=
=0A=
  /**=0A=
   * get the current relative url=0A=
   */=0A=
  getCurrentURL : function() {=0A=
    var path =3D document.location.pathname;=0A=
    var parts =3D path.split(/\//);=0A=
    $.each(DOCUMENTATION_OPTIONS.URL_ROOT.split(/\//), function() {=0A=
      if (this =3D=3D '..')=0A=
        parts.pop();=0A=
    });=0A=
    var url =3D parts.join('/');=0A=
    return path.substring(url.lastIndexOf('/') + 1, path.length - 1);=0A=
  }=0A=
};=0A=
=0A=
// quick alias for translations=0A=
_ =3D Documentation.gettext;=0A=
=0A=
$(document).ready(function() {=0A=
  Documentation.init();=0A=
});=0A=

------=_NextPart_000_0000_01CD8C89.6E361A20
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://docs.opencv.org/_static/insertIframe.js

function insertIframe (elementId, iframeSrc) =0A=
{=0A=
  var iframe;=0A=
  if (document.createElement && (iframe =3D =
document.createElement('iframe')))=0A=
  {=0A=
    iframe.src =3D unescape(iframeSrc);=0A=
    iframe.width =3D "100%";=0A=
    iframe.height =3D "511px";=0A=
    var element =3D document.getElementById(elementId);=0A=
    element.parentNode.replaceChild(iframe, element);=0A=
  }=0A=
}=0A=
=0A=

------=_NextPart_000_0000_01CD8C89.6E361A20--
